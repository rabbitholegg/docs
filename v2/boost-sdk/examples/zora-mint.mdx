---
title: "Boost an NFT Mint on Zora"
description: Learn how to reward users with ERC20 rewards when they mint an NFT on Zora.
---

In this example, you've created an NFT on Zora, and want to incentivize users to mint it by offering additional rewards.

<Warning>
Make sure you've completed the [quick start](/v2/boost-sdk/quick-start) guide.
</Warning>

First you'll need to either initialize a new budget, or use an existing one, and allow the budget to spend a certain amount of your selected ERC20.

<CodeGroup>
```ts index.ts
import { BoostCore } from '@boostxyz/sdk/BoostCore'
import { BoostRegistry } from '@boostxyz/sdk/BoostRegistry'
import { ManagedBudget, ManagedBudgetRoles } from '@boostxyz/sdk/Budgets/ManagedBudget'
import { parseUnits } from 'viem'
import { wagmiConfig } from '../config'

// Initialize the BoostCore and BoostRegistry modules
const registry = new BoostRegistry({ config: wagmiConfig }),
const core = new BoostCore({ config: wagmiConfig })

// Get the address of the BoostCore module
const coreAddress = core.assertValidAddress()

// Create a new budget and grant the correct permissions to the protocol
const budget = await registry.initialize('MyNewBudget', core.ManagedBudget({
  owner: '0xME',
  authorized: ['0xME', coreAddress],
  roles: [ManagedBudgetRoles.ADMIN, ManagedBudgetRoles.MANAGER]
}))

// Allow the budget to spend your ERC20 token
await writeContract(wagmiConfig, {
  abi,
  address: '0xERC20', // The address of the ERC20 token you want to approve
  functionName: 'approve',
  args: [
    budget.assertValidAddress(),
    parseUnits('100', 18) // The amount of ERC20 token you want to approve
  ]
})

// Allocate assets to the budget
await budget.allocate({
  amount: parseUnits('100', 18),
  asset: '0xERC20',
  target: '0xME',
})
```

```ts config.ts
import { http, createConfig } from '@wagmi/core'
import { mainnet, sepolia } from '@wagmi/core/chains'

export const wagmiConfig = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
})
```

</CodeGroup>

Next you'll need to define the action that qualifies a user to claim the reward.

For Zora, we want to reward users that mint a specific NFT on Zora. To do this, we'll key off of the `Purchased` event, 
which has the event signature `Purchased(address,address,uint256,uint256,uint256)`.

<Frame caption="'Purchased' Event Structure. Take note of the tokenId field which is at index 3.">
  <img src="/assets/event-purchased.png" alt="Purchased Event" />
</Frame>

Here is how you can structure the EventActionPayload to target the `Purchased` event.

<Tip>
  If you're using a known event, you can use the selectors package to get the signature.
    ```ts
    import { selectors } from '@boostxyz/signatures/events'
    const selector = selectors[
      'Purchased(address,address,uint256,uint256,uint256)'
    ] as Hex;
    ```
</Tip>

```ts
import { 
  EventActionPayload, 
  ActionStep, 
  ActionClaimant, 
  SignatureType, 
  FilterType, 
  PrimitiveType 
} from '@boostxyz/sdk/Actions/EventAction'
import { selectors } from '@boostxyz/signatures/events'

// If one exists, use the signature from the selectors package
const selectedSignature = selectors[
  'Purchased(address,address,uint256,uint256,uint256)'
] as Hex;

// The EventAction step outlines the criteria that the validator uses to determine eligibility for reward redemption.
const eventActionStep: ActionStep = {
  signature: selectedSignature,
  signatureType: SignatureType.EVENT,
  targetContract: '0xZORA', // Address of the contract to observe for the event
  // We want to target the `tokenId` property on the Purchase event
  actionParameter: {
    filterType: FilterType.EQUAL, // Filter to check for equality
    fieldType: PrimitiveType.UINT, // The field we're filtering is the tokenId
    fieldIndex: 3,
    filterData: '0xUINT256_TOKEN_ID', // We'll validate by comparing purchase events with a token ID that equals the this field
  },
};

```


Next, we need to define the action claimant and create the payload for the new event action.

The `eventAction` payload consists of the `actionClaimant` and the `actionSteps` we defined previously. 
The purpose of the `eventAction` is to track and reward users based on their interactions with the specified event.

1. **actionClaimant**: This object defines the conditions under which a user is eligible to claim rewards. It includes:
   - `signatureType`: Specifies that the signature type is an event.
   - `signature`: The event signature we are targeting, in this case, the `Purchased` event.
   - `fieldIndex`: Indicates which field in the event data we are interested in; here, it targets the 'from' address (the address that initiated the purchase).
   - `targetContract`: The address of the contract we are monitoring for the event.

2. **actionSteps**: This array can contain up to four action steps that outline the specific actions or conditions that must be met for the event action to be valid. In this example, we include the previously defined `eventActionStep`.

Next, we initialize the `EventAction` class from the `bases` module, passing in the default options and the constructed `eventActionPayload`. This creates a new event action.

```ts
const eventActionPayload = {
  actionClaimant: {
    signatureType: SignatureType.EVENT,
    signature: selectedSignature, // Purchased event signature
    fieldIndex: 0, // Targeting the 'from' address
    targetContract: targetContract, // The contract we're monitoring
  },
  actionSteps: [eventActionStep] // use can place up to 4 action steps
};

// Initialize EventAction with the custom payload
const eventAction = new bases.EventAction(
  defaultOptions,
  eventActionPayload,
);
```

Once the event action is created, we can set up the incentives and deploy our boost.

```ts
// This allows for 100 participants to be rewarded with 1 ERC20 token each
const incentives = [
    new bases.ERC20Incentive(defaultOptions, {
      asset: erc20.assertValidAddress(),
      reward: parseEther('1'),
      limit: 100n,
      strategy: StrategyType.POOL,
    }),
  ],
```

```ts
// Deploy the boost
await core.createBoost({
  maxParticipants: 100n, // Set a max number of participants
  budget: budget, // Use the ManagedBudget we set up earlier
  action: eventAction, // Pass the manually created EventAction
  incentives: incentives,
  validator: new bases.SignerValidator(defaultOptions, {
    signers: [owner, trustedSigner.account],
    validatorCaller: core.assertValidAddress(), 
  }),
  // The boost is available to all addresses. If you want to limit it to a specific address, you can use a SimpleAllowList
  allowList: new bases.SimpleDenyList(defaultOptions, {
    owner: owner,
    denied: [],
  }),
});
```
