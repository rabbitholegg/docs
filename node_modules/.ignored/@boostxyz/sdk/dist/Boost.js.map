{"version":3,"file":"Boost.js","sources":["../../../node_modules/.pnpm/solady@0.0.208/node_modules/solady/js/solady.js","../src/Boost.ts"],"sourcesContent":["/**\n * Accompanying JavaScript library for Solady.\n *\n * To install:\n * \n * ```\n * npm install solady\n * ```\n *\n * Module exports:\n * \n * - `LibZip`\n *   - `flzCompress(data)`: Compresses hex encoded data with FastLZ.\n *   - `flzDecompress(data)`: Decompresses hex encoded data with FastLZ.\n *   - `cdCompress(data)`: Compresses hex encoded calldata.\n *   - `cdDecompress(data)`: Decompresses hex encoded calldata.\n *   \n * - `ERC1967Factory`\n *   - `address`: Canonical address of Solady's ERC1967Factory.\n *   - `abi`: ABI of Solady's ERC1967Factory.\n *\n * @module solady\n */\n(function(global, factory) {\n\n    \"use strict\";\n\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        module.exports = factory(global, 1);\n        if (typeof exports === \"object\") {\n            exports.LibZip = module.exports.LibZip;\n            exports.ERC1967Factory = module.exports.ERC1967Factory;\n        }\n    } else {\n        factory(global);\n    }\n\n})(typeof window !== \"undefined\" ? window : this, function(window, noGlobal) {\n\n    \"use strict\";\n\n    var solady = {};\n\n    /*============================================================*/\n    /*                     LibZip Operations                      */\n    /*============================================================*/\n\n    // See: https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol\n\n    /**\n     * FastLZ and calldata compression / decompression functions.\n     * @namespace\n     * @alias module:solady.LibZip\n     */\n    var LibZip = {};\n\n    solady.LibZip = LibZip;\n\n    function hexString(data) {\n        if (typeof data === \"string\" || data instanceof String) {\n            if (data = data.match(/^[\\s\\uFEFF\\xA0]*(0[Xx])?([0-9A-Fa-f]*)[\\s\\uFEFF\\xA0]*$/)) {\n                if (data[2].length % 2) {\n                    throw new Error(\"Hex string length must be a multiple of 2.\");\n                }\n                return data[2];\n            }\n        }\n        throw new Error(\"Data must be a hex string.\");\n    }\n\n    function byteToString(b) {\n        return (b | 0x100).toString(16).slice(1);\n    }\n\n    function parseByte(data, i) {\n        return parseInt(data.substr(i, 2), 16);\n    }\n\n    function hexToBytes(data) {\n        var a = [], i = 0;\n        for (; i < data.length; i += 2) a.push(parseByte(data, i));\n        return a;\n    }\n\n    function bytesToHex(a) {\n        var o = \"0x\", i = 0;\n        for (; i < a.length; o += byteToString(a[i++])) ;\n        return o;\n    }\n\n    /**\n     * Compresses hex encoded data with the FastLZ LZ77 algorithm.\n     * @param {string} data A hex encoded string representing the original data.\n     * @returns {string} The compressed result as a hex encoded string.\n     */\n    LibZip.flzCompress = function(data) {\n        var ib = hexToBytes(hexString(data)), b = ib.length - 4;\n        var ht = [], ob = [], a = 0, i = 2, o = 0, j, s, h, d, c, l, r, p, q, e;\n\n        function u24(i) {\n            return ib[i] | (ib[++i] << 8) | (ib[++i] << 16);\n        }\n\n        function hash(x) {\n            return ((2654435769 * x) >> 19) & 8191;\n        }\n\n        function literals(r, s) {\n            while (r >= 32) for (ob[o++] = 31, j = 32; j--; r--) ob[o++] = ib[s++];\n            if (r) for (ob[o++] = r - 1; r--; ) ob[o++] = ib[s++];\n        }\n\n        while (i < b - 9) {\n            do {\n                r = ht[h = hash(s = u24(i))] || 0;\n                c = (d = (ht[h] = i) - r) < 8192 ? u24(r) : 0x1000000;\n            } while (i < b - 9 && i++ && s != c);\n            if (i >= b - 9) break;\n            if (--i > a) literals(i - a, a);\n            for (l = 0, p = r + 3, q = i + 3, e = b - q; l < e; l++) e *= ib[p + l] === ib[q + l];\n            i += l;\n            for (--d; l > 262; l -= 262) ob[o++] = 224 + (d >> 8), ob[o++] = 253, ob[o++] = d & 255;\n            if (l < 7) ob[o++] = (l << 5) + (d >> 8), ob[o++] = d & 255;\n            else ob[o++] = 224 + (d >> 8), ob[o++] = l - 7, ob[o++] = d & 255;\n            ht[hash(u24(i))] = i++, ht[hash(u24(i))] = i++, a = i;\n        }\n        literals(b + 4 - a, a);\n        return bytesToHex(ob);\n    }\n\n    /**\n     * Decompresses hex encoded data with the FastLZ LZ77 algorithm.\n     * @param {string} data A hex encoded string representing the compressed data.\n     * @returns {string} The decompressed result as a hex encoded string.\n     */\n    LibZip.flzDecompress = function(data) {\n        var ib = hexToBytes(hexString(data)), i = 0, o = 0, l, f, t, r, h, ob = [];\n        while (i < ib.length) {\n            if (!(t = ib[i] >> 5)) {\n                for (l = 1 + ib[i++]; l--;) ob[o++] = ib[i++];\n            } else {\n                f = 256 * (ib[i] & 31) + ib[i + 2 - (t = t < 7)];\n                l = t ? 2 + (ib[i] >> 5) : 9 + ib[i + 1];\n                i = i + 3 - t;\n                r = o - f - 1;\n                while (l--) ob[o++] = ob[r++];\n            }\n        }\n        return bytesToHex(ob);\n    }\n\n    /**\n     * Compresses hex encoded calldata.\n     * @param {string} data A hex encoded string representing the original data.\n     * @returns {string} The compressed result as a hex encoded string.\n     */\n    LibZip.cdCompress = function(data) {\n        data = hexString(data);\n        var o = \"0x\", z = 0, y = 0, i = 0, c;\n\n        function pushByte(b) {\n            o += byteToString(((o.length < 4 * 2 + 2) * 0xff) ^ b);\n        }\n\n        function rle(v, d) {\n            pushByte(0x00);\n            pushByte(d - 1 + v * 0x80);\n        }\n\n        for (; i < data.length; i += 2) {\n            c = parseByte(data, i);\n            if (!c) {\n                if (y) rle(1, y), y = 0;\n                if (++z === 0x80) rle(0, 0x80), z = 0;\n                continue;\n            }\n            if (c === 0xff) {\n                if (z) rle(0, z), z = 0;\n                if (++y === 0x20) rle(1, 0x20), y = 0;\n                continue;\n            }\n            if (y) rle(1, y), y = 0;\n            if (z) rle(0, z), z = 0;\n            pushByte(c);\n        }\n        if (y) rle(1, y), y = 0;\n        if (z) rle(0, z), z = 0;\n        return o;\n    }\n\n    /**\n     * Decompresses hex encoded calldata.\n     * @param {string} data A hex encoded string representing the compressed data.\n     * @returns {string} The decompressed result as a hex encoded string.\n     */\n    LibZip.cdDecompress = function(data) {\n        data = hexString(data);\n        var o = \"0x\", i = 0, j, c, s;\n\n        while (i < data.length) {\n            c = ((i < 4 * 2) * 0xff) ^ parseByte(data, i);\n            i += 2;\n            if (!c) {\n                c = ((i < 4 * 2) * 0xff) ^ parseByte(data, i);\n                s = (c & 0x7f) + 1;\n                i += 2;\n                for (j = 0; j < s; ++j) o += byteToString((c >> 7 && j < 32) * 0xff);\n                continue;\n            }\n            o += byteToString(c);\n        }\n        return o;\n    }\n\n    /*============================================================*/\n    /*                       ERC1967Factory                       */\n    /*============================================================*/\n\n    // See: https://github.com/vectorized/solady/blob/main/src/utils/ERC1967Factory.sol\n\n    /**\n     * ERC1967Factory canonical address and ABI.\n     * @namespace\n     * @alias module:solady.ERC1967Factory\n     */\n    var ERC1967Factory = {};\n\n    solady.ERC1967Factory = ERC1967Factory;\n\n    /**\n     * Canonical address of Solady's ERC1967Factory.\n     * @type {string}\n     */\n    ERC1967Factory.address = \"0x0000000000006396FF2a80c067f99B3d2Ab4Df24\";\n\n    /**\n     * ABI of Solady's ERC1967Factory.\n     * @type {Object}\n     */\n    ERC1967Factory.abi = JSON.parse('[{0:[],1:\"DeploymentFailed\"96\"SaltDoesNotStartWithCaller\"96\"Unauthorized\"96\"UpgradeFailed\",2:3959790,9791],1:\"AdminChanged\",2:10959790,9792,9791],1:\"Deployed\",2:10959790,9792],1:\"Upgraded\",2:10},{0:[{90],1:\"adminOf\",12:[{9199{0:[{90,{91],1:\"changeAdmin\",12:[],13:\"nonpayable\",2:15},{0:[{92,{91],1:\"deploy\",12:[{9098,{0:[{92,{91,{94],1:\"deployAndCall\",12:[{9098,{0:[{92,{91,{93],1:\"deployDeterministic\",12:[{9098,{0:[{92,{91,{93,{94],1:\"deployDeterministicAndCall\",12:[{9098,{0:[],1:\"initCodeHash\",12:[{6:19,1:\"result\",2:19}99{0:[{93],1:\"predictDeterministicAddress\",12:[{6:7,1:\"predicted\",2:7}99{0:[{90,{92],1:\"upgrade\",12:[98,{0:[{90,{92,{94],1:\"upgradeAndCall\",12:[98]'.replace(/9\\d/g, function (m) { return [\"6:7,1:8,2:7}\",\"6:7,1:9,2:7}\",\"6:7,1:11,2:7}\",\"6:19,1:20,2:19}\",\"6:17,1:18,2:17}\",\"},{4:false,0:[\",\",2:3},{0:[],1:\",\"{5:true,\",\"],13:16,2:15}\",\"],13:14,2:15},\"][m-90] }).replace(/\\d+/g, function (m) { return '\"' + (\"inputs,name,type,error,anonymous,indexed,internalType,address,proxy,admin,event,implementation,outputs,stateMutability,view,function,payable,bytes,data,bytes32,salt\".split(\",\")[m]) + '\"' }));\n\n    /*--------------------------- END ----------------------------*/\n\n    if (typeof define === \"function\" && define.amd) {\n        define(\"solady\", [], function() {\n            return solady\n        });\n    }\n\n    if (!noGlobal) {\n        window.solady = solady;\n    }\n\n    return solady;\n});\n","import { LibZip } from 'solady';\nimport {\n  type Address,\n  type Hex,\n  encodeAbiParameters,\n  parseAbiParameters,\n  zeroAddress,\n} from 'viem';\nimport type { Action } from './Actions/Action';\nimport type { AllowList } from './AllowLists/AllowList';\nimport type { Budget } from './Budgets/Budget';\nimport type { Incentive } from './Incentives/Incentive';\nimport type { Validator } from './Validators/Validator';\n\n/**\n * Interface representing a `BoostLib.Boost` on-chain struct\n *\n * @export\n * @interface BoostPayload\n * @typedef {BoostPayload}\n */\nexport interface RawBoost {\n  action: Address;\n  validator: Address;\n  allowList: Address;\n  budget: Address;\n  incentives: readonly Address[];\n  protocolFee: bigint;\n  referralFee: bigint;\n  maxParticipants: bigint;\n  owner: Address;\n}\n\n/**\n * Configuration used to instantiate a `Boost` instance.\n *\n * @export\n * @interface BoostPayload\n * @typedef {BoostPayload}\n */\nexport interface BoostConfig {\n  /**\n   *\n   * @type {bigint}\n   */\n  id: bigint;\n  /**\n   *\n   * @type {Budget}\n   */\n  budget: Budget;\n  /**\n   *\n   * @type {Action}\n   */\n  action: Action;\n  /**\n   *\n   * @type {Validator}\n   */\n  validator: Validator;\n  /**\n   *\n   * @type {AllowList}\n   */\n  allowList: AllowList;\n  /**\n   *\n   * @type {Array<Incentive>}\n   */\n  incentives: Array<Incentive>;\n  /**\n   *\n   * @type {?bigint}\n   */\n  protocolFee?: bigint;\n  /**\n   *\n   * @type {?bigint}\n   */\n  referralFee?: bigint;\n  /**\n   *\n   * @type {?bigint}\n   */\n  maxParticipants?: bigint;\n  /**\n   *\n   * @type {?Address}\n   */\n  owner?: Address;\n}\n\n/**\n * A struct representing a single Boost. Typically you would not construct this directly, rather get an instance from `BoostCore.createBoost` or `BoostCore.getBoost`\n *\n * @export\n * @class Boost\n * @typedef {Boost}\n */\nexport class Boost {\n  /**\n   *\n   * @readonly\n   * @type {bigint}\n   */\n  readonly id: bigint;\n  /**\n   *\n   * @readonly\n   * @type {Budget}\n   */\n  readonly budget: Budget;\n  /**\n   *\n   * @readonly\n   * @type {Action}\n   */\n  readonly action: Action;\n  /**\n   *\n   * @readonly\n   * @type {Validator}\n   */\n  readonly validator: Validator;\n  /**\n   *\n   * @readonly\n   * @type {AllowList}\n   */\n  readonly allowList: AllowList;\n  /**\n   *\n   * @readonly\n   * @type {Array<Incentive>}\n   */\n  readonly incentives: Array<Incentive>;\n  /**\n   *\n   * @readonly\n   * @type {bigint}\n   */\n  readonly protocolFee: bigint;\n  /**\n   *\n   * @readonly\n   * @type {bigint}\n   */\n  readonly referralFee: bigint;\n  /**\n   *\n   * @readonly\n   * @type {bigint}\n   */\n  readonly maxParticipants: bigint;\n  /**\n   *\n   * @readonly\n   * @type {Address}\n   */\n  readonly owner: Address;\n\n  /**\n   * Creates an instance of Boost.\n   *\n   * @constructor\n   * @param {BoostConfig} config\n   */\n  constructor(config: BoostConfig) {\n    this.id = config.id;\n    this.budget = config.budget;\n    this.action = config.action;\n    this.validator = config.validator;\n    this.allowList = config.allowList;\n    this.incentives = config.incentives;\n    this.protocolFee = config.protocolFee || 0n;\n    this.referralFee = config.referralFee || 0n;\n    this.maxParticipants = config.maxParticipants || 0n;\n    this.owner = config.owner || zeroAddress;\n  }\n}\n\n/**\n * Object representation of `BoostLib.Target` struct. Used for low level Boost creation operations.\n * This is used to pass the base contract and its initialization parameters in an efficient manner\n *\n * @export\n * @typedef {Target}\n */\nexport type Target = {\n  isBase: boolean;\n  instance: Address;\n  parameters: Hex;\n};\n\n/**\n * Object representation of `BoostCore.InitPayload` struct.\n *\n * @export\n * @interface BoostPayload\n * @typedef {BoostPayload}\n */\nexport interface BoostPayload {\n  /**\n   * Address to valid budget.\n   *\n   * @type {Address}\n   */\n  budget: Address;\n  /**\n   * Target for existing action, or base with initialization payload.\n   *\n   * @type {Target}\n   */\n  action: Target;\n  /**\n   * Target for existing validator, or base with initialization payload.\n   *\n   * @type {Target}\n   */\n  validator: Target;\n  /**\n   * Target for existing allowList, or base with initialization payload.\n   *\n   * @type {Target}\n   */\n  allowList: Target;\n  /**\n   * Targets for new incentives, with initialization payloads.\n   *\n   * @type {Target[]}\n   */\n  incentives: Target[];\n  /**\n   * The base protocol fee (in bps)\n   *\n   * @type {?bigint}\n   */\n  protocolFee?: bigint;\n  /**\n   * The base referral fee (in bps)\n   *\n   * @type {?bigint}\n   */\n  referralFee?: bigint;\n  /**\n   * Optional maximum amount of participants in the Boost.\n   *\n   * @type {?bigint}\n   */\n  maxParticipants?: bigint;\n  /**\n   * The owner of the Boost.\n   *\n   * @type {Address}\n   */\n  owner: Address;\n}\n\n/**\n * Given a valid {@link BoostPayload}, properly encode and compress the payload for use with `createBoost`\n *\n * @export\n * @param {BoostPayload} param0\n * @param {Address} param0.budget - Address to valid budget.\n * @param {Target} param0.action - Target for existing action, or base with initialization payload.\n * @param {Target} param0.validator - Target for existing validator, or base with initialization payload.\n * @param {Target} param0.allowList - Target for existing allowList, or base with initialization payload.\n * @param {Target[]} param0.incentives - Targets for new incentives, with initialization payloads.\n * @param {bigint} [param0.protocolFee=0n] - The base protocol fee (in bps)\n * @param {bigint} [param0.referralFee=0n] - The base referral fee (in bps)\n * @param {bigint} [param0.maxParticipants=0n] - Optional maximum amount of participants in the Boost.\n * @param {Address} param0.owner - The owner of the Boost.\n * @returns {Hex}\n */\nexport function prepareBoostPayload({\n  budget,\n  action,\n  validator,\n  allowList,\n  incentives,\n  protocolFee = 0n,\n  referralFee = 0n,\n  maxParticipants = 0n,\n  owner,\n}: BoostPayload): Hex {\n  return LibZip.cdCompress(\n    encodeAbiParameters(\n      parseAbiParameters([\n        'BoostPayload payload',\n        'struct BoostPayload { address budget; Target action; Target validator; Target allowList; Target[] incentives; uint64 protocolFee; uint64 referralFee; uint256 maxParticipants; address owner; }',\n        'struct Target { bool isBase; address instance; bytes parameters; }',\n      ]),\n      [\n        {\n          budget,\n          action,\n          validator,\n          allowList,\n          incentives,\n          protocolFee,\n          referralFee,\n          maxParticipants,\n          owner,\n        },\n      ],\n    ),\n  ) as Hex;\n}\n"],"names":["global","factory","module","exports","this","window","noGlobal","solady","LibZip","hexString","data","byteToString","b","parseByte","i","hexToBytes","a","bytesToHex","o","ib","ht","ob","j","s","h","d","c","l","r","p","q","e","u24","hash","x","literals","f","t","z","y","pushByte","rle","v","ERC1967Factory","m","Boost","config","zeroAddress","prepareBoostPayload","budget","action","validator","allowList","incentives","protocolFee","referralFee","maxParticipants","owner","encodeAbiParameters","parseAbiParameters"],"mappings":"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","x_google_ignoreList":[0]}