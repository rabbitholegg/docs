{"version":3,"file":"BoostRegistry.js","sources":["../src/BoostRegistry.ts"],"sourcesContent":["import {\n  boostRegistryAbi,\n  readBoostRegistryGetBaseImplementation,\n  readBoostRegistryGetCloneIdentifier,\n  readBoostRegistryGetClones,\n  simulateBoostRegistryDeployClone,\n  simulateBoostRegistryRegister,\n  writeBoostRegistryDeployClone,\n  writeBoostRegistryRegister,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/BoostRegistry.sol/BoostRegistry.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  isAddress,\n  zeroAddress,\n} from 'viem';\nimport { BoostRegistry as BoostRegistryBases } from '../dist/deployments.json';\nimport {\n  Deployable,\n  type DeployableOptions,\n  type GenericDeployableParams,\n} from './Deployable/Deployable';\nimport type { DeployableTarget } from './Deployable/DeployableTarget';\nimport {\n  type GenericLog,\n  type HashAndSimulatedResult,\n  type ReadParams,\n  type RegistryType,\n  type WriteParams,\n  assertValidAddressByChainId,\n} from './utils';\n\n/**\n * The ABI of the BoostRegistry contract, if needed for low level operations\n *\n * @type {typeof boostRegistryAbi}\n */\nexport { boostRegistryAbi };\n\n/**\n * The address of the deployed `BoostRegistry` instance. In prerelease mode, this will be its sepolia address\n *\n * @type {Address}\n */\nexport const BOOST_REGISTRY_ADDRESS =\n  (BoostRegistryBases as Record<string, Address>)[__DEFAULT_CHAIN_ID__] ||\n  zeroAddress;\n\n/**\n * The fixed addresses for the deployed Boost Registry.\n * By default, `new BoostRegistry` will use the address deployed to the currently connected chain, or `BOOST_REGISTRY_ADDRESS` if not provided.\n *\n * @type {Record<number, Address>}\n */\nexport const BOOST_REGISTRY_ADDRESSES: Record<number, Address> = {\n  ...(BoostRegistryBases as Record<number, Address>),\n  31337: import.meta.env.VITE_BOOST_REGISTRY_ADDRESS,\n};\n\n/**\n * A record of `BoostRegistry` event names to `AbiEvent` objects for use with `getLogs`\n *\n * @export\n * @typedef {BoostRegistryLog}\n * @template {ContractEventName<typeof boostRegistryAbi>} [event=ContractEventName<\n *     typeof boostRegistryAbi\n *   >]\n */\nexport type BoostRegistryLog<\n  event extends ContractEventName<typeof boostRegistryAbi> = ContractEventName<\n    typeof boostRegistryAbi\n  >,\n> = GenericLog<typeof boostRegistryAbi, event>;\n\n/**\n * Instantiation options for a previously deployed Boost Registry\n *\n * @export\n * @interface BoostRegistryDeployedOptions\n * @typedef {BoostRegistryDeployedOptions}\n * @extends {DeployableOptions}\n */\nexport interface BoostRegistryDeployedOptions extends DeployableOptions {\n  /**\n   * The address for a Boost Registry, if different than `BOOST_REGISTRY_ADDRESS`\n   *\n   * @type {?Address}\n   */\n  address?: Address;\n}\n\n/**\n * A typeguard to determine if instantiation is using a custom address.\n *\n * @param {*} opts\n * @returns {opts is BoostRegistryDeployedOptions}\n */\nfunction isBoostRegistryDeployed(\n  // biome-ignore lint/suspicious/noExplicitAny: type guard\n  opts: any,\n): opts is BoostRegistryDeployedOptions {\n  return opts.address && isAddress(opts.address);\n}\n\n/**\n * The Boost Registry does not take any construction arguments, so if you'd like to deploy a new Boost Registry, pass an explicit null to the `address` field.\n *\n * @export\n * @interface BoostRegistryOptionsWithPayload\n * @typedef {BoostRegistryOptionsWithPayload}\n * @extends {DeployableOptions}\n */\nexport interface BoostRegistryOptionsWithPayload extends DeployableOptions {\n  /**\n   *\n   * @type {null}\n   */\n  address: null;\n}\n\n/**\n * A typeguard to determine if the user is intending to deploy a new Boost Registry before usage\n *\n * @param {*} opts\n * @returns {opts is BoostRegistryOptionsWithPayload}\n */\nfunction isBoostRegistryDeployable(\n  // biome-ignore lint/suspicious/noExplicitAny: type guard\n  opts: any,\n): opts is BoostRegistryOptionsWithPayload {\n  return opts.address === null;\n}\n\n/**\n * Instantiation options for a Boost Registry.\n *\n * @example\n * To target Boost's Registry, omit the address field.\n * Otherwise, supply a custom address to a previously deployed custom Boost Registry.\n * You can also pass `{ address: null }` if you are intending to deploy a new Boost Registry.\n * ```ts\n * let registry = new BoostRegistry({ config, account })\n * // or\n * registry = new BoostRegistry({ config, account, address: CUSTOM_ADDRESS })\n * // or\n * registry = new BoostRegistry({ config, account, address: null })\n * await registry.deploy()\n * ```\n *\n * @export\n * @typedef {BoostRegistryConfig}\n */\nexport type BoostRegistryConfig =\n  | BoostRegistryDeployedOptions\n  | BoostRegistryOptionsWithPayload;\n\n/**\n * Constructs a new Boost Registry. A registry for base implementations and cloned instances.\n * This contract is used to register base implementations and deploy new instances of those implementations for use within the Boost protocol.\n *\n * @see {@link BoostRegistryConfig}\n * @export\n * @class BoostRegistry\n * @typedef {BoostRegistry}\n * @extends {Deployable<never[]>}\n */\nexport class BoostRegistry extends Deployable<\n  never[],\n  typeof boostRegistryAbi\n> {\n  /**\n   * A static property representing a map of stringified chain ID's to the address of the deployed implementation on chain\n   *\n   * @static\n   * @readonly\n   * @type {Record<string, Address>}\n   */\n  static readonly addresses: Record<number, Address> = BOOST_REGISTRY_ADDRESSES;\n\n  /**\n   * A getter that will return Boost registry's static addresses by numerical chain ID\n   *\n   * @public\n   * @readonly\n   * @type {Record<number, Address>}\n   */\n  public get addresses(): Record<number, Address> {\n    return (this.constructor as typeof BoostRegistry).addresses;\n  }\n\n  /**\n   * Creates an instance of BoostRegistry.\n   *\n   * @see {@link BoostRegistryConfig}\n   * @constructor\n   * @param {BoostRegistryConfig} param0\n   * @param {Config} param0.config - [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)\n   * @param {?Account} [param0.account] - [Viem Local Account](https://viem.sh/docs/accounts/local)\n   * @param {({ address?: Address; } | {})} param0....options\n   */\n  constructor({ config, account, ...options }: BoostRegistryConfig) {\n    if (isBoostRegistryDeployed(options) && options.address) {\n      super({ account, config }, options.address);\n    } else if (isBoostRegistryDeployable(options)) {\n      super({ account, config }, []);\n    } else {\n      const { address } = assertValidAddressByChainId(\n        config,\n        BOOST_REGISTRY_ADDRESSES,\n      );\n      super({ account, config }, address);\n    }\n  }\n\n  /**\n   *  Register a new base implementation of a given type\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {string} name - A name for the implementation (must be unique within the given type)\n   * @param {Address} implementation - The address of the implementation contract\n   * @param {?WriteParams} [params] - Optional params to provide the underlying Viem contract call\n   * @returns {Promise<void>}\n   * @example\n   * ```ts\n   * await registry.register(ContractAction.registryType, 'ContractAction', ContractAction.base)\n   * ```\n   */\n  public async register(\n    registryType: RegistryType,\n    name: string,\n    implementation: Address,\n    params?: WriteParams<typeof boostRegistryAbi, 'register'>,\n  ) {\n    return await this.awaitResult(\n      this.registerRaw(registryType, name, implementation, params),\n    );\n  }\n\n  /**\n   * @see {@link register}\n   * @public\n   * @async\n   * @param {RegistryType} registryType\n   * @param {string} name\n   * @param {Address} implementation\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async registerRaw(\n    registryType: RegistryType,\n    name: string,\n    implementation: Address,\n    params?: WriteParams<typeof boostRegistryAbi, 'register'>,\n  ) {\n    const { request, result } = await simulateBoostRegistryRegister(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [registryType, name, implementation],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostRegistryRegister(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Initialize a new instance of a registered base implementation, returning the provided target with a new address set on it.\n   * This method is the same as `clone`, but serves to make its function more obvious as to why you'd need to use it.\n   *\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName - The display name for the clone\n   * @param {Target} target - An instance of a target contract to clone and initialize\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Target>} - The provided instance, but with a new address attached.\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public initialize<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Target> {\n    return this.clone(displayName, target, params);\n  }\n\n  /**\n   * Deploy a new instance of a registered base implementation, returning the provided target with a new address set on it.\n   *\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName - The display name for the clone\n   * @param {Target} target - An instance of a target contract to clone and initialize\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Target>} - The provided instance, but with a new address attached.\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async clone<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Target> {\n    const instance = await this.deployClone(displayName, target, params);\n    return target.at(instance);\n  }\n\n  /**\n   *\n   * @see {@link clone}\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName\n   * @param {Target} target\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Address>}\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async deployClone<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Address> {\n    return await this.awaitResult(\n      this.deployCloneRaw(displayName, target, params),\n    );\n  }\n\n  /**\n   * @see {@link clone}\n   * @public\n   * @async\n   * @param {string} displayName\n   * @param {DeployableTarget} target\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: Hex, result: Address }>} - The transaction hash\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async deployCloneRaw<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<HashAndSimulatedResult<Address>> {\n    const payload = target.buildParameters(undefined, {\n      config: this._config,\n      account: this._account,\n    });\n    const { address: baseAddress } = assertValidAddressByChainId(\n      this._config,\n      target.bases,\n      params?.chain?.id || params?.chainId,\n    );\n    const { request, result } = await simulateBoostRegistryDeployClone(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [target.registryType, baseAddress, displayName, payload.args[0]],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostRegistryDeployClone(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get the address of a registered base implementation.\n   * This function will revert if the implementation is not registered\n   *\n   * @public\n   * @async\n   * @param {Hex} identifier - The unique identifier for the implementation (see {getIdentifier})\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>} - The address of the implementation\n   */\n  public async getBaseImplementation(\n    identifier: Hex,\n    params?: ReadParams<typeof boostRegistryAbi, 'getBaseImplementation'>,\n  ) {\n    return await readBoostRegistryGetBaseImplementation(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [identifier],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the address of a deployed clone by its identifier\n   *\n   * @public\n   * @async\n   * @param {Hex} identifier - The unique identifier for the deployed clone (see {getCloneIdentifier})\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>} - The address of the deployed clone\n   */\n  public async getClone(\n    identifier: Hex,\n    params?: ReadParams<typeof boostRegistryAbi, 'getClone'>,\n  ) {\n    return await readBoostRegistryGetBaseImplementation(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [identifier],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the list of identifiers of deployed clones for a given deployer\n   *\n   * @public\n   * @async\n   * @param {Address} deployer - The address of the deployer\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex[]>} - The list of deployed clones for the given deployer\n   */\n  public async getClones(\n    deployer: Address,\n    params?: ReadParams<typeof boostRegistryAbi, 'getClones'>,\n  ) {\n    return await readBoostRegistryGetClones(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [deployer],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Build the identifier for a clone of a base implementation\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {Address} base - The address of the base implementation\n   * @param {Address} deployer - The address of the deployer\n   * @param {string} displayName - The display name of the clone\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>} - The unique identifier for the clone\n   */\n  public async getCloneIdentifier(\n    registryType: RegistryType,\n    base: Address,\n    deployer: Address,\n    displayName: string,\n    params?: ReadParams<typeof boostRegistryAbi, 'getCloneIdentifier'>,\n  ) {\n    return await readBoostRegistryGetCloneIdentifier(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [registryType, base, deployer, displayName],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Build the identifier for a base implementation\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {string} displayName - The name of the implementation\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>} - The unique identifier for the implementation\n   */\n  public async getIdentifier(\n    registryType: RegistryType,\n    displayName: string,\n    params?: ReadParams<typeof boostRegistryAbi, 'getIdentifier'>,\n  ) {\n    return await readBoostRegistryGetCloneIdentifier(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [registryType, displayName],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?never[]} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: never[],\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [, options] = this.validateDeploymentConfig([], _options);\n    return {\n      abi: boostRegistryAbi,\n      bytecode: bytecode as Hex,\n      // biome-ignore lint/suspicious/noExplicitAny: Registry doesn't construct or initialize\n      args: [] as any,\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n"],"names":["BOOST_REGISTRY_ADDRESS","BoostRegistryBases","BOOST_REGISTRY_ADDRESSES","isBoostRegistryDeployed","opts","isAddress","isBoostRegistryDeployable","_BoostRegistry","Deployable","config","account","options","address","assertValidAddressByChainId","registryType","name","implementation","params","request","result","simulateBoostRegistryRegister","_a","writeBoostRegistryRegister","displayName","target","instance","payload","baseAddress","simulateBoostRegistryDeployClone","_b","writeBoostRegistryDeployClone","identifier","readBoostRegistryGetBaseImplementation","deployer","readBoostRegistryGetClones","base","readBoostRegistryGetCloneIdentifier","_payload","_options","boostRegistryAbi","bytecode","BoostRegistry"],"mappings":"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"}