{"version":3,"file":"BoostCore-BiPwp6SR.cjs","sources":["../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/getAccount.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/getChainId.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/utils/getAction.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/version.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/utils/getVersion.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/errors/base.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/errors/config.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/getConnectorClient.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/simulateContract.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/writeContract.js","../../../node_modules/.pnpm/@wagmi+core@2.13.8_@tanstack+query-core@5.32.0_@types+react@18.3.0_immer@10.0.2_react@18.3.0__rf4knvbttxkigkqzlfrm4rcvsi/node_modules/@wagmi/core/dist/esm/actions/codegen/createWriteContract.js","../src/Incentives/ERC20VariableCriteriaIncentive.ts","../src/BoostCore.ts"],"sourcesContent":["/** https://wagmi.sh/core/api/actions/getAccount */\nexport function getAccount(config) {\n    const uid = config.state.current;\n    const connection = config.state.connections.get(uid);\n    const addresses = connection?.accounts;\n    const address = addresses?.[0];\n    const chain = config.chains.find((chain) => chain.id === connection?.chainId);\n    const status = config.state.status;\n    switch (status) {\n        case 'connected':\n            return {\n                address: address,\n                addresses: addresses,\n                chain,\n                chainId: connection?.chainId,\n                connector: connection?.connector,\n                isConnected: true,\n                isConnecting: false,\n                isDisconnected: false,\n                isReconnecting: false,\n                status,\n            };\n        case 'reconnecting':\n            return {\n                address,\n                addresses,\n                chain,\n                chainId: connection?.chainId,\n                connector: connection?.connector,\n                isConnected: !!address,\n                isConnecting: false,\n                isDisconnected: false,\n                isReconnecting: true,\n                status,\n            };\n        case 'connecting':\n            return {\n                address,\n                addresses,\n                chain,\n                chainId: connection?.chainId,\n                connector: connection?.connector,\n                isConnected: false,\n                isConnecting: true,\n                isDisconnected: false,\n                isReconnecting: false,\n                status,\n            };\n        case 'disconnected':\n            return {\n                address: undefined,\n                addresses: undefined,\n                chain: undefined,\n                chainId: undefined,\n                connector: undefined,\n                isConnected: false,\n                isConnecting: false,\n                isDisconnected: true,\n                isReconnecting: false,\n                status,\n            };\n    }\n}\n//# sourceMappingURL=getAccount.js.map","/** https://wagmi.sh/core/api/actions/getChainId */\nexport function getChainId(config) {\n    return config.state.chainId;\n}\n//# sourceMappingURL=getChainId.js.map","/**\n * Retrieves and returns an action from the client (if exists), and falls\n * back to the tree-shakable action.\n *\n * Useful for extracting overridden actions from a client (ie. if a consumer\n * wants to override the `sendTransaction` implementation).\n */\nexport function getAction(client, actionFn, \n// Some minifiers drop `Function.prototype.name`, or replace it with short letters,\n// meaning that `actionFn.name` will not always work. For that case, the consumer\n// needs to pass the name explicitly.\nname) {\n    const action_implicit = client[actionFn.name];\n    if (typeof action_implicit === 'function')\n        return action_implicit;\n    const action_explicit = client[name];\n    if (typeof action_explicit === 'function')\n        return action_explicit;\n    return (params) => actionFn(client, params);\n}\n//# sourceMappingURL=getAction.js.map","export const version = '2.13.8';\n//# sourceMappingURL=version.js.map","import { version } from '../version.js';\nexport const getVersion = () => `@wagmi/core@${version}`;\n//# sourceMappingURL=getVersion.js.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseError_instances, _BaseError_walk;\nimport { getVersion } from '../utils/getVersion.js';\nexport class BaseError extends Error {\n    get docsBaseUrl() {\n        return 'https://wagmi.sh/core';\n    }\n    get version() {\n        return getVersion();\n    }\n    constructor(shortMessage, options = {}) {\n        super();\n        _BaseError_instances.add(this);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WagmiCoreError'\n        });\n        const details = options.cause instanceof BaseError\n            ? options.cause.details\n            : options.cause?.message\n                ? options.cause.message\n                : options.details;\n        const docsPath = options.cause instanceof BaseError\n            ? options.cause.docsPath || options.docsPath\n            : options.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(options.metaMessages ? [...options.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (options.cause)\n            this.cause = options.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = options.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, this, fn);\n    }\n}\n_BaseError_instances = new WeakSet(), _BaseError_walk = function _BaseError_walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err.cause)\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, err.cause, fn);\n    return err;\n};\n//# sourceMappingURL=base.js.map","import { BaseError } from './base.js';\nexport class ChainNotConfiguredError extends BaseError {\n    constructor() {\n        super('Chain not configured.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ChainNotConfiguredError'\n        });\n    }\n}\nexport class ConnectorAlreadyConnectedError extends BaseError {\n    constructor() {\n        super('Connector already connected.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorAlreadyConnectedError'\n        });\n    }\n}\nexport class ConnectorNotConnectedError extends BaseError {\n    constructor() {\n        super('Connector not connected.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorNotConnectedError'\n        });\n    }\n}\nexport class ConnectorNotFoundError extends BaseError {\n    constructor() {\n        super('Connector not found.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorNotFoundError'\n        });\n    }\n}\nexport class ConnectorAccountNotFoundError extends BaseError {\n    constructor({ address, connector, }) {\n        super(`Account \"${address}\" not found for connector \"${connector.name}\".`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorAccountNotFoundError'\n        });\n    }\n}\nexport class ConnectorChainMismatchError extends BaseError {\n    constructor({ connectionChainId, connectorChainId, }) {\n        super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {\n            metaMessages: [\n                `Current Chain ID:  ${connectorChainId}`,\n                `Expected Chain ID: ${connectionChainId}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorChainMismatchError'\n        });\n    }\n}\nexport class ConnectorUnavailableReconnectingError extends BaseError {\n    constructor({ connector }) {\n        super(`Connector \"${connector.name}\" unavailable while reconnecting.`, {\n            details: [\n                'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`.',\n                'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',\n                'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',\n            ].join(' '),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ConnectorUnavailableReconnectingError'\n        });\n    }\n}\n//# sourceMappingURL=config.js.map","import { createClient, custom, } from 'viem';\nimport { getAddress, parseAccount } from 'viem/utils';\nimport { ConnectorAccountNotFoundError, ConnectorChainMismatchError, ConnectorNotConnectedError, ConnectorUnavailableReconnectingError, } from '../errors/config.js';\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient(config, parameters = {}) {\n    // Get connection\n    let connection;\n    if (parameters.connector) {\n        const { connector } = parameters;\n        if (config.state.status === 'reconnecting' &&\n            !connector.getAccounts &&\n            !connector.getChainId)\n            throw new ConnectorUnavailableReconnectingError({ connector });\n        const [accounts, chainId] = await Promise.all([\n            connector.getAccounts(),\n            connector.getChainId(),\n        ]);\n        connection = {\n            accounts: accounts,\n            chainId,\n            connector,\n        };\n    }\n    else\n        connection = config.state.connections.get(config.state.current);\n    if (!connection)\n        throw new ConnectorNotConnectedError();\n    const chainId = parameters.chainId ?? connection.chainId;\n    // Check connector using same chainId as connection\n    const connectorChainId = await connection.connector.getChainId();\n    if (connectorChainId !== connection.chainId)\n        throw new ConnectorChainMismatchError({\n            connectionChainId: connection.chainId,\n            connectorChainId,\n        });\n    const connector = connection.connector;\n    if (connector.getClient)\n        return connector.getClient({ chainId });\n    // Default using `custom` transport\n    const account = parseAccount(parameters.account ?? connection.accounts[0]);\n    account.address = getAddress(account.address); // TODO: Checksum address as part of `parseAccount`?\n    // If account was provided, check that it exists on the connector\n    if (parameters.account &&\n        !connection.accounts.some((x) => x.toLowerCase() === account.address.toLowerCase()))\n        throw new ConnectorAccountNotFoundError({\n            address: account.address,\n            connector,\n        });\n    const chain = config.chains.find((chain) => chain.id === chainId);\n    const provider = (await connection.connector.getProvider({ chainId }));\n    return createClient({\n        account,\n        chain,\n        name: 'Connector Client',\n        transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n    });\n}\n//# sourceMappingURL=getConnectorClient.js.map","import { simulateContract as viem_simulateContract, } from 'viem/actions';\nimport { getAction } from '../utils/getAction.js';\nimport { getConnectorClient, } from './getConnectorClient.js';\n/** https://wagmi.sh/core/api/actions/simulateContract */\nexport async function simulateContract(config, parameters) {\n    const { abi, chainId, connector, ...rest } = parameters;\n    let account;\n    if (parameters.account)\n        account = parameters.account;\n    else {\n        const connectorClient = await getConnectorClient(config, {\n            chainId,\n            connector,\n        });\n        account = connectorClient.account;\n    }\n    const client = config.getClient({ chainId });\n    const action = getAction(client, viem_simulateContract, 'simulateContract');\n    const { result, request } = await action({ ...rest, abi, account });\n    return {\n        chainId: client.chain.id,\n        result,\n        request: { __mode: 'prepared', ...request, chainId },\n    };\n}\n//# sourceMappingURL=simulateContract.js.map","import { writeContract as viem_writeContract, } from 'viem/actions';\nimport { getAction } from '../utils/getAction.js';\nimport { getAccount } from './getAccount.js';\nimport { getConnectorClient, } from './getConnectorClient.js';\nimport { simulateContract, } from './simulateContract.js';\n/** https://wagmi.sh/core/api/actions/writeContract */\nexport async function writeContract(config, parameters) {\n    const { account, chainId, connector, __mode, ...rest } = parameters;\n    let client;\n    if (typeof account === 'object' && account.type === 'local')\n        client = config.getClient({ chainId });\n    else\n        client = await getConnectorClient(config, { account, chainId, connector });\n    const { connector: activeConnector } = getAccount(config);\n    let request;\n    if (__mode === 'prepared' || activeConnector?.supportsSimulation)\n        request = rest;\n    else {\n        const { request: simulateRequest } = await simulateContract(config, {\n            ...rest,\n            account,\n            chainId,\n        });\n        request = simulateRequest;\n    }\n    const action = getAction(client, viem_writeContract, 'writeContract');\n    const hash = await action({\n        ...request,\n        ...(account ? { account } : {}),\n        chain: chainId ? { id: chainId } : null,\n    });\n    return hash;\n}\n//# sourceMappingURL=writeContract.js.map","import { getAccount } from '../getAccount.js';\nimport { getChainId } from '../getChainId.js';\nimport { writeContract, } from '../writeContract.js';\nexport function createWriteContract(c) {\n    if (c.address !== undefined && typeof c.address === 'object')\n        return (config, parameters) => {\n            const configChainId = getChainId(config);\n            const account = getAccount(config);\n            let chainId;\n            if (parameters.chainId)\n                chainId = parameters.chainId;\n            else if (parameters\n                .account &&\n                parameters\n                    .account === account.address)\n                chainId = account.chainId;\n            else if (parameters\n                .account === undefined)\n                chainId = account.chainId;\n            else\n                chainId = configChainId;\n            return writeContract(config, {\n                ...parameters,\n                ...(c.functionName ? { functionName: c.functionName } : {}),\n                address: chainId ? c.address?.[chainId] : undefined,\n                abi: c.abi,\n            });\n        };\n    return (config, parameters) => {\n        return writeContract(config, {\n            ...parameters,\n            ...(c.address ? { address: c.address } : {}),\n            ...(c.functionName ? { functionName: c.functionName } : {}),\n            abi: c.abi,\n        });\n    };\n}\n//# sourceMappingURL=createWriteContract.js.map","import {\n  erc20VariableCriteriaIncentiveAbi,\n  readErc20VariableCriteriaIncentiveGetIncentiveCriteria,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/incentives/ERC20VariableCriteriaIncentive.sol/ERC20VariableCriteriaIncentive.json';\nimport events from '@boostxyz/signatures/events';\nimport functions from '@boostxyz/signatures/functions';\nimport { getTransaction, getTransactionReceipt } from '@wagmi/core';\nimport {\n  type AbiEvent,\n  type AbiFunction,\n  type Address,\n  type Hex,\n  type Log,\n  decodeFunctionData,\n  encodeAbiParameters,\n  parseEventLogs,\n} from 'viem';\nimport { ERC20VariableCriteriaIncentive as ERC20VariableCriteriaIncentiveBases } from '../../dist/deployments.json';\nimport { SignatureType } from '../Actions/EventAction';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport {\n  DecodedArgsError,\n  FieldActionValidationError,\n  IncentiveCriteriaNotFoundError,\n  InvalidCriteriaTypeError,\n  NoMatchingLogsError,\n} from '../errors';\nimport type { ReadParams } from '../utils';\nimport { ERC20VariableIncentive } from './ERC20VariableIncentive';\n\nexport interface ERC20VariableCriteriaIncentivePayload {\n  /**\n   * The address of the incentivized asset.\n   *\n   * @type {Address}\n   */\n  asset: Address;\n  /**\n   * The amount of the asset to distribute as reward.\n   *\n   * @type {bigint}\n   */\n  reward: bigint;\n  /**\n   * The total spending limit of the asset that will be distributed.\n   *\n   * @type {bigint}\n   */\n  limit: bigint;\n  /**\n   * The criteria for the incentive that determines how the reward is distributed.\n   *\n   * @type {IncentiveCriteria}\n   */\n  criteria: IncentiveCriteria;\n}\n\nexport interface IncentiveCriteria {\n  /**\n   * The type of criteria used, either function signature or event signature.\n   *\n   * @type {SignatureType}\n   */\n  criteriaType: SignatureType;\n  /**\n   * The function or event signature used for criteria matching.\n   *\n   * @type {Hex}\n   */\n  signature: Hex;\n  /**\n   * The index of the field from where the scalar value is extracted.\n   *\n   * @type {number}\n   */\n  fieldIndex: number;\n  /**\n   * The address of the contract where the event/function is called/emitted.\n   *\n   * @type {Address}\n   */\n  targetContract: Address;\n}\n\nexport interface ReadIncentiveCriteriaParams\n  extends ReadParams<\n    typeof erc20VariableCriteriaIncentiveAbi,\n    'getIncentiveCriteria'\n  > {}\n\nexport interface GetIncentiveScalarParams {\n  hash: Hex;\n}\n\n/**\n * Extended ERC20 Variable Criteria Incentive class that fetches incentive criteria and scalar\n */\nexport class ERC20VariableCriteriaIncentive extends DeployableTarget<\n  ERC20VariableCriteriaIncentivePayload,\n  typeof erc20VariableCriteriaIncentiveAbi\n> {\n  public override readonly abi = erc20VariableCriteriaIncentiveAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(ERC20VariableCriteriaIncentiveBases as Record<number, Address>),\n  };\n\n  /**\n   *Functions from the ERC20VariableIncentive contract\n   */\n\n  /**\n   * Fetches the IncentiveCriteria struct from the contract\n   *\n   * @returns {Promise<IncentiveCriteria>} Incentive criteria structure\n   * @throws {IncentiveCriteriaNotFoundError}\n   */\n  public async getIncentiveCriteria(): Promise<IncentiveCriteria> {\n    try {\n      const criteria =\n        await readErc20VariableCriteriaIncentiveGetIncentiveCriteria(\n          this._config,\n          {\n            address: this.assertValidAddress(),\n          },\n        );\n\n      return criteria;\n    } catch (e) {\n      throw new IncentiveCriteriaNotFoundError(e as Error);\n    }\n  }\n\n  /**\n   * Fetches the incentive scalar from a transaction hash\n   *\n   * @param {GetIncentiveScalarParams} params\n   * @returns {Promise<bigint>}\n   * @throws {InvalidCriteriaTypeError | NoMatchingLogsError | DecodedArgsError}\n   */\n  public async getIncentiveScalar({\n    hash,\n  }: GetIncentiveScalarParams): Promise<bigint> {\n    const criteria = await this.getIncentiveCriteria();\n    const transaction = await getTransaction(this._config, {\n      hash,\n    });\n    if (criteria.criteriaType === SignatureType.EVENT) {\n      const transactionReceipt = await getTransactionReceipt(this._config, {\n        hash,\n      });\n\n      const logs = transactionReceipt.logs;\n\n      if (logs.length === 0) {\n        throw new NoMatchingLogsError(\n          `No logs found for event signature ${criteria.signature}`,\n        );\n      }\n\n      // Decode the event log\n      try {\n        // Decode function data\n        const eventAbi = (events.abi as Record<Hex, AbiEvent>)[\n          criteria.signature\n        ] as AbiEvent;\n        const decodedEvents = parseEventLogs({\n          abi: [eventAbi],\n          logs,\n        });\n        if (decodedEvents == undefined || decodedEvents.length === 0) {\n          throw new NoMatchingLogsError(\n            `No logs found for event signature ${criteria.signature}`,\n          );\n        }\n        const scalarValue = (decodedEvents[0]?.args as string[])[\n          criteria.fieldIndex\n        ];\n\n        if (scalarValue === undefined) {\n          throw new DecodedArgsError(\n            `Decoded argument at index ${criteria.fieldIndex} is undefined`,\n          );\n        }\n        return BigInt(scalarValue);\n      } catch (e) {\n        throw new DecodedArgsError(\n          `Failed to decode event log for signature ${criteria.signature}: ${(e as Error).message}`,\n        );\n      }\n    } else if (criteria.criteriaType === SignatureType.FUNC) {\n      // Fetch the transaction data\n      try {\n        // Decode function data\n        const func = (functions.abi as Record<Hex, AbiFunction>)[\n          criteria.signature\n        ] as AbiFunction;\n\n        const decodedFunction = decodeFunctionData({\n          abi: [func],\n          data: transaction.input,\n        });\n        const scalarValue = decodedFunction.args[criteria.fieldIndex] as string;\n        if (scalarValue === undefined || scalarValue === null) {\n          throw new DecodedArgsError(\n            `Decoded argument at index ${criteria.fieldIndex} is undefined`,\n          );\n        }\n        return BigInt(scalarValue);\n      } catch (e) {\n        throw new DecodedArgsError(\n          `Failed to decode function data for signature ${criteria.signature}: ${(e as Error).message}`,\n        );\n      }\n    } else {\n      throw new InvalidCriteriaTypeError(\n        `Invalid criteria type ${criteria.criteriaType}`,\n      );\n    }\n  }\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?ERC20VariableCriteriaIncentivePayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: ERC20VariableCriteriaIncentivePayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: erc20VariableCriteriaIncentiveAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareERC20VariableCriteriaIncentivePayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n *\n *\n * @param {InitPayloadExtended} param0\n * @param {Address} param0.asset - The address of the ERC20 asset to incentivize.\n * @param {bigint} param0.reward - The reward amount to distribute per action.\n * @param {bigint} param0.limit - The total limit of the asset distribution.\n * @param {IncentiveCriteria} param0.criteria - The incentive criteria for reward distribution.\n * @returns {Hex}\n */\nexport function prepareERC20VariableCriteriaIncentivePayload({\n  asset,\n  reward,\n  limit,\n  criteria,\n}: ERC20VariableCriteriaIncentivePayload) {\n  return encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'initPayloadExtended',\n        components: [\n          { type: 'address', name: 'asset' },\n          { type: 'uint256', name: 'reward' },\n          { type: 'uint256', name: 'limit' },\n          {\n            type: 'tuple',\n            name: 'criteria',\n            components: [\n              { type: 'uint8', name: 'criteriaType' },\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'fieldIndex' },\n              { type: 'address', name: 'targetContract' },\n            ],\n          },\n        ],\n      },\n    ],\n    [\n      {\n        asset: asset,\n        reward: reward,\n        limit: limit,\n        criteria: {\n          criteriaType: criteria.criteriaType,\n          signature: criteria.signature,\n          fieldIndex: criteria.fieldIndex,\n          targetContract: criteria.targetContract,\n        },\n      },\n    ],\n  );\n}\n","import {\n  boostCoreAbi,\n  type iAuthAbi,\n  readBoostCoreClaimFee,\n  readBoostCoreCreateBoostAuth,\n  readBoostCoreGetBoost,\n  readBoostCoreGetBoostCount,\n  readBoostCoreProtocolFee,\n  readBoostCoreProtocolFeeReceiver,\n  readIAuthIsAuthorized,\n  simulateBoostCoreClaimIncentive,\n  simulateBoostCoreClaimIncentiveFor,\n  simulateBoostCoreSetClaimFee,\n  simulateBoostCoreSetCreateBoostAuth,\n  simulateBoostCoreSetProtocolFeeReceiver,\n  writeBoostCoreClaimIncentive,\n  writeBoostCoreClaimIncentiveFor,\n  writeBoostCoreSetClaimFee,\n  writeBoostCoreSetCreateBoostAuth,\n  writeBoostCoreSetProtocolFeeReceiver,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/BoostCore.sol/BoostCore.json';\nimport {\n  type GetTransactionReceiptParameters,\n  getAccount,\n  getTransactionReceipt,\n  waitForTransactionReceipt,\n} from '@wagmi/core';\nimport { createWriteContract } from '@wagmi/core/codegen';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  parseEther,\n  parseEventLogs,\n  zeroAddress,\n  zeroHash,\n} from 'viem';\nimport { BoostCore as BoostCoreBases } from '../dist/deployments.json';\nimport { type Action, actionFromAddress } from './Actions/Action';\nimport { EventAction, type EventActionPayload } from './Actions/EventAction';\nimport { type AllowList, allowListFromAddress } from './AllowLists/AllowList';\nimport { OpenAllowList } from './AllowLists/OpenAllowList';\nimport {\n  SimpleAllowList,\n  type SimpleAllowListPayload,\n} from './AllowLists/SimpleAllowList';\nimport {\n  SimpleDenyList,\n  type SimpleDenyListPayload,\n} from './AllowLists/SimpleDenyList';\nimport { type Auth, PassthroughAuth } from './Auth/Auth';\nimport {\n  Boost,\n  type BoostPayload,\n  type Target,\n  prepareBoostPayload,\n} from './Boost';\nimport { type Budget, budgetFromAddress } from './Budgets/Budget';\nimport {\n  ManagedBudget,\n  type ManagedBudgetPayload,\n} from './Budgets/ManagedBudget';\nimport {\n  Deployable,\n  type DeployableOptions,\n  type DeployablePayloadOrAddress,\n  type GenericDeployableParams,\n} from './Deployable/Deployable';\nimport {\n  AllowListIncentive,\n  type AllowListIncentivePayload,\n} from './Incentives/AllowListIncentive';\nimport {\n  CGDAIncentive,\n  type CGDAIncentivePayload,\n} from './Incentives/CGDAIncentive';\nimport {\n  ERC20Incentive,\n  type ERC20IncentivePayload,\n} from './Incentives/ERC20Incentive';\nimport {\n  ERC20VariableCriteriaIncentive,\n  type ERC20VariableCriteriaIncentivePayload,\n} from './Incentives/ERC20VariableCriteriaIncentive';\nimport type { ERC20VariableIncentivePayload } from './Incentives/ERC20VariableIncentive';\nimport {\n  ERC20VariableIncentive,\n  type Incentive,\n  incentiveFromAddress,\n} from './Incentives/Incentive';\nimport {\n  PointsIncentive,\n  type PointsIncentivePayload,\n} from './Incentives/PointsIncentive';\nimport {\n  SignerValidator,\n  type SignerValidatorPayload,\n} from './Validators/SignerValidator';\nimport { type Validator, validatorFromAddress } from './Validators/Validator';\nimport {\n  BoostCoreNoIdentifierEmitted,\n  BudgetMustAuthorizeBoostCore,\n  DeployableUnknownOwnerProvidedError,\n  IncentiveNotCloneableError,\n  MustInitializeBudgetError,\n} from './errors';\nimport {\n  type GenericLog,\n  type ReadParams,\n  type WriteParams,\n  assertValidAddressByChainId,\n} from './utils';\n\n/**\n * The ABI of the BoostCore contract, if needed for low level operations\n *\n * @type {typeof boostCoreAbi}\n */\nexport { boostCoreAbi };\n\n/**\n * The fee (in wei) required to claim each incentive, must be provided for the `claimIncentive` transaction\n *\n * @type {bigint}\n */\nexport const BOOST_CORE_CLAIM_FEE = parseEther('0.000075');\n\n/**\n * The address of the deployed BoostCore instance. In prerelease mode, this will be its sepolia address\n *\n * @type {Address}\n */\nexport const BOOST_CORE_ADDRESS =\n  (BoostCoreBases as Record<string, Address>)[__DEFAULT_CHAIN_ID__] ||\n  zeroAddress;\n\n/**\n * The fixed addresses for the deployed Boost Core.\n * By default, `new BoostCore` will use the address deployed to the currently connected chain, or `BOOST_CORE_ADDRESS` if not provided.\n *\n * @type {Record<number, Address>}\n */\nexport const BOOST_CORE_ADDRESSES: Record<number, Address> = {\n  ...(BoostCoreBases as Record<number, Address>),\n  31337: import.meta.env.VITE_BOOST_CORE_ADDRESS,\n};\n\n/**\n * A generic `viem.Log` event with support for `BoostCore` event types.\n *\n * @export\n * @typedef {BoostCoreLog}\n * @template {ContractEventName<typeof boostCoreAbi>} [event=ContractEventName<\n *     typeof boostCoreAbi\n *   >]\n */\nexport type BoostCoreLog<\n  event extends ContractEventName<typeof boostCoreAbi> = ContractEventName<\n    typeof boostCoreAbi\n  >,\n> = GenericLog<typeof boostCoreAbi, event>;\n\n/**\n * Boost Core instantiation options for a custom deployed instance.\n *\n * @export\n * @interface BoostCoreDeployedOptions\n * @typedef {BoostCoreDeployedOptions}\n * @extends {DeployableOptions}\n */\nexport interface BoostCoreDeployedOptions extends DeployableOptions {\n  /**\n   * The address of a deployed, custom Boost Core contract.\n   *\n   * @type {?Address}\n   */\n  address?: Address;\n}\n\n/**\n * Typeguard to determine if a user is supplying a custom address for a Boost Core contract.\n *\n * @param {*} opts\n * @returns {opts is BoostCoreDeployedOptions}\n */\n// biome-ignore lint/suspicious/noExplicitAny: type guard\nfunction isBoostCoreDeployed(opts: any): opts is BoostCoreDeployedOptions {\n  return opts.address;\n}\n\n/**\n * Boost Core instantiation options when a user intends to deploy a new instance of Boost Core, setting their own registry address and protocol fee receiver.\n *\n * @export\n * @interface BoostCoreOptionsWithPayload\n * @typedef {BoostCoreOptionsWithPayload}\n * @extends {DeployableOptions}\n */\nexport interface BoostCoreOptionsWithPayload extends DeployableOptions {\n  /**\n   * The address of a deployed Boost Registry contract.\n   *\n   * @type {Address}\n   */\n  registryAddress: Address;\n  /**\n   * The address to send fees.\n   *\n   * @type {Address}\n   */\n  protocolFeeReceiver: Address;\n}\n\n/**\n * Typeguard to determine if a user is intending to deploy a new instance of the Boost Core contracts with {@link BoostCoreOptionsWithPayload}.\n *\n * @param {*} opts\n * @returns {opts is BoostCoreOptionsWithPayload}\n */\n// biome-ignore lint/suspicious/noExplicitAny: type guard\nfunction isBoostCoreDeployable(opts: any): opts is BoostCoreOptionsWithPayload {\n  return opts.registryAddress && opts.protocolFeeReceiver;\n}\n\n/**\n * A union representing both of the valid Boost Core instantiation parameters.\n *\n * @export\n * @typedef {BoostCoreConfig}\n */\nexport type BoostCoreConfig =\n  | BoostCoreDeployedOptions\n  | BoostCoreOptionsWithPayload;\n\n/**\n * The interface required to create a new Boost.\n *\n * @export\n * @typedef {CreateBoostPayload}\n */\nexport type CreateBoostPayload = {\n  budget: Budget;\n  action: Action;\n  validator?: Validator;\n  allowList: AllowList;\n  incentives: Array<Incentive>;\n  protocolFee?: bigint;\n  referralFee?: bigint;\n  maxParticipants?: bigint;\n  owner?: Address;\n};\n\n/**\n * The core contract for the Boost protocol. Used to create and retrieve deployed Boosts.\n *\n * @export\n * @class BoostCore\n * @typedef {BoostCore}\n * @extends {Deployable<[Address, Address]>}\n */\nexport class BoostCore extends Deployable<\n  [Address, Address],\n  typeof boostCoreAbi\n> {\n  /**\n   * A static property representing a map of stringified chain ID's to the address of the deployed implementation on chain\n   *\n   * @static\n   * @readonly\n   * @type {Record<string, Address>}\n   */\n  static readonly addresses: Record<number, Address> = BOOST_CORE_ADDRESSES;\n\n  /**\n   * A getter that will return Boost core's static addresses by numerical chain ID\n   *\n   * @public\n   * @readonly\n   * @type {Record<number, Address>}\n   */\n  public get addresses(): Record<number, Address> {\n    return (this.constructor as typeof BoostCore).addresses;\n  }\n\n  /**\n   * Creates an instance of BoostCore.\n   *\n   * @constructor\n   * @param {BoostCoreConfig} param0\n   * @param {Config} param0.config\n   * @param {?Account} [param0.account]\n   * @param {({ address?: Address; } | { registryAddress: Address; protocolFeeReceiver: Address; })} param0....options\n   */\n  constructor({ config, account, ...options }: BoostCoreConfig) {\n    if (isBoostCoreDeployed(options) && options.address) {\n      super({ account, config }, options.address);\n    } else if (isBoostCoreDeployable(options)) {\n      super({ account, config }, [\n        options.registryAddress,\n        options.protocolFeeReceiver,\n      ]);\n    } else {\n      const { address } = assertValidAddressByChainId(\n        config,\n        BOOST_CORE_ADDRESSES,\n      );\n      super({ account, config }, address);\n    }\n    //@ts-expect-error I can't set this property on the class because for some reason it takes super out of constructor scope?\n    this.abi = boostCoreAbi;\n  }\n  /**\n   * Create a new Boost.\n   *\n   * @public\n   * @async\n   * @param {CreateBoostPayload} _boostPayload\n   * @param {?DeployableOptions} [_options]\n   * @returns {Promise<Boost>}\n   */\n  public async createBoost(\n    _boostPayload: CreateBoostPayload,\n    _params?: DeployableOptions &\n      WriteParams<typeof boostCoreAbi, 'createBoost'>,\n  ) {\n    const [payload, options] =\n      this.validateDeploymentConfig<CreateBoostPayload>(_boostPayload, _params);\n    const desiredChainId = _params?.chain?.id || _params?.chainId;\n    const { chainId, address: coreAddress } = assertValidAddressByChainId(\n      options.config,\n      this.addresses,\n      desiredChainId,\n    );\n\n    let {\n      budget,\n      action,\n      validator,\n      allowList,\n      incentives,\n      protocolFee = 0n,\n      referralFee = 0n,\n      maxParticipants = 0n,\n      owner,\n    } = payload;\n\n    const boostFactory = createWriteContract({\n      abi: boostCoreAbi,\n      functionName: 'createBoost',\n      address: coreAddress,\n    });\n\n    if (!owner) {\n      owner =\n        this._account?.address ||\n        getAccount(options.config).address ||\n        zeroAddress;\n      if (owner === zeroAddress) {\n        throw new DeployableUnknownOwnerProvidedError();\n      }\n    }\n\n    if (!validator) {\n      validator = this.SignerValidator({\n        signers: [owner],\n        validatorCaller: coreAddress,\n      });\n    }\n\n    let budgetPayload: BoostPayload['budget'] = zeroAddress;\n    if (budget.address) {\n      budgetPayload = budget.address;\n      if (!(await budget.isAuthorized(coreAddress))) {\n        throw new BudgetMustAuthorizeBoostCore(coreAddress);\n      }\n    } else {\n      throw new MustInitializeBudgetError();\n    }\n\n    // if we're supplying an address, it could be a pre-initialized target\n    // if base is explicitly set to false, then it will not be initialized, and it will be referenced as is if it implements interface correctly\n    let actionPayload: BoostPayload['action'] = {\n      instance: zeroAddress,\n      isBase: true,\n      parameters: zeroHash,\n    };\n    if (action.address) {\n      const isBase = action.isBase;\n      actionPayload = {\n        isBase: isBase,\n        instance: action.address,\n        parameters: isBase\n          ? action.buildParameters(undefined, options).args.at(0) || zeroHash\n          : zeroHash,\n      };\n    } else {\n      actionPayload.parameters =\n        action.buildParameters(undefined, options).args.at(0) || zeroHash;\n      actionPayload.instance = assertValidAddressByChainId(\n        options.config,\n        action.bases,\n        chainId,\n      ).address;\n    }\n\n    let validatorPayload: BoostPayload['validator'] = {\n      instance: zeroAddress,\n      isBase: true,\n      parameters: zeroHash,\n    };\n    if (validator.address) {\n      const isBase = validator.isBase;\n      validatorPayload = {\n        isBase: isBase,\n        instance: validator.address,\n        parameters: isBase\n          ? validator.buildParameters(undefined, options).args.at(0) || zeroHash\n          : zeroHash,\n      };\n    } else {\n      validatorPayload.parameters =\n        validator.buildParameters(undefined, options).args.at(0) || zeroHash;\n      validatorPayload.instance = assertValidAddressByChainId(\n        options.config,\n        validator.bases,\n        chainId,\n      ).address;\n    }\n\n    let allowListPayload: BoostPayload['allowList'] = {\n      instance: zeroAddress,\n      isBase: true,\n      parameters: zeroHash,\n    };\n    if (allowList.address) {\n      const isBase = allowList.isBase;\n      allowListPayload = {\n        isBase: isBase,\n        instance: allowList.address,\n        parameters: isBase\n          ? zeroHash // allowList.buildParameters(undefined, options).args.at(0) || zeroHash\n          : zeroHash,\n      };\n    } else {\n      allowListPayload.parameters =\n        allowList.buildParameters(undefined, options).args.at(0) || zeroHash;\n      allowListPayload.instance = assertValidAddressByChainId(\n        options.config,\n        allowList.bases,\n        chainId,\n      ).address;\n    }\n\n    const incentivesPayloads: Array<Target> = incentives.map(() => ({\n      instance: zeroAddress,\n      isBase: true,\n      parameters: zeroHash,\n    }));\n    for (let i = 0; i < incentives.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: this will never be undefined\n      const incentive = incentives.at(i)!;\n      if (incentive.address) {\n        const isBase = incentive.isBase;\n        if (!isBase) throw new IncentiveNotCloneableError(incentive);\n        incentivesPayloads[i] = {\n          isBase: isBase,\n          instance: incentive.address,\n          parameters: isBase\n            ? incentive.buildParameters(undefined, options).args.at(0) ||\n              zeroHash\n            : zeroHash,\n        };\n      } else {\n        // biome-ignore lint/style/noNonNullAssertion: this will never be undefined\n        incentivesPayloads[i]!.parameters =\n          incentive.buildParameters(undefined, options).args.at(0) || zeroHash;\n        // biome-ignore lint/style/noNonNullAssertion: this will never be undefined\n        incentivesPayloads[i]!.instance = assertValidAddressByChainId(\n          options.config,\n          incentive.bases,\n          chainId,\n        ).address;\n      }\n    }\n\n    const onChainPayload = {\n      budget: budgetPayload,\n      action: actionPayload,\n      validator: validatorPayload,\n      allowList: allowListPayload,\n      incentives: incentivesPayloads,\n      protocolFee,\n      referralFee,\n      maxParticipants,\n      owner,\n    };\n\n    const boostHash = await boostFactory(options.config, {\n      ...this.optionallyAttachAccount(options.account),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(_params as any),\n      chainId,\n      args: [prepareBoostPayload(onChainPayload)],\n    });\n    const receipt = await waitForTransactionReceipt(options.config, {\n      hash: boostHash,\n    });\n    const boostCreatedLog = parseEventLogs({\n      abi: boostCoreAbi,\n      eventName: 'BoostCreated',\n      logs: receipt.logs,\n    }).at(0);\n    let boostId = 0n;\n    if (!boostCreatedLog) throw new BoostCoreNoIdentifierEmitted();\n    boostId = boostCreatedLog?.args.boostIndex;\n    const boost = await this.readBoost(boostId);\n    return new Boost({\n      id: boostId,\n      budget: budget.at(boost.budget),\n      action: action.at(boost.action),\n      validator: validator.at(boost.validator),\n      allowList: allowList.at(boost.allowList),\n      incentives: incentives.map((incentive, i) =>\n        // biome-ignore lint/style/noNonNullAssertion: this will never be undefined\n        incentive.at(boost.incentives.at(i)!),\n      ),\n      protocolFee: boost.protocolFee,\n      referralFee: boost.referralFee,\n      maxParticipants: boost.maxParticipants,\n      owner: boost.owner,\n    });\n  }\n\n  /**\n   * Claims one incentive from a given `Boost` by `boostId` and `incentiveId`\n   *\n   * @public\n   * @async\n   * @param {bigint} boostId\n   * @param {bigint} incentiveId\n   * @param {Address} address\n   * @param {Hex} data\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async claimIncentive(\n    boostId: bigint,\n    incentiveId: bigint,\n    address: Address,\n    data: Hex,\n    params?: WriteParams<typeof boostCoreAbi, 'claimIncentive'>,\n  ) {\n    return await this.awaitResult(\n      this.claimIncentiveRaw(boostId, incentiveId, address, data, params),\n    );\n  }\n\n  /**\n   * Claim an incentive for a Boost\n   *\n   * @public\n   * @async\n   * @param {bigint} boostId - The ID of the Boost\n   * @param {bigint} incentiveId - The ID of the Incentive\n   * @param {Address} referrer - The address of the referrer (if any)\n   * @param {Hex} data- The data for the claim\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async claimIncentiveRaw(\n    boostId: bigint,\n    incentiveId: bigint,\n    referrer: Address,\n    data: Hex,\n    params?: WriteParams<typeof boostCoreAbi, 'claimIncentive'>,\n  ) {\n    const { request, result } = await simulateBoostCoreClaimIncentive(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [boostId, incentiveId, referrer, data],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostCoreClaimIncentive(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Claims one incentive for a given `Boost` on behalf of another user by `boostId` and `incentiveId`\n   *\n   * @public\n   * @async\n   * @param {bigint} boostId\n   * @param {bigint} incentiveId\n   * @param {Address} referrer\n   * @param {Hex} data\n   * @param {Address} claimant\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async claimIncentiveFor(\n    boostId: bigint,\n    incentiveId: bigint,\n    referrer: Address,\n    data: Hex,\n    claimant: Address,\n    params?: WriteParams<typeof boostCoreAbi, 'claimIncentiveFor'>,\n  ) {\n    return await this.awaitResult(\n      this.claimIncentiveForRaw(\n        boostId,\n        incentiveId,\n        referrer,\n        data,\n        claimant,\n        params,\n      ),\n    );\n  }\n\n  /**\n   * Claim an incentive for a Boost on behalf of another user\n   *\n   * @public\n   * @async\n   * @param {bigint} boostId - The ID of the Boost\n   * @param {bigint} incentiveId - The ID of the Incentive\n   * @param {Address} referrer - The address of the referrer (if any)\n   * @param {Hex} data - The data for the claim\n   * @param {Address} claimant - The address of the user eligible for the incentive payout\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: Hex; result: void; }>}\n   */\n  public async claimIncentiveForRaw(\n    boostId: bigint,\n    incentiveId: bigint,\n    referrer: Address,\n    data: Hex,\n    claimant: Address,\n    params?: WriteParams<typeof boostCoreAbi, 'claimIncentiveFor'>,\n  ) {\n    const { request, result } = await simulateBoostCoreClaimIncentiveFor(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [boostId, incentiveId, referrer, data, claimant],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostCoreClaimIncentiveFor(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get a Boost by index, will return the raw on chain representation of a Boost.\n   *\n   * @public\n   * @async\n   * @param {bigint} id\n   * @param {?ReadParams} [params]\n   * @returns {Promise<RawBoost>}\n   */\n  public async readBoost(\n    id: bigint,\n    params?: ReadParams<typeof boostCoreAbi, 'getBoost'>,\n  ) {\n    return await readBoostCoreGetBoost(this._config, {\n      address: this.assertValidAddress(),\n      args: [id],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get a Boost by index, will return a new {@link Boost} with correct target implementations instantiated, ie `(await core.getBoost(0n)).allowList instanceof SimpleAllowList` vs `SimpleDenyList`\n   *\n   * @public\n   * @async\n   * @param {(string | bigint)} _id\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Boost>}\n   */\n  public async getBoost(\n    _id: string | bigint,\n    params?: ReadParams<typeof boostCoreAbi, 'getBoost'>,\n  ) {\n    let id: bigint;\n    if (typeof _id === 'string') {\n      id = BigInt(_id);\n    } else id = _id;\n    const {\n      protocolFee,\n      referralFee,\n      maxParticipants,\n      owner,\n      ...boostPayload\n    } = await this.readBoost(id, params);\n    const options: DeployableOptions = {\n      config: this._config,\n      account: this._account,\n    };\n    const [action, budget, validator, allowList, incentives] =\n      await Promise.all([\n        actionFromAddress(options, boostPayload.action),\n        budgetFromAddress(options, boostPayload.budget),\n        validatorFromAddress(options, boostPayload.validator),\n        allowListFromAddress(options, boostPayload.allowList),\n        Promise.all(\n          boostPayload.incentives.map((incentiveAddress) =>\n            incentiveFromAddress(options, incentiveAddress),\n          ),\n        ),\n      ]);\n    return new Boost({\n      id,\n      action,\n      budget,\n      validator,\n      allowList,\n      incentives,\n      protocolFee,\n      referralFee,\n      maxParticipants,\n      owner,\n    });\n  }\n\n  /**\n   * Retrieve the total number of deployed Boosts\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async getBoostCount(\n    params?: ReadParams<typeof boostCoreAbi, 'getBoostCount'>,\n  ) {\n    return await readBoostCoreGetBoostCount(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Checks if an address is authorized\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?ReadParams &\n   *       ReadParams<typeof iAuthAbi, 'isAuthorized'>} [params]\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthorized(\n    address: Address,\n    params?: ReadParams<typeof boostCoreAbi, 'createBoostAuth'> &\n      ReadParams<typeof iAuthAbi, 'isAuthorized'>,\n  ) {\n    const auth = await this.createBoostAuth(params);\n    return readIAuthIsAuthorized(this._config, {\n      address: auth,\n      args: [address],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Retrieve the address of the current creation auth provider.\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public async createBoostAuth(\n    params?: ReadParams<typeof boostCoreAbi, 'createBoostAuth'>,\n  ) {\n    return await readBoostCoreCreateBoostAuth(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   *  Replace the current auth scheme.\n   *\n   * @public\n   * @async\n   * @param {Auth} auth\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setCreateBoostAuth(\n    auth: Auth,\n    params?: WriteParams<typeof boostCoreAbi, 'setCreateBoostAuth'>,\n  ) {\n    return await this.awaitResult(\n      this.setCreateBoostAuthRaw(auth.assertValidAddress(), {\n        ...params,\n      }),\n    );\n  }\n\n  /**\n   * Set the createBoostAuth address\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setCreateBoostAuthRaw(\n    address: Address,\n    params?: WriteParams<typeof boostCoreAbi, 'setCreateBoostAuth'>,\n  ) {\n    const { request, result } = await simulateBoostCoreSetCreateBoostAuth(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chainId,\n        ),\n        args: [address],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostCoreSetCreateBoostAuth(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get the protocol fee.\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {unknown}\n   */\n  public async protocolFee(\n    params?: ReadParams<typeof boostCoreAbi, 'protocolFee'>,\n  ) {\n    return await readBoostCoreProtocolFee(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the protocol fee receiver.\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public async protocolFeeReceiver(\n    params?: ReadParams<typeof boostCoreAbi, 'protocolFeeReceiver'>,\n  ) {\n    return await readBoostCoreProtocolFeeReceiver(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Set the protocol fee receiver address. This function is only callable by the owner.\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setProcolFeeReceiver(\n    address: Address,\n    params?: WriteParams<typeof boostCoreAbi, 'setProtocolFeeReceiver'>,\n  ) {\n    return await this.awaitResult(\n      this.setProcolFeeReceiverRaw(address, {\n        ...params,\n      }),\n    );\n  }\n\n  /**\n   * Set the protocol fee receiver address. This function is only callable by the owner.\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setProcolFeeReceiverRaw(\n    address: Address,\n    params?: WriteParams<typeof boostCoreAbi, 'setProtocolFeeReceiver'>,\n  ) {\n    const { request, result } = await simulateBoostCoreSetProtocolFeeReceiver(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chainId,\n        ),\n        args: [address],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostCoreSetProtocolFeeReceiver(\n      this._config,\n      request,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Get the claim fee.\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async claimFee(params?: ReadParams<typeof boostCoreAbi, 'claimFee'>) {\n    return await readBoostCoreClaimFee(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Sets the claim fee.\n   *\n   * @public\n   * @async\n   * @param {bigint} claimFee\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setClaimFee(\n    claimFee: bigint,\n    params?: WriteParams<typeof boostCoreAbi, 'setClaimFee'>,\n  ) {\n    return await this.awaitResult(this.setClaimFeeRaw(claimFee, params));\n  }\n\n  /**\n   * Sets the claim fee.\n   *\n   * @public\n   * @async\n   * @param {bigint} claimFee\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setClaimFeeRaw(\n    claimFee: bigint,\n    params?: WriteParams<typeof boostCoreAbi, 'setClaimFee'>,\n  ) {\n    const { request, result } = await simulateBoostCoreSetClaimFee(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chainId,\n        ),\n        args: [claimFee],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostCoreSetClaimFee(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Retrieves the claim information from a transaction receipt.\n   *\n   * @param {GetTransactionReceiptParameters} params - The parameters required to get the transaction receipt.\n   * @returns {Promise<{ boostId: bigint, incentiveId: bigint, claimer: Address, amount: bigint } | undefined>} The claim information if found, undefined otherwise.\n   *\n   * @description\n   * This method retrieves the transaction receipt using the provided parameters,\n   * then parses the logs to find the 'BoostClaimed' event.\n   * If found, it returns the arguments of the event, which include the boost ID,\n   * incentive ID, claimer address, and claimed amount.\n   *\n   * @example\n   * ```ts\n   * const claimInfo = await boostCore.getClaimFromTransaction({\n   *   hash: '0x...',\n   *   chainId: 1\n   * });\n   * if (claimInfo) {\n   *   console.log(`Boost ${claimInfo.boostId} claimed by ${claimInfo.claimer}`);\n   * }\n   * ```\n   */\n  public async getClaimFromTransaction(\n    params: GetTransactionReceiptParameters,\n  ) {\n    const receipt = await getTransactionReceipt(this._config, params);\n    const logs = parseEventLogs({\n      abi: boostCoreAbi,\n      eventName: 'BoostClaimed',\n      logs: receipt.logs,\n    });\n    return logs.at(0)?.args;\n  }\n\n  /**\n   * Bound {@link PassthroughAuth} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const auth = core.PassthroughAuth('0x') // is roughly equivalent to\n   * const auth = new PassthroughAuth({ config: core._config, account: core._account }, '0x')\n   * ```\n   * @param {Address} address\n   * @returns {PassthroughAuth}\n   */\n  PassthroughAuth(address?: Address) {\n    return new PassthroughAuth(\n      { config: this._config, account: this._account },\n      address,\n    );\n  }\n\n  // /**\n  //  * Bound {@link ContractAction} constructor that reuses the same configuration as the Boost Core instance.\n  //  *\n  //  * @example\n  //  * ```ts\n  //  * const action = core.ContractAction('0x') // is roughly equivalent to\n  //  * const action = new ContractAction({ config: core._config, account: core._account }, '0x')\n  //  * ```\n  //  * @param {DeployablePayloadOrAddress<ContractActionPayload>} options\n  //  * @param {?boolean} [isBase]\n  //  * @returns {ContractAction}\n  //  */\n  // ContractAction(\n  //   options: DeployablePayloadOrAddress<ContractActionPayload>,\n  //   isBase?: boolean,\n  // ) {\n  //   return new ContractAction(\n  //     { config: this._config, account: this._account },\n  //     options,\n  //     isBase,\n  //   );\n  // }\n\n  /**\n   * Bound {@link EventAction} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const action = core.EventAction('0x') // is roughly equivalent to\n   * const action = new EventAction({ config: core._config, account: core._account }, '0x')\n   */\n  EventAction(\n    options: DeployablePayloadOrAddress<EventActionPayload>,\n    isBase?: boolean,\n  ) {\n    return new EventAction(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n  // /**\n  //  * Bound {@link ERC721MintAction} constructor that reuses the same configuration as the Boost Core instance.\n  //  *\n  //  * @example\n  //  * ```ts\n  //  * const action = core.ERC721MintAction('0x') // is roughly equivalent to\n  //  * const action = new ERC721MintAction({ config: core._config, account: core._account }, '0x')\n  //  * ```\n  //  * @param {DeployablePayloadOrAddress<ERC721MintActionPayload>} options\n  //  * @param {?boolean} [isBase]\n  //  * @returns {ERC721MintAction}\n  //  */\n  // ERC721MintAction(\n  //   options: DeployablePayloadOrAddress<ERC721MintActionPayload>,\n  //   isBase?: boolean,\n  // ) {\n  //   return new ERC721MintAction(\n  //     { config: this._config, account: this._account },\n  //     options,\n  //     isBase,\n  //   );\n  // }\n  /**\n   * Bound {@link OpenAllowList} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const list = core.OpenAllowList('0x') // is roughly equivalent to\n   * const list = new OpenAllowList({ config: core._config, account: core._account }, '0x')\n   * ```\n   * @param {?boolean} [isBase]\n   * @returns {OpenAllowList}\n   */\n  OpenAllowList(isBase?: boolean) {\n    return new OpenAllowList(\n      { config: this._config, account: this._account },\n      undefined,\n      isBase,\n    );\n  }\n  /**\n   * Bound {@link SimpleAllowList} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const list = core.SimpleAllowList('0x') // is roughly equivalent to\n   * const list = new SimpleAllowList({ config: core._config, account: core._account }, '0x')\n   * ```\n   * @param {DeployablePayloadOrAddress<SimpleAllowListPayload>} options\n   * @param {?boolean} [isBase]\n   * @returns {SimpleAllowList}\n   */\n  SimpleAllowList(\n    options: DeployablePayloadOrAddress<SimpleAllowListPayload>,\n    isBase?: boolean,\n  ) {\n    return new SimpleAllowList(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n  /**\n   * Bound {@link SimpleDenyList} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const list = core.SimpleDenyList('0x') // is roughly equivalent to\n   * const list = new SimpleDenyList({ config: core._config, account: core._account }, '0x')\n   * ```\n   * @param {DeployablePayloadOrAddress<SimpleDenyListPayload>} options\n   * @param {?boolean} [isBase]\n   * @returns {SimpleDenyList}\n   */\n  SimpleDenyList(\n    options: DeployablePayloadOrAddress<SimpleDenyListPayload>,\n    isBase?: boolean,\n  ) {\n    return new SimpleDenyList(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n  // /**\n  //  * Bound {@link SimpleBudget} constructor that reuses the same configuration as the Boost Core instance.\n  //  *\n  //  * @example\n  //  * ```ts\n  //  * const budget = core.SimpleBudget('0x') // is roughly equivalent to\n  //  * const budget = new SimpleBudget({ config: core._config, account: core._account }, '0x')\n  //  * ```\n  //  * @param {DeployablePayloadOrAddress<SimpleBudgetPayload>} options\n  //  * @returns {SimpleBudget}\n  //  */\n  // SimpleBudget(options: DeployablePayloadOrAddress<SimpleBudgetPayload>) {\n  //   return new SimpleBudget(\n  //     { config: this._config, account: this._account },\n  //     options,\n  //   );\n  // }\n  /**\n   * Bound {@link ManagedBudget} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const budget = core.ManagedBudget('0x') // is roughly equivalent to\n   * const budget = new ManagedBudget({ config: core._config, account: core._account }, '0x')\n   * ```\n   * @param {DeployablePayloadOrAddress<ManagedBudgetPayload>} options\n   * @returns {ManagedBudget}\n   */\n  ManagedBudget(options: DeployablePayloadOrAddress<ManagedBudgetPayload>) {\n    return new ManagedBudget(\n      { config: this._config, account: this._account },\n      options,\n    );\n  }\n  // /**\n  //  * Bound {@link VestingBudget} constructor that reuses the same configuration as the Boost Core instance.\n  //  *\n  //  * @example\n  //  * ```ts\n  //  * const budget = core.VestingBudget('0x') // is roughly equivalent to\n  //  * const budget = new VestingBudget({ config: core._config, account: core._account }, '0x')\n  //  * ```\n  //  * @param {DeployablePayloadOrAddress<VestingBudgetPayload>} options\n  //  * @returns {VestingBudget}\n  //  */\n  // VestingBudget(options: DeployablePayloadOrAddress<VestingBudgetPayload>) {\n  //   return new VestingBudget(\n  //     { config: this._config, account: this._account },\n  //     options,\n  //   );\n  // }\n  /**\n   * Bound {@link AllowListIncentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const incentive = core.AllowListIncentive({ ... }) // is roughly equivalent to\n   * const incentive = new AllowListIncentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {DeployablePayloadOrAddress<VestingBudgetPayload>} options\n   * @returns {VestingBudget}\n   */\n  AllowListIncentive(options: AllowListIncentivePayload) {\n    return new AllowListIncentive(\n      { config: this._config, account: this._account },\n      options,\n    );\n  }\n  /**\n   * Bound {@link CGDAIncentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const incentive = core.CGDAIncentive({ ... }) // is roughly equivalent to\n   * const incentive = new CGDAIncentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {CGDAIncentivePayload} options\n   * @returns {CGDAIncentive}\n   */\n  CGDAIncentive(options: CGDAIncentivePayload) {\n    return new CGDAIncentive(\n      { config: this._config, account: this._account },\n      options,\n    );\n  }\n  /**\n   * Bound {@link ERC20Incentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const incentive = core.ERC20Incentive({ ... }) // is roughly equivalent to\n   * const incentive = new ERC20Incentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {ERC20IncentivePayload} options\n   * @returns {ERC20Incentive}\n   */\n  ERC20Incentive(options: ERC20IncentivePayload) {\n    return new ERC20Incentive(\n      { config: this._config, account: this._account },\n      options,\n    );\n  }\n  // /**\n  //  * Temporarily disabled until low level ABI encoding bugs are resolved\n  //  * Bound {@link ERC1155Incentive} constructor that reuses the same configuration as the Boost Core instance.\n  //  *\n  //  * @experimental\n  //  * @example\n  //  * ```ts\n  //  * const incentive = core.ERC1155Incentive({ ... }) // is roughly equivalent to\n  //  * const incentive = new ERC1155Incentive({ config: core._config, account: core._account }, { ... })\n  //  * ```\n  //  * @param {ERC1155IncentivePayload} options\n  //  * @returns {ERC1155Incentive}\n  //  */\n  // ERC1155Incentive(options: ERC1155IncentivePayload) {\n  //   return new ERC1155Incentive(\n  //     { config: this._config, account: this._account },\n  //     options,\n  //   );\n  // }\n  /**\n   * Bound {@link PointsIncentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const incentive = core.PointsIncentive({ ... }) // is roughly equivalent to\n   * const incentive = new PointsIncentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {PointsIncentivePayload} options\n   * @returns {PointsIncentive}\n   */\n  PointsIncentive(options: PointsIncentivePayload) {\n    return new PointsIncentive(\n      { config: this._config, account: this._account },\n      options,\n    );\n  }\n  /**\n   * Bound {@link SignerValidator} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const validator = core.SignerValidator({ ... }) // is roughly equivalent to\n   * const validator = new SignerValidator({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {DeployablePayloadOrAddress<SignerValidatorPayload>} options\n   * @param {?boolean} [isBase]\n   * @returns {SignerValidator}\n   */\n  SignerValidator(\n    options: DeployablePayloadOrAddress<SignerValidatorPayload>,\n    isBase?: boolean,\n  ) {\n    return new SignerValidator(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n\n  /**\n   * Bound {@link ERC20VariableCriteriaIncentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const validator = core.ERC20VariableCrtieriaIncentive({ ... }) // is roughly equivalent to\n   * const validator = new ERC20VariableCrtieriaIncentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {DeployablePayloadOrAddress<ERC20VariableCrtieriaIncentivePayload>} options\n   * @param {?boolean} [isBase]\n   * @returns {ERC20VariableCrtieriaIncentive}\n   * */\n  ERC20VariableCriteriaIncentive(\n    options: DeployablePayloadOrAddress<ERC20VariableCriteriaIncentivePayload>,\n    isBase?: boolean,\n  ) {\n    return new ERC20VariableCriteriaIncentive(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n\n  /**\n   * Bound {@link ERC20VariableIncentive} constructor that reuses the same configuration as the Boost Core instance.\n   *\n   * @example\n   * ```ts\n   * const validator = core.ERC20VariableIncentive({ ... }) // is roughly equivalent to\n   * const validator = new ERC20VariableIncentive({ config: core._config, account: core._account }, { ... })\n   * ```\n   * @param {DeployablePayloadOrAddress<ERC20VariableIncentivePayload>} options\n   * @param {?boolean} [isBase]\n   * @returns {ERC20VariableIncentive}\n   */\n  ERC20VariableIncentive(\n    options: DeployablePayloadOrAddress<ERC20VariableIncentivePayload>,\n    isBase?: boolean,\n  ) {\n    return new ERC20VariableIncentive(\n      { config: this._config, account: this._account },\n      options,\n      isBase,\n    );\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?[Address, Address]} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: [Address, Address],\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: boostCoreAbi,\n      bytecode: bytecode as Hex,\n      args: payload,\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n"],"names":["getAccount","config","uid","connection","addresses","address","chain","status","getChainId","getAction","client","actionFn","name","action_implicit","action_explicit","params","version","getVersion","__classPrivateFieldGet","receiver","state","kind","f","_BaseError_instances","_BaseError_walk","BaseError","shortMessage","options","details","_a","docsPath","fn","err","ConnectorNotConnectedError","ConnectorAccountNotFoundError","connector","ConnectorChainMismatchError","connectionChainId","connectorChainId","ConnectorUnavailableReconnectingError","getConnectorClient","parameters","accounts","chainId","account","parseAccount","getAddress","x","provider","createClient","opts","custom","simulateContract","abi","rest","action","viem_simulateContract","result","request","writeContract","__mode","activeConnector","simulateRequest","viem_writeContract","createWriteContract","c","configChainId","_ERC20VariableCriteriaIncentive","DeployableTarget","erc20VariableCriteriaIncentiveAbi","readErc20VariableCriteriaIncentiveGetIncentiveCriteria","IncentiveCriteriaNotFoundError","hash","criteria","transaction","getTransaction","SignatureType","logs","getTransactionReceipt","NoMatchingLogsError","eventAbi","events","decodedEvents","parseEventLogs","scalarValue","DecodedArgsError","e","func","functions","decodeFunctionData","InvalidCriteriaTypeError","_payload","_options","payload","bytecode","prepareERC20VariableCriteriaIncentivePayload","ERC20VariableCriteriaIncentiveBases","ERC20VariableCriteriaIncentive","asset","reward","limit","encodeAbiParameters","BOOST_CORE_CLAIM_FEE","parseEther","BOOST_CORE_ADDRESS","BoostCoreBases","BOOST_CORE_ADDRESSES","isBoostCoreDeployed","isBoostCoreDeployable","_BoostCore","Deployable","assertValidAddressByChainId","boostCoreAbi","_boostPayload","_params","desiredChainId","coreAddress","budget","validator","allowList","incentives","protocolFee","referralFee","maxParticipants","owner","boostFactory","_b","zeroAddress","DeployableUnknownOwnerProvidedError","budgetPayload","BudgetMustAuthorizeBoostCore","MustInitializeBudgetError","actionPayload","zeroHash","isBase","validatorPayload","allowListPayload","incentivesPayloads","i","incentive","IncentiveNotCloneableError","onChainPayload","boostHash","prepareBoostPayload","receipt","waitForTransactionReceipt","boostCreatedLog","boostId","BoostCoreNoIdentifierEmitted","boost","Boost","incentiveId","data","referrer","simulateBoostCoreClaimIncentive","writeBoostCoreClaimIncentive","claimant","simulateBoostCoreClaimIncentiveFor","writeBoostCoreClaimIncentiveFor","id","readBoostCoreGetBoost","_id","boostPayload","actionFromAddress","budgetFromAddress","validatorFromAddress","allowListFromAddress","incentiveAddress","incentiveFromAddress","readBoostCoreGetBoostCount","auth","readIAuthIsAuthorized","readBoostCoreCreateBoostAuth","simulateBoostCoreSetCreateBoostAuth","writeBoostCoreSetCreateBoostAuth","readBoostCoreProtocolFee","readBoostCoreProtocolFeeReceiver","simulateBoostCoreSetProtocolFeeReceiver","writeBoostCoreSetProtocolFeeReceiver","readBoostCoreClaimFee","claimFee","simulateBoostCoreSetClaimFee","writeBoostCoreSetClaimFee","PassthroughAuth","EventAction","OpenAllowList","SimpleAllowList","SimpleDenyList","ManagedBudget","AllowListIncentive","CGDAIncentive","ERC20Incentive","PointsIncentive","SignerValidator","ERC20VariableIncentive","BoostCore"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}