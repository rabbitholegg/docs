{"version":3,"file":"Contract.cjs","sources":["../../src/Deployable/Contract.ts"],"sourcesContent":["import { type Config, watchContractEvent } from '@wagmi/core';\nimport type { ExtractAbiEvent } from 'abitype';\nimport {\n  type Abi,\n  type Address,\n  type ContractEventName,\n  type GetLogsReturnType,\n  type WaitForTransactionReceiptParameters,\n  type WatchContractEventOnLogsParameter,\n  getAbiItem,\n} from 'viem';\nimport { getLogs } from 'viem/actions';\nimport { ContractAddressRequiredError } from '../errors';\nimport {\n  type GetLogsParams,\n  type HashAndSimulatedResult,\n  type WatchParams,\n  awaitResult,\n} from '../utils';\n\n/**\n * A basic Contract class to encapsulate configuration and a potential address\n *\n * @export\n * @class Contract\n * @typedef {Contract}\n * @template {Abi} [ContractAbi=[]]\n * @template {ContractEventName<ContractAbi>} [ContractEvent=any]\n */\nexport class Contract<ContractAbi extends Abi> {\n  //@ts-expect-error this should always be set by implementing contract\n  public readonly abi: ContractAbi;\n  /**\n   * @see [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)\n   * @protected\n   * @type {WagmiConfig}\n   */\n  protected _config: Config;\n  /**\n   * The internally managed address for this contract\n   *\n   * @protected\n   * @type {(Address | undefined)}\n   */\n  protected _address: Address | undefined;\n\n  /**\n   * Creates an instance of Contract.\n   *\n   * @constructor\n   * @param {Config} config\n   * @param {(Address | undefined)} address\n   */\n  constructor(config: Config, address: Address | undefined) {\n    this._config = config;\n    this._address = address;\n  }\n\n  /**\n   * A getter returning this contract's deployed address, if it exists.\n   *\n   * @public\n   * @readonly\n   * @type {Address | undefined}\n   */\n  public get address() {\n    return this._address;\n  }\n\n  /**\n   * Will set this contract's address and return the instance for chaining. Does not verify that provided address is valid.\n   *\n   * @public\n   * @param {Address} address\n   * @returns {this}\n   */\n  public at(address: Address) {\n    this._address = address;\n    return this;\n  }\n\n  /**\n   * Will set this contract's internal [Wagmi Configuration](https://en.wikipedia.org/wiki/Factorial) and return the instance for chaining.\n   *\n   * @public\n   * @param {Config} config\n   * @returns {this}\n   */\n  public withConfig(config: Config) {\n    this._config = config;\n    return this;\n  }\n\n  /**\n   * Utility function to validate the existence of an address on this Contract.\n   *\n   * @public\n   * @returns {Address}\n   * @throws {@link ContractAddressRequiredError} if no address exists on this Contract instance\n   */\n  public assertValidAddress() {\n    const address = this.address;\n    if (!address) throw new ContractAddressRequiredError();\n    return address;\n  }\n\n  /**\n   * A typed wrapper for (viem.getLogs)[https://viem.sh/docs/actions/public/getLogs#getlogs].\n   * Accepts `eventName` and `eventNames` as optional parameters to narrow the returned log types.\n   * @example\n   * ```ts\n   * const logs = contract.getLogs({ eventName: 'EventName' })\n   * const logs = contract.getLogs({ eventNames: ['EventName'] })\n   *\n   * @public\n   * @async\n   * @template {ContractEvent} event\n   * @template {ExtractAbiEvent<\n   *       ContractAbi,\n   *       event\n   *     >} [abiEvent=ExtractAbiEvent<ContractAbi, event>]\n   * @param {?Omit<\n   *       GetLogsParams<ContractAbi, event, abiEvent, abiEvent[]>,\n   *       'event' | 'events'\n   *     > & {\n   *       eventName?: event;\n   *       eventNames?: event[];\n   *     }} [params]\n   * @returns {Promise<GetLogsReturnType<abiEvent, abiEvent[]>>}\n   */\n  public async getLogs<\n    event extends ContractEventName<ContractAbi>,\n    const abiEvent extends ExtractAbiEvent<\n      ContractAbi,\n      event\n    > = ExtractAbiEvent<ContractAbi, event>,\n  >(\n    params?: Omit<\n      GetLogsParams<ContractAbi, event, abiEvent, abiEvent[]>,\n      'event' | 'events'\n    > & {\n      eventName?: event;\n      eventNames?: event[];\n    },\n  ): Promise<GetLogsReturnType<abiEvent, abiEvent[]>> {\n    return getLogs(this._config.getClient({ chainId: params?.chainId }), {\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wag\n      ...(params as any),\n      ...(params?.eventName\n        ? {\n            event: getAbiItem({\n              abi: this.abi,\n              name: params.eventName,\n              // biome-ignore lint/suspicious/noExplicitAny: awkward abi intersection issue\n            } as any),\n          }\n        : {}),\n      ...(params?.eventNames\n        ? {\n            events: params.eventNames.map((name) =>\n              getAbiItem({\n                abi: this.abi,\n                name,\n                // biome-ignore lint/suspicious/noExplicitAny: awkward abi intersection issue\n              } as any),\n            ),\n          }\n        : {}),\n      address: this.assertValidAddress(),\n    });\n  }\n\n  /**\n   * A typed wrapper for `wagmi.watchContractEvent`\n   *\n   * @public\n   * @template {ContractEvent} event\n   * @param {(\n   *       log: WatchContractEventOnLogsParameter<ContractAbi, event, true>[number],\n   *     ) => unknown} cb\n   * @param {?WatchParams<ContractAbi, event> & {\n   *       eventName?: event;\n   *     }} [params]\n   * @returns {() => void}\n   */\n  public subscribe<event extends ContractEventName<ContractAbi>>(\n    cb: (\n      log: WatchContractEventOnLogsParameter<ContractAbi, event, true>[number],\n    ) => unknown,\n    params?: WatchParams<ContractAbi, event> & {\n      eventName?: event;\n    },\n  ) {\n    return watchContractEvent<\n      typeof this._config,\n      (typeof this._config)['chains'][number]['id'],\n      ContractAbi,\n      event\n    >(this._config, {\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      eventName: params?.eventName,\n      abi: this.abi,\n      address: this.assertValidAddress(),\n      onLogs: (logs) => {\n        for (let l of logs) {\n          cb(l);\n        }\n      },\n    });\n  }\n\n  /**\n   * @see {@link awaitResult}\n   * @protected\n   * @async\n   * @template [Result=unknown]\n   * @param {Promise<HashAndSimulatedResult<Result>>} hashPromise\n   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]\n   * @returns {Promise<Result>}\n   */\n  protected async awaitResult<Result = unknown>(\n    hashPromise: Promise<HashAndSimulatedResult<Result>>,\n    waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n  ) {\n    return await awaitResult(this._config, hashPromise, waitParams);\n  }\n}\n"],"names":["Contract","config","address","ContractAddressRequiredError","params","getLogs","getAbiItem","name","cb","watchContractEvent","logs","l","hashPromise","waitParams","awaitResult"],"mappings":"gNA6BO,MAAMA,CAAkC,CAwB7C,YAAYC,EAAgBC,EAA8B,CACxD,KAAK,QAAUD,EACf,KAAK,SAAWC,CAClB,CASA,IAAW,SAAU,CACnB,OAAO,KAAK,QACd,CASO,GAAGA,EAAkB,CAC1B,YAAK,SAAWA,EACT,IACT,CASO,WAAWD,EAAgB,CAChC,YAAK,QAAUA,EACR,IACT,CASO,oBAAqB,CAC1B,MAAMC,EAAU,KAAK,QACrB,GAAI,CAACA,EAAe,MAAA,IAAIC,EAAAA,6BACjB,OAAAD,CACT,CA0BA,MAAa,QAOXE,EAOkD,CAC3C,OAAAC,EAAA,QAAQ,KAAK,QAAQ,UAAU,CAAE,QAASD,GAAA,YAAAA,EAAQ,OAAQ,CAAC,EAAG,CAEnE,GAAIA,EACJ,GAAIA,GAAA,MAAAA,EAAQ,UACR,CACE,MAAOE,EAAAA,WAAW,CAChB,IAAK,KAAK,IACV,KAAMF,EAAO,SAAA,CAEP,CAAA,EAEV,CAAC,EACL,GAAIA,GAAA,MAAAA,EAAQ,WACR,CACE,OAAQA,EAAO,WAAW,IAAKG,GAC7BD,EAAAA,WAAW,CACT,IAAK,KAAK,IACV,KAAAC,CAAA,CAEM,CACV,CAAA,EAEF,CAAC,EACL,QAAS,KAAK,mBAAmB,CAAA,CAClC,CACH,CAeO,UACLC,EAGAJ,EAGA,CACO,OAAAK,EAAA,mBAKL,KAAK,QAAS,CAEd,GAAIL,EACJ,UAAWA,GAAA,YAAAA,EAAQ,UACnB,IAAK,KAAK,IACV,QAAS,KAAK,mBAAmB,EACjC,OAASM,GAAS,CAChB,QAASC,KAAKD,EACZF,EAAGG,CAAC,CAER,CAAA,CACD,CACH,CAWA,MAAgB,YACdC,EACAC,EACA,CACA,OAAO,MAAMC,EAAA,YAAY,KAAK,QAASF,EAAaC,CAAU,CAChE,CACF"}