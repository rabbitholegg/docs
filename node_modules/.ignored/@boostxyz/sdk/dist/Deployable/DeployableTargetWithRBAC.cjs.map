{"version":3,"file":"DeployableTargetWithRBAC.cjs","sources":["../../src/Deployable/DeployableTargetWithRBAC.ts"],"sourcesContent":["import {\n  rbacAbi,\n  readRbacHasAllRoles,\n  readRbacHasAnyRole,\n  readRbacIsAuthorized,\n  readRbacRolesOf,\n  simulateRbacGrantRoles,\n  simulateRbacRevokeRoles,\n  simulateRbacSetAuthorized,\n  writeRbacGrantRoles,\n  writeRbacRevokeRoles,\n  writeRbacSetAuthorized,\n} from '@boostxyz/evm';\nimport type { Abi, Address, ContractEventName } from 'viem';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport type { GenericLog, ReadParams, WriteParams } from '../utils';\nexport { rbacAbi };\n\n/**\n *  Enum representing available roles for use with the `RBAC` authorization scheme.\n * `MANAGER` has lowest level of write permissions, for specific implementations, see Budgets and ALlowLists\n * `ADMIN` can additionally manage authorized users on the contract.\n *\n * @export\n * @type {{ readonly MANAGER: 1n; readonly ADMIN_ROLE: 2n; }}\n * @enum {bigint}\n */\nexport enum Roles {\n  //@ts-expect-error ts doesn't like bigint enum values\n  MANAGER = 1n,\n  //@ts-expect-error ts doesn't like bigint enum values\n  ADMIN = 2n,\n}\n\n/**\n * A generic `viem.Log` event with support for `Rbac` event types.\n *\n * @export\n * @typedef {RBACLog}\n * @template {ContractEventName<typeof rbacAbi>} [event=ContractEventName<\n *     typeof rbacAbi\n *   >]\n */\nexport type RBACLog<\n  event extends ContractEventName<typeof rbacAbi> = ContractEventName<\n    typeof rbacAbi\n  >,\n> = GenericLog<typeof rbacAbi, event>;\n\n/**\n * A minimal RBAC implementation that offers MANAGER and ADMIN roles, and\n * Budgets and allowlists support this auth scheme\n *\n * @export\n * @class DeployableTargetWithRBAC\n * @typedef {DeployableTargetWithRBAC}\n * @extends {DeployableTarget<RbacPayload>}\n */\nexport class DeployableTargetWithRBAC<\n  Payload,\n  ABI extends Abi,\n> extends DeployableTarget<Payload, ABI> {\n  /**\n   * Set the authorized status of the given accounts\n   * The mechanism for managing authorization is left to the implementing contract\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The accounts to authorize or deauthorize\n   * @param {boolean[]} allowed - The authorization status for the given accounts\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setAuthorized(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof rbacAbi, 'setAuthorized'>,\n  ) {\n    return await this.awaitResult(\n      this.setAuthorizedRaw(addresses, allowed, params),\n    );\n  }\n\n  /**\n   * Set the authorized status of the given accounts\n   * The mechanism for managing authorization is left to the implementing contract\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The accounts to authorize or deauthorize\n   * @param {boolean[]} allowed - The authorization status for the given accounts\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setAuthorizedRaw(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof rbacAbi, 'setAuthorized'>,\n  ) {\n    const { request, result } = await simulateRbacSetAuthorized(this._config, {\n      address: this.assertValidAddress(),\n      args: [addresses, allowed],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n    const hash = await writeRbacSetAuthorized(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Grant many accounts permissions on the rbac.\n   *\n   * @example\n   * ```ts\n   * await rbac.grantRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])\n   * ```\n   * @public\n   * @async\n   * @param {Address[]} addresses\n   * @param {RbacRoles[]} roles\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async grantRoles(\n    addresses: Address[],\n    roles: Roles[],\n    params?: WriteParams<typeof rbacAbi, 'grantRoles'>,\n  ) {\n    return await this.awaitResult(this.grantRolesRaw(addresses, roles, params));\n  }\n\n  /**\n   * Grant many accounts permissions on the rbac.\n   *\n   * @example\n   * ```ts\n   * await rbac.grantRoles(['0xfoo', '0xbar], [Roles.MANAGER, Roles.ADMIN])\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses\n   * @param {RbacRoles[]} roles\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async grantRolesRaw(\n    addresses: Address[],\n    roles: Roles[],\n    params?: WriteParams<typeof rbacAbi, 'grantRoles'>,\n  ) {\n    const { request, result } = await simulateRbacGrantRoles(this._config, {\n      address: this.assertValidAddress(),\n      args: [addresses, roles],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n    const hash = await writeRbacGrantRoles(\n      this._config,\n      // biome-ignore lint/suspicious/noExplicitAny: negligible low level lack of type intersection\n      request as any,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Revoke many accounts' permissions on the rbac.\n   *\n   * @example\n   * ```ts\n   * await rbac.revokeRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses\n   * @param {RbacRoles[]} roles\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async revokeRoles(\n    addresses: Address[],\n    roles: Roles[],\n    params?: WriteParams<typeof rbacAbi, 'revokeRoles'>,\n  ) {\n    return await this.awaitResult(\n      this.revokeRolesRaw(addresses, roles, params),\n    );\n  }\n\n  /**\n   * Revoke many accounts' permissions on the rbac.\n   *\n   * @example\n   * ```ts\n   * await rbac.revokeRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])\n   * @public\n   * @async\n   * @param {Address[]} addresses\n   * @param {RbacRoles[]} roles\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async revokeRolesRaw(\n    addresses: Address[],\n    roles: Roles[],\n    params?: WriteParams<typeof rbacAbi, 'revokeRoles'>,\n  ) {\n    const { request, result } = await simulateRbacRevokeRoles(this._config, {\n      address: this.assertValidAddress(),\n      args: [addresses, roles],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n    const hash = await writeRbacRevokeRoles(\n      this._config,\n      // biome-ignore lint/suspicious/noExplicitAny: negligible low level lack of type intersection\n      request as any,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Return an array of the roles assigned to the given account.\n   * @example\n   * ```ts\n   * (await rbac.rolesOf(0xfoo)).includes(RbacRoles.ADMIN)\n   * @public\n   * @param {Address} account\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Array<RbacRoles>>}\n   */\n  public async rolesOf(\n    account: Address,\n    params?: ReadParams<typeof rbacAbi, 'rolesOf'>,\n  ) {\n    const roles = await readRbacRolesOf(this._config, {\n      address: this.assertValidAddress(),\n      args: [account],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n    return ([Roles.MANAGER, Roles.ADMIN] as unknown as Array<bigint>).filter(\n      (role) => (roles & role) === role,\n    ) as unknown as Roles[];\n  }\n\n  /**\n   * Returns whether given account has any of the provided roles bitmap.\n   *\n   * @example\n   * ```ts\n   * await rbac.hasAnyRole(0xfoo, RbacRoles.ADMIN | RbacRoles.MANAGER)\n   * @public\n   * @param {Address} account\n   * @param {RbacRoles} roles\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public hasAnyRole(\n    account: Address,\n    roles: Roles,\n    params?: ReadParams<typeof rbacAbi, 'hasAnyRole'>,\n  ) {\n    return readRbacHasAnyRole(this._config, {\n      address: this.assertValidAddress(),\n      args: [account, roles],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Returns whether given account has all of the provided roles bitmap.\n   *\n   * @example\n   * ```ts\n   * await rbac.hasAllRoles(0xfoo, RbacRoles.ADMIN & RbacRoles.MANAGER)\n   *\n   * @public\n   * @param {Address} account\n   * @param {RbacRoles} roles\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public hasAllRoles(\n    account: Address,\n    roles: Roles,\n    params?: ReadParams<typeof rbacAbi, 'hasAllRoles'>,\n  ) {\n    return readRbacHasAllRoles(this._config, {\n      address: this.assertValidAddress(),\n      args: [account, roles],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Check if the given account is authorized to use the rbac\n   *\n   * @public\n   * @param {Address} account\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} - True if the account is authorized\n   */\n  public isAuthorized(\n    account: Address,\n    params?: ReadParams<typeof rbacAbi, 'isAuthorized'>,\n  ) {\n    return readRbacIsAuthorized(this._config, {\n      address: this.assertValidAddress(),\n      args: [account],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n}\n"],"names":["Roles","DeployableTargetWithRBAC","DeployableTarget","addresses","allowed","params","request","result","simulateRbacSetAuthorized","writeRbacSetAuthorized","roles","simulateRbacGrantRoles","writeRbacGrantRoles","simulateRbacRevokeRoles","writeRbacRevokeRoles","account","readRbacRolesOf","role","readRbacHasAnyRole","readRbacHasAllRoles","readRbacIsAuthorized"],"mappings":"iKA2BY,IAAAA,GAAAA,IAEVA,EAAAA,EAAA,QAAU,EAAV,EAAA,UAEAA,EAAAA,EAAA,MAAQ,EAAR,EAAA,QAJUA,IAAAA,GAAA,CAAA,CAAA,EA+BL,MAAMC,UAGHC,EAAAA,gBAA+B,CAYvC,MAAa,cACXC,EACAC,EACAC,EACA,CACA,OAAO,MAAM,KAAK,YAChB,KAAK,iBAAiBF,EAAWC,EAASC,CAAM,CAAA,CAEpD,CAaA,MAAa,iBACXF,EACAC,EACAC,EACA,CACA,KAAM,CAAE,QAAAC,EAAS,OAAAC,CAAA,EAAW,MAAMC,EAAA,GAA0B,KAAK,QAAS,CACxE,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACL,EAAWC,CAAO,EACzB,GAAG,KAAK,wBAAwB,EAEhC,GAAIC,CAAA,CACL,EAEM,MAAA,CAAE,KADI,MAAMI,EAAuB,GAAA,KAAK,QAASH,CAAO,EAChD,OAAAC,EACjB,CAgBA,MAAa,WACXJ,EACAO,EACAL,EACA,CACO,OAAA,MAAM,KAAK,YAAY,KAAK,cAAcF,EAAWO,EAAOL,CAAM,CAAC,CAC5E,CAgBA,MAAa,cACXF,EACAO,EACAL,EACA,CACA,KAAM,CAAE,QAAAC,EAAS,OAAAC,CAAA,EAAW,MAAMI,EAAA,GAAuB,KAAK,QAAS,CACrE,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACR,EAAWO,CAAK,EACvB,GAAG,KAAK,wBAAwB,EAEhC,GAAIL,CAAA,CACL,EAMM,MAAA,CAAE,KALI,MAAMO,EAAA,GACjB,KAAK,QAELN,CAAA,EAEa,OAAAC,EACjB,CAgBA,MAAa,YACXJ,EACAO,EACAL,EACA,CACA,OAAO,MAAM,KAAK,YAChB,KAAK,eAAeF,EAAWO,EAAOL,CAAM,CAAA,CAEhD,CAeA,MAAa,eACXF,EACAO,EACAL,EACA,CACA,KAAM,CAAE,QAAAC,EAAS,OAAAC,CAAA,EAAW,MAAMM,EAAA,GAAwB,KAAK,QAAS,CACtE,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACV,EAAWO,CAAK,EACvB,GAAG,KAAK,wBAAwB,EAEhC,GAAIL,CAAA,CACL,EAMM,MAAA,CAAE,KALI,MAAMS,EAAA,GACjB,KAAK,QAELR,CAAA,EAEa,OAAAC,EACjB,CAYA,MAAa,QACXQ,EACAV,EACA,CACA,MAAMK,EAAQ,MAAMM,KAAgB,KAAK,QAAS,CAChD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACD,CAAO,EACd,GAAG,KAAK,wBAAwB,EAEhC,GAAIV,CAAA,CACL,EACD,MAAQ,CAACL,EAAM,QAASA,EAAM,KAAK,EAA+B,OAC/DiB,IAAUP,EAAQO,KAAUA,CAAA,CAEjC,CAcO,WACLF,EACAL,EACAL,EACA,CACO,OAAAa,EAAA,GAAmB,KAAK,QAAS,CACtC,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACH,EAASL,CAAK,EACrB,GAAG,KAAK,wBAAwB,EAEhC,GAAIL,CAAA,CACL,CACH,CAeO,YACLU,EACAL,EACAL,EACA,CACO,OAAAc,EAAA,GAAoB,KAAK,QAAS,CACvC,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACJ,EAASL,CAAK,EACrB,GAAG,KAAK,wBAAwB,EAEhC,GAAIL,CAAA,CACL,CACH,CAUO,aACLU,EACAV,EACA,CACO,OAAAe,EAAA,GAAqB,KAAK,QAAS,CACxC,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACL,CAAO,EACd,GAAG,KAAK,wBAAwB,EAEhC,GAAIV,CAAA,CACL,CACH,CACF"}