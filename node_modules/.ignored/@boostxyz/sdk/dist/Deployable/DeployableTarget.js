import { q as d, r as c } from "../generated-B7VaSah4.js";
import { deployContract as h } from "@wagmi/core";
import { isAddress as u, zeroAddress as l, isAddressEqual as a } from "viem";
import { DeployableAlreadyDeployedError as y, DeployableMissingPayloadError as f } from "../errors.js";
import { RegistryType as m } from "../utils.js";
import { Deployable as p } from "./Deployable.js";
const i = class i extends p {
  /**
   * Creates an instance of DeployableTarget.
   *
   * @constructor
   * @param {DeployableOptions} options
   * @param {DeployablePayloadOrAddress<Payload>} payload - Either a given implementation's initialization payload, or an address to an existing on chain target.
   * @param {?boolean} [isBase] - A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.
   */
  constructor(t, s, r) {
    super(t, s), this._isBase = !0, typeof s == "string" && u(s) && s !== l && !Object.values(this.bases).some((e) => !s || !e ? !1 : a(s, e)) && (r = !1), r !== void 0 && (this._isBase = r);
  }
  get isBase() {
    return this.address && Object.values(this.bases).some(
      (t) => (
        // biome-ignore lint/style/noNonNullAssertion: won't evaluate this if address checked and defined above
        a(this.address, t)
      )
    ) ? !0 : this._isBase;
  }
  /**
   * A getter that will return the base implementation's static addresses by numerical chain ID
   *
   * @public
   * @readonly
   * @type {Record<number, Address>}
   */
  get bases() {
    return this.constructor.bases;
  }
  /**
   * A getter that returns the registry type of the base implementation
   *
   * @public
   * @readonly
   * @type {RegistryType}
   */
  get registryType() {
    return this.constructor.registryType;
  }
  /**
   * @inheritdoc
   *
   * @public
   * @async
   * @param {?Payload} [payload]
   * @param {?DeployableOptions} [options]
   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]
   * @returns {Promise<this>}
   */
  async deploy(t, s, r) {
    return await super.deploy(t, s, r), this.assertValidAddress(), this;
  }
  /**
   * @inheritdoc
   *
   * @public
   * @async
   * @param {?Payload} [_payload]
   * @param {?DeployableOptions} [_options]
   * @returns {Promise<Hash>}
   */
  async deployRaw(t, s) {
    if (this.address) throw new y(this.address);
    const r = t || this._payload, e = (s == null ? void 0 : s.config) || this._config, { args: g, ...n } = this.buildParameters(r);
    return await h(e, {
      ...n,
      ...this.optionallyAttachAccount(s == null ? void 0 : s.account),
      // Deployable targets don't construct with arguments, they initialize with encoded payloads
      args: []
    });
  }
  /**
   * Check if the contract supports the given interface
   *
   * @public
   * @async
   * @param {Hex} interfaceId - The interface identifier
   * @param {?ReadParams} [params]
   * @returns {Promise<boolean>} - True if the contract supports the interface
   */
  async supportsInterface(t, s) {
    return await d(this._config, {
      address: this.assertValidAddress(),
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...s,
      args: [t]
    });
  }
  /**
   *  Return a cloneable's unique identifier for downstream consumers to differentiate various targets
   *  All implementations must override this function
   *
   * @public
   * @async
   * @param {?ReadParams} [params]
   * @returns {Promise<Hex>}
   */
  async getComponentInterface(t) {
    return await c(this._config, {
      address: this.assertValidAddress(),
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...t,
      args: []
    });
  }
  /**
   * @inheritdoc
   *
   * @protected
   * @template [P=Payload]
   * @param {?P} [_payload]
   * @param {?DeployableOptions} [_options]
   * @returns {[P, DeployableOptions]}
   */
  validateDeploymentConfig(t, s) {
    const r = t || this._payload;
    if (!r) throw new f();
    return super.validateDeploymentConfig(r, s);
  }
};
i.bases = {}, i.registryType = m.ACTION;
let o = i;
export {
  o as DeployableTarget
};
//# sourceMappingURL=DeployableTarget.js.map
