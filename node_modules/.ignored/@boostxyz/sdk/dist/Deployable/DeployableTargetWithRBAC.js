import { M as h, f as c, e as l, h as d, i as A, j as g, o as u, k as w, n as y, m as R } from "../generated-B7VaSah4.js";
import { z as N } from "../generated-B7VaSah4.js";
import { DeployableTarget as f } from "./DeployableTarget.js";
var o = /* @__PURE__ */ ((r) => (r[r.MANAGER = 1n] = "MANAGER", r[r.ADMIN = 2n] = "ADMIN", r))(o || {});
class M extends f {
  /**
   * Set the authorized status of the given accounts
   * The mechanism for managing authorization is left to the implementing contract
   *
   * @public
   * @async
   * @param {Address[]} addresses - The accounts to authorize or deauthorize
   * @param {boolean[]} allowed - The authorization status for the given accounts
   * @param {?WriteParams} [params]
   * @returns {Promise<void>}
   */
  async setAuthorized(s, t, a) {
    return await this.awaitResult(
      this.setAuthorizedRaw(s, t, a)
    );
  }
  /**
   * Set the authorized status of the given accounts
   * The mechanism for managing authorization is left to the implementing contract
   *
   * @public
   * @async
   * @param {Address[]} addresses - The accounts to authorize or deauthorize
   * @param {boolean[]} allowed - The authorization status for the given accounts
   * @param {?WriteParams} [params]
   * @returns {Promise<void>}
   */
  async setAuthorizedRaw(s, t, a) {
    const { request: i, result: e } = await h(this._config, {
      address: this.assertValidAddress(),
      args: [s, t],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...a
    });
    return { hash: await c(this._config, i), result: e };
  }
  /**
   * Grant many accounts permissions on the rbac.
   *
   * @example
   * ```ts
   * await rbac.grantRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])
   * ```
   * @public
   * @async
   * @param {Address[]} addresses
   * @param {RbacRoles[]} roles
   * @param {?WriteParams} [params]
   * @returns {Promise<void>}
   */
  async grantRoles(s, t, a) {
    return await this.awaitResult(this.grantRolesRaw(s, t, a));
  }
  /**
   * Grant many accounts permissions on the rbac.
   *
   * @example
   * ```ts
   * await rbac.grantRoles(['0xfoo', '0xbar], [Roles.MANAGER, Roles.ADMIN])
   *
   * @public
   * @async
   * @param {Address[]} addresses
   * @param {RbacRoles[]} roles
   * @param {?WriteParams} [params]
   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}
   */
  async grantRolesRaw(s, t, a) {
    const { request: i, result: e } = await l(this._config, {
      address: this.assertValidAddress(),
      args: [s, t],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...a
    });
    return { hash: await d(
      this._config,
      // biome-ignore lint/suspicious/noExplicitAny: negligible low level lack of type intersection
      i
    ), result: e };
  }
  /**
   * Revoke many accounts' permissions on the rbac.
   *
   * @example
   * ```ts
   * await rbac.revokeRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])
   *
   * @public
   * @async
   * @param {Address[]} addresses
   * @param {RbacRoles[]} roles
   * @param {?WriteParams} [params]
   * @returns {Promise<void>}
   */
  async revokeRoles(s, t, a) {
    return await this.awaitResult(
      this.revokeRolesRaw(s, t, a)
    );
  }
  /**
   * Revoke many accounts' permissions on the rbac.
   *
   * @example
   * ```ts
   * await rbac.revokeRoles(['0xfoo', '0xbar], [RbacRoles.MANAGER, RbacRoles.ADMIN])
   * @public
   * @async
   * @param {Address[]} addresses
   * @param {RbacRoles[]} roles
   * @param {?WriteParams} [params]
   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}
   */
  async revokeRolesRaw(s, t, a) {
    const { request: i, result: e } = await A(this._config, {
      address: this.assertValidAddress(),
      args: [s, t],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...a
    });
    return { hash: await g(
      this._config,
      // biome-ignore lint/suspicious/noExplicitAny: negligible low level lack of type intersection
      i
    ), result: e };
  }
  /**
   * Return an array of the roles assigned to the given account.
   * @example
   * ```ts
   * (await rbac.rolesOf(0xfoo)).includes(RbacRoles.ADMIN)
   * @public
   * @param {Address} account
   * @param {?ReadParams} [params]
   * @returns {Promise<Array<RbacRoles>>}
   */
  async rolesOf(s, t) {
    const a = await u(this._config, {
      address: this.assertValidAddress(),
      args: [s],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...t
    });
    return [o.MANAGER, o.ADMIN].filter(
      (i) => (a & i) === i
    );
  }
  /**
   * Returns whether given account has any of the provided roles bitmap.
   *
   * @example
   * ```ts
   * await rbac.hasAnyRole(0xfoo, RbacRoles.ADMIN | RbacRoles.MANAGER)
   * @public
   * @param {Address} account
   * @param {RbacRoles} roles
   * @param {?ReadParams} [params]
   * @returns {Promise<boolean>}
   */
  hasAnyRole(s, t, a) {
    return w(this._config, {
      address: this.assertValidAddress(),
      args: [s, t],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...a
    });
  }
  /**
   * Returns whether given account has all of the provided roles bitmap.
   *
   * @example
   * ```ts
   * await rbac.hasAllRoles(0xfoo, RbacRoles.ADMIN & RbacRoles.MANAGER)
   *
   * @public
   * @param {Address} account
   * @param {RbacRoles} roles
   * @param {?ReadParams} [params]
   * @returns {Promise<boolean>}
   */
  hasAllRoles(s, t, a) {
    return y(this._config, {
      address: this.assertValidAddress(),
      args: [s, t],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...a
    });
  }
  /**
   * Check if the given account is authorized to use the rbac
   *
   * @public
   * @param {Address} account
   * @param {?ReadParams} [params]
   * @returns {Promise<boolean>} - True if the account is authorized
   */
  isAuthorized(s, t) {
    return R(this._config, {
      address: this.assertValidAddress(),
      args: [s],
      ...this.optionallyAttachAccount(),
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...t
    });
  }
}
export {
  M as DeployableTargetWithRBAC,
  o as Roles,
  N as rbacAbi
};
//# sourceMappingURL=DeployableTargetWithRBAC.js.map
