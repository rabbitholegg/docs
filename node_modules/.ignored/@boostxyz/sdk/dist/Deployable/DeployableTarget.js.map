{"version":3,"file":"DeployableTarget.js","sources":["../../src/Deployable/DeployableTarget.ts"],"sourcesContent":["import {\n  type aCloneableAbi,\n  readACloneableGetComponentInterface,\n  readACloneableSupportsInterface,\n} from '@boostxyz/evm';\nimport { deployContract } from '@wagmi/core';\nimport {\n  type Abi,\n  type Address,\n  type Hash,\n  type Hex,\n  type WaitForTransactionReceiptParameters,\n  isAddress,\n  isAddressEqual,\n  zeroAddress,\n} from 'viem';\nimport {\n  DeployableAlreadyDeployedError,\n  DeployableMissingPayloadError,\n} from '../errors';\nimport { type ReadParams, RegistryType } from '../utils';\nimport {\n  Deployable,\n  type DeployableOptions,\n  type DeployablePayloadOrAddress,\n} from './Deployable';\n\n/**\n * A base class representing a generic base Boost Protocol target contract, extended by Actions, AllowLists, Budgets, Incentives, and Validators.\n *\n * @export\n * @class DeployableTarget\n * @typedef {DeployableTarget}\n * @template [Payload=unknown]\n * @extends {Deployable<Payload>}\n */\nexport class DeployableTarget<\n  Payload,\n  ContractAbi extends Abi,\n> extends Deployable<Payload, ContractAbi> {\n  /**\n   * A static property representing a map of stringified chain ID's to the address of the base implementation on chain, used when cloning base contracts.\n   *\n   * @static\n   * @readonly\n   * @type {Record<string, Address>}\n   */\n  static readonly bases: Record<number, Address> = {};\n  /**\n   * The target's registry type.\n   *\n   * @static\n   * @readonly\n   * @type {RegistryType}\n   */\n  static readonly registryType: RegistryType = RegistryType.ACTION;\n  /**\n   * A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  readonly _isBase: boolean = true;\n  public get isBase() {\n    if (\n      !!this.address &&\n      Object.values(this.bases).some((base) =>\n        // biome-ignore lint/style/noNonNullAssertion: won't evaluate this if address checked and defined above\n        isAddressEqual(this.address!, base),\n      )\n    )\n      return true;\n    return this._isBase;\n  }\n\n  /**\n   * Creates an instance of DeployableTarget.\n   *\n   * @constructor\n   * @param {DeployableOptions} options\n   * @param {DeployablePayloadOrAddress<Payload>} payload - Either a given implementation's initialization payload, or an address to an existing on chain target.\n   * @param {?boolean} [isBase] - A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.\n   */\n  constructor(\n    options: DeployableOptions,\n    payload?: DeployablePayloadOrAddress<Payload>,\n    isBase?: boolean,\n  ) {\n    super(options, payload);\n    // if supplying a custom address, safe enough to assume it is not a base address which makes reusing contracts like budgets easier\n    if (\n      typeof payload === 'string' &&\n      isAddress(payload) &&\n      payload !== zeroAddress &&\n      !Object.values(this.bases).some((base) => {\n        if (!payload || !base) return false;\n        return isAddressEqual(payload, base);\n      })\n    )\n      isBase = false;\n    if (isBase !== undefined) this._isBase = isBase;\n  }\n\n  /**\n   * A getter that will return the base implementation's static addresses by numerical chain ID\n   *\n   * @public\n   * @readonly\n   * @type {Record<number, Address>}\n   */\n  public get bases(): Record<number, Address> {\n    return (this.constructor as typeof DeployableTarget).bases;\n  }\n\n  /**\n   * A getter that returns the registry type of the base implementation\n   *\n   * @public\n   * @readonly\n   * @type {RegistryType}\n   */\n  public get registryType(): RegistryType {\n    return (this.constructor as typeof DeployableTarget).registryType;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @async\n   * @param {?Payload} [payload]\n   * @param {?DeployableOptions} [options]\n   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]\n   * @returns {Promise<this>}\n   */\n  protected override async deploy(\n    payload?: Payload,\n    options?: DeployableOptions,\n    waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n  ) {\n    await super.deploy(payload, options, waitParams);\n    this.assertValidAddress();\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @async\n   * @param {?Payload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {Promise<Hash>}\n   */\n  protected override async deployRaw(\n    _payload?: Payload,\n    _options?: DeployableOptions,\n  ): Promise<Hash> {\n    if (this.address) throw new DeployableAlreadyDeployedError(this.address);\n    const payload = _payload || this._payload;\n    const config = _options?.config || this._config;\n    const { args, ...deployment } = this.buildParameters(payload);\n    return await deployContract(config, {\n      ...deployment,\n      ...this.optionallyAttachAccount(_options?.account),\n      // Deployable targets don't construct with arguments, they initialize with encoded payloads\n      args: [],\n    });\n  }\n\n  /**\n   * Check if the contract supports the given interface\n   *\n   * @public\n   * @async\n   * @param {Hex} interfaceId - The interface identifier\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} - True if the contract supports the interface\n   */\n  public async supportsInterface(\n    interfaceId: Hex,\n    params?: ReadParams<typeof aCloneableAbi, 'supportsInterface'>,\n  ) {\n    return await readACloneableSupportsInterface(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [interfaceId],\n    });\n  }\n\n  /**\n   *  Return a cloneable's unique identifier for downstream consumers to differentiate various targets\n   *  All implementations must override this function\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>}\n   */\n  public async getComponentInterface(\n    params?: ReadParams<typeof aCloneableAbi, 'getComponentInterface'>,\n  ) {\n    return await readACloneableGetComponentInterface(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [],\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @protected\n   * @template [P=Payload]\n   * @param {?P} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {[P, DeployableOptions]}\n   */\n  protected override validateDeploymentConfig<P = Payload>(\n    _payload?: P,\n    _options?: DeployableOptions,\n  ) {\n    const payload = _payload || this._payload;\n    if (!payload) throw new DeployableMissingPayloadError();\n    return super.validateDeploymentConfig(payload, _options) as [\n      P,\n      DeployableOptions,\n    ];\n  }\n}\n"],"names":["_DeployableTarget","Deployable","options","payload","isBase","isAddress","zeroAddress","base","isAddressEqual","waitParams","_payload","_options","DeployableAlreadyDeployedError","config","args","deployment","deployContract","interfaceId","params","readACloneableSupportsInterface","readACloneableGetComponentInterface","DeployableMissingPayloadError","RegistryType","DeployableTarget"],"mappings":";;;;;;AAoCO,MAAMA,IAAN,MAAMA,UAGHC,EAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4CzC,YACEC,GACAC,GACAC,GACA;AACA,UAAMF,GAASC,CAAO,GA1BxB,KAAS,UAAmB,IA6BxB,OAAOA,KAAY,YACnBE,EAAUF,CAAO,KACjBA,MAAYG,KACZ,CAAC,OAAO,OAAO,KAAK,KAAK,EAAE,KAAK,CAACC,MAC3B,CAACJ,KAAW,CAACI,IAAa,KACvBC,EAAeL,GAASI,CAAI,CACpC,MAEQH,IAAA,KACPA,MAAW,WAAW,KAAK,UAAUA;AAAA,EAC3C;AAAA,EAtCA,IAAW,SAAS;AAEhB,WAAE,KAAK,WACP,OAAO,OAAO,KAAK,KAAK,EAAE;AAAA,MAAK,CAACG;AAAA;AAAA,QAE9BC,EAAe,KAAK,SAAUD,CAAI;AAAA;AAAA,IACpC,IAEO,KACF,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCA,IAAW,QAAiC;AAC1C,WAAQ,KAAK,YAAwC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAW,eAA6B;AACtC,WAAQ,KAAK,YAAwC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAyB,OACvBJ,GACAD,GACAO,GACA;AACA,iBAAM,MAAM,OAAON,GAASD,GAASO,CAAU,GAC/C,KAAK,mBAAmB,GACjB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAyB,UACvBC,GACAC,GACe;AACf,QAAI,KAAK,QAAS,OAAM,IAAIC,EAA+B,KAAK,OAAO;AACjE,UAAAT,IAAUO,KAAY,KAAK,UAC3BG,KAASF,KAAA,gBAAAA,EAAU,WAAU,KAAK,SAClC,EAAE,MAAAG,GAAM,GAAGC,MAAe,KAAK,gBAAgBZ,CAAO;AACrD,WAAA,MAAMa,EAAeH,GAAQ;AAAA,MAClC,GAAGE;AAAA,MACH,GAAG,KAAK,wBAAwBJ,KAAA,gBAAAA,EAAU,OAAO;AAAA;AAAA,MAEjD,MAAM,CAAC;AAAA,IAAA,CACR;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,kBACXM,GACAC,GACA;AACO,WAAA,MAAMC,EAAgC,KAAK,SAAS;AAAA,MACzD,SAAS,KAAK,mBAAmB;AAAA,MACjC,GAAG,KAAK,wBAAwB;AAAA;AAAA,MAEhC,GAAID;AAAA,MACJ,MAAM,CAACD,CAAW;AAAA,IAAA,CACnB;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,sBACXC,GACA;AACO,WAAA,MAAME,EAAoC,KAAK,SAAS;AAAA,MAC7D,SAAS,KAAK,mBAAmB;AAAA,MACjC,GAAG,KAAK,wBAAwB;AAAA;AAAA,MAEhC,GAAIF;AAAA,MACJ,MAAM,CAAC;AAAA,IAAA,CACR;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWmB,yBACjBR,GACAC,GACA;AACM,UAAAR,IAAUO,KAAY,KAAK;AACjC,QAAI,CAACP,EAAe,OAAA,IAAIkB;AACjB,WAAA,MAAM,yBAAyBlB,GAASQ,CAAQ;AAAA,EAIzD;AACF;AA1LEX,EAAgB,QAAiC,IAQjDA,EAAgB,eAA6BsB,EAAa;AAnBrD,IAAMC,IAANvB;"}