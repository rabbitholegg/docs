import { type Config, deployContract } from '@wagmi/core';
import type { Abi, Account, Address, Hash, Hex, WaitForTransactionReceiptParameters } from 'viem';
import { Contract } from './Contract';
/**
 * A base class representing a deployable contract, contains base implementations for deployment and initialization payload construction.
 *
 * @export
 * @typedef {GenericDeployableParams}
 */
export type GenericDeployableParams = Omit<Parameters<typeof deployContract>[1], 'args' | 'account'> & {
    args: [Hex, ...Array<Hex>];
    account?: Account;
};
/**
 * A generic type that encapsulates either an initialization payload for a contract, or a valid address for a previously deployed contract.
 *
 * @export
 * @typedef {DeployablePayloadOrAddress}
 * @template [Payload=unknown]
 */
export type DeployablePayloadOrAddress<Payload = unknown> = Payload | Address;
/**
 * Instantion options for the base deployable.
 *
 * @export
 * @interface DeployableOptions
 * @typedef {DeployableOptions}
 */
export interface DeployableOptions {
    /**
     * [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)
     *
     * @see {@link Config}
     * @type {Config}
     */
    config: Config;
    /**
     * [Viem Local Account](https://viem.sh/docs/accounts/local), required if in a Node environment
     *
     * @see {@link Account}
     * @type {?Account}
     */
    account?: Account;
}
/**
 * A generic deployable contract that encapsulates common operations related to contract deployment
 *
 * @export
 * @class Deployable
 * @typedef {Deployable}
 * @template [Payload=unknown]
 * @template {Abi} [ContractAbi=[]]
 * @template {ContractEventName<ContractAbi>} [ContractEvent=ContractEventName<ContractAbi>]
 * @extends {Contract<ContractAbi, ContractEvent>}
 */
export declare class Deployable<Payload, ContractAbi extends Abi> extends Contract<ContractAbi> {
    /**
     * The deployable payload used either for contract construction or initialization
     *
     * @protected
     * @type {(Payload | undefined)}
     */
    protected _payload: Payload | undefined;
    /**
     * If it exists, [Viem Local Account](https://viem.sh/docs/accounts/local), if in a Node environment
     *
     * @protected
     * @type {?Account}
     */
    protected _account?: Account;
    /**
     * Creates an instance of Deployable.
     *
     * @constructor
     * @param {DeployableOptions} param0
     * @param {?Account} [param0.account]
     * @param {Config} param0.config
     * @param {DeployablePayloadOrAddress<Payload>} payload
     */
    constructor({ account, config }: DeployableOptions, payload?: DeployablePayloadOrAddress<Payload>);
    /**
     * Returns the attached deployable payload, if it exists
     *
     * @readonly
     * @type {Payload}
     */
    get payload(): Payload | undefined;
    /**
     * Attaches a new payload for use with this deployable's initialization
     *
     * @public
     * @param {Payload} payload
     * @returns {this}
     */
    withPayload(payload: Payload): this;
    /**
     * High level deployment function to deploy and await the contract address.
     * This is mainly a convenience method to easily deploy a contract, but will not initialize a `Cloneable`,
     * which makes it useless for Boost components.
     * Obviously you can ignore the TS warnings and use this, but you shouldn't in most all cases.
     *
     * @public
     * @async
     * @param {?Payload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams] - See [viem.WaitForTransactionReceipt](https://v1.viem.sh/docs/actions/public/waitForTransactionReceipt.html#waitfortransactionreceipt)
     * @returns {Promise<this>}
     */
    protected deploy(_payload?: Payload, _options?: DeployableOptions, waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>): Promise<this>;
    /**
     * The lower level contract deployment function that does not await for the transaction receipt.
     * This is mainly a convenience method to easily deploy a contract, but will not initialize a `Cloneable`,
     * which makes it useless for Boost components.
     * Obviously you can ignore the TS warnings and use this, but you shouldn't in most all cases.
     *
     * @public
     * @async
     * @param {?Payload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {Promise<Hash>}
     * @throws {@link DeployableAlreadyDeployedError}
     * @throws {@link DeployableWagmiConfigurationRequiredError}
     * @throws {@link DeployableMissingPayloadError}
     */
    protected deployRaw(_payload?: Payload, _options?: DeployableOptions): Promise<Hash>;
    /**
     * Internal function to attach the connected account to write methods to avoid manually passing in an account each call.
     *
     * @protected
     * @param {?Account} [account]
     * @returns {({ account: Account; } | { account?: undefined; })}
     */
    protected optionallyAttachAccount(account?: Account): {
        account: Account;
    } | {
        account?: undefined;
    };
    /**
     * Base parameter constructor, should return a partial `viem.deployContract` parameters shape including abi, bytecode, and arguments, if any.
     * Expected to be overridden by protocol contracts.
     *
     * @public
     * @param {?Payload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {GenericDeployableParams}
     */
    buildParameters(_payload?: Payload, _options?: DeployableOptions): GenericDeployableParams;
    /**
     * Internal method used to ensure that a Wagmi configuration and payload are always present when deploying.
     *
     * @protected
     * @template [P=Payload]
     * @param {?P} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {[P, DeployableOptions]}
     * @throws {@link DeployableWagmiConfigurationRequiredError}
     * @throws {@link DeployableMissingPayloadError}
     */
    protected validateDeploymentConfig<P = Payload>(_payload?: P, _options?: DeployableOptions): [P, DeployableOptions];
}
//# sourceMappingURL=Deployable.d.ts.map