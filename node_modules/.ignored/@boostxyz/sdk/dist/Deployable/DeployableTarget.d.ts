import { type aCloneableAbi } from '@boostxyz/evm';
import { type Abi, type Address, type Hash, type Hex, type WaitForTransactionReceiptParameters } from 'viem';
import { type ReadParams, RegistryType } from '../utils';
import { Deployable, type DeployableOptions, type DeployablePayloadOrAddress } from './Deployable';
/**
 * A base class representing a generic base Boost Protocol target contract, extended by Actions, AllowLists, Budgets, Incentives, and Validators.
 *
 * @export
 * @class DeployableTarget
 * @typedef {DeployableTarget}
 * @template [Payload=unknown]
 * @extends {Deployable<Payload>}
 */
export declare class DeployableTarget<Payload, ContractAbi extends Abi> extends Deployable<Payload, ContractAbi> {
    /**
     * A static property representing a map of stringified chain ID's to the address of the base implementation on chain, used when cloning base contracts.
     *
     * @static
     * @readonly
     * @type {Record<string, Address>}
     */
    static readonly bases: Record<number, Address>;
    /**
     * The target's registry type.
     *
     * @static
     * @readonly
     * @type {RegistryType}
     */
    static readonly registryType: RegistryType;
    /**
     * A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.
     *
     * @readonly
     * @type {boolean}
     */
    readonly _isBase: boolean;
    get isBase(): boolean;
    /**
     * Creates an instance of DeployableTarget.
     *
     * @constructor
     * @param {DeployableOptions} options
     * @param {DeployablePayloadOrAddress<Payload>} payload - Either a given implementation's initialization payload, or an address to an existing on chain target.
     * @param {?boolean} [isBase] - A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.
     */
    constructor(options: DeployableOptions, payload?: DeployablePayloadOrAddress<Payload>, isBase?: boolean);
    /**
     * A getter that will return the base implementation's static addresses by numerical chain ID
     *
     * @public
     * @readonly
     * @type {Record<number, Address>}
     */
    get bases(): Record<number, Address>;
    /**
     * A getter that returns the registry type of the base implementation
     *
     * @public
     * @readonly
     * @type {RegistryType}
     */
    get registryType(): RegistryType;
    /**
     * @inheritdoc
     *
     * @public
     * @async
     * @param {?Payload} [payload]
     * @param {?DeployableOptions} [options]
     * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]
     * @returns {Promise<this>}
     */
    protected deploy(payload?: Payload, options?: DeployableOptions, waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>): Promise<this>;
    /**
     * @inheritdoc
     *
     * @public
     * @async
     * @param {?Payload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {Promise<Hash>}
     */
    protected deployRaw(_payload?: Payload, _options?: DeployableOptions): Promise<Hash>;
    /**
     * Check if the contract supports the given interface
     *
     * @public
     * @async
     * @param {Hex} interfaceId - The interface identifier
     * @param {?ReadParams} [params]
     * @returns {Promise<boolean>} - True if the contract supports the interface
     */
    supportsInterface(interfaceId: Hex, params?: ReadParams<typeof aCloneableAbi, 'supportsInterface'>): Promise<boolean>;
    /**
     *  Return a cloneable's unique identifier for downstream consumers to differentiate various targets
     *  All implementations must override this function
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<Hex>}
     */
    getComponentInterface(params?: ReadParams<typeof aCloneableAbi, 'getComponentInterface'>): Promise<`0x${string}`>;
    /**
     * @inheritdoc
     *
     * @protected
     * @template [P=Payload]
     * @param {?P} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {[P, DeployableOptions]}
     */
    protected validateDeploymentConfig<P = Payload>(_payload?: P, _options?: DeployableOptions): [P, DeployableOptions];
}
//# sourceMappingURL=DeployableTarget.d.ts.map