import { signerValidatorAbi } from '@boostxyz/evm';
import { type Address, type ContractEventName, type Hex, type PrivateKeyAccount } from 'viem';
import type { DeployableOptions, GenericDeployableParams } from '../Deployable/Deployable';
import { DeployableTarget } from '../Deployable/DeployableTarget';
import { type GenericLog, type ReadParams, RegistryType, type WriteParams } from '../utils';
export { signerValidatorAbi };
/**
 * Object reprentation of a {@link SignerValidator} initialization payload
 *
 * @export
 * @interface SignerValidatorPayload
 * @typedef {SignerValidatorPayload}
 */
export interface SignerValidatorPayload {
    /**
     * The list of authorized signers. The first address in the list will be the initial owner of the contract.
     *
     * @type {Address[]}
     */
    signers: Address[];
    /**
     * The authorized caller of the {@link prepareSignerValidator} function
     * @type {Address}
     */
    validatorCaller: Address;
}
/**
 * Description placeholder
 *
 * @export
 * @interface SignerValidatorValidatePayload
 * @typedef {SignerValidatorValidatePayload}
 */
export interface SignerValidatorValidatePayload {
    /**
     * The ID of the boost.
     *
     * @type {bigint}
     */
    boostId: bigint;
    /**
     * The ID of the incentive.
     *
     * @type {bigint}
     */
    incentiveId: bigint;
    /**
     * The address of the claimant.
     *
     * @type {Address}
     */
    claimant: Address;
    /**
     * The claim data.
     *
     * @type {Hex}
     */
    claimData: Hex;
}
/**
 * Object reprentation of a {@link SignerValidator} initialization payload
 *
 * @export
 * @interface SignerValidatorPayload
 * @typedef {SignerValidatorPayload}
 */
export interface SignerValidatorPayload {
    /**
     * The list of authorized signers. The first address in the list will be the initial owner of the contract.
     *
     * @type {Address[]}
     */
    signers: Address[];
    /**
     * The authorized caller of the {@link prepareSignerValidator} function
     * @type {Address}
     */
    validatorCaller: Address;
}
/**
 * Description placeholder
 *
 * @export
 * @interface SignerValidatorValidatePayload
 * @typedef {SignerValidatorValidatePayload}
 */
export interface SignerValidatorValidatePayload {
    /**
     * The ID of the boost.
     *
     * @type {bigint}
     */
    boostId: bigint;
    /**
     * The ID of the incentive.
     *
     * @type {bigint}
     */
    incentiveId: bigint;
    /**
     * The address of the claimant.
     *
     * @type {Address}
     */
    claimant: Address;
    /**
     * The claim data.
     *
     * @type {Hex}
     */
    claimData: Hex;
}
/**
 * Signer Validator Claim Data Payload
 *
 * @export
 * @interface SignerValidatorClaimDataParams
 * @typedef {SignerValidatorClaimDataParams}
 */
export interface SignerValidatorClaimDataParams {
    /**
     * The signer with which to sign the input
     *
     * @type {{
     *     account: Address;
     *     key: Hex;
     *     privateKey: PrivateKeyAccount;
     *   }}
     */
    signer: {
        account: Address;
        key: Hex;
        privateKey: PrivateKeyAccount;
    };
    /**
     * The encoded data to provide the underlying incentive. You can use {@link prepareAllowListIncentivePayload}, {@link prepareCGDAIncentivePayload}, {@link prepareERC20IncentivePayload}, {@link prepareERC1155IncentivePayload}, or {@link preparePointsIncentivePayload}
     *
     * @type {Hex}
     */
    incentiveData: Hex;
    /**
     * The chain id to target
     *
     * @type {number}
     */
    chainId: number;
    /**
     * The address of the validator
     *
     * @type {Address}
     */
    validator: Address;
    /**
     * The incentive quantity.
     *
     * @type {number}
     */
    incentiveQuantity: number;
    /**
     * The address of the claimant
     *
     * @type {Address}
     */
    claimant: Address;
    /**
     * The ID of the boost
     *
     * @type {bigint}
     */
    boostId: bigint;
}
/**
 * Object representation of a {@link SignerValidatorInputParams} initialization payload
 *
 * @export
 * @interface SignerValidatorInputParams
 * @typedef {SignerValidatorInputParams}
 */
export interface SignerValidatorInputParams {
    /**
     * The signer address.
     *
     * @type {Address}
     */
    signer: Address;
    /**
     * The signature data.
     *
     * @type {string}
     */
    signature: Hex;
    /**
     * The incentive quantity.
     *
     * @type {number}
     */
    incentiveQuantity: number;
}
/**
 * Object representing the payload for signing before validaton.
 *
 * @export
 * @interface SignerValidatorSignaturePayload
 * @typedef {SignerValidatorSignaturePayload}
 */
export interface SignerValidatorSignaturePayload {
    /**
     * The ID of the boost.
     *
     * @type {bigint}
     */
    boostId: bigint;
    /**
     * The ID of the incentive.
     *
     * @type {number}
     */
    incentiveQuantity: number;
    /**
     * The address of the claimant.
     *
     * @type {Address}
     */
    claimant: Address;
    /**
     * The claim data.
     *
     * @type {Hex}
     */
    incentiveData: Hex;
}
/**
 * A generic `viem.Log` event with support for `BoostCore` event types.
 *
 * @export
 * @typedef {SignerValidatorLog}
 * @template {ContractEventName<
 *     typeof signerValidatorAbi
 *   >} [event=ContractEventName<typeof signerValidatorAbi>]
 */
export type SignerValidatorLog<event extends ContractEventName<typeof signerValidatorAbi> = ContractEventName<typeof signerValidatorAbi>> = GenericLog<typeof signerValidatorAbi, event>;
/**
 *  A simple implementation of a Validator that verifies a given signature and checks the recovered address against a set of authorized signers
 *
 * @export
 * @class SignerValidator
 * @typedef {SignerValidator}
 * @extends {DeployableTarget<SignerValidatorPayload>}
 */
export declare class SignerValidator extends DeployableTarget<SignerValidatorPayload, typeof signerValidatorAbi> {
    /**
     * @inheritdoc
     *
     * @public
     * @readonly
     * @type {*}
     */
    readonly abi: readonly [{
        readonly type: "constructor";
        readonly inputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "AlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "CloneAlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InitializerNotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "available";
            readonly internalType: "uint8";
            readonly type: "uint8";
        }, {
            readonly name: "id";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "InvalidIncentive";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitialization";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitializationData";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "LengthMismatch";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NewOwnerIsZeroAddress";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NoHandoverRequest";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotInitializing";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "version";
            readonly internalType: "uint64";
            readonly type: "uint64";
            readonly indexed: false;
        }];
        readonly name: "Initialized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverCanceled";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverRequested";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "oldOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipTransferred";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "cancelOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "completeOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "eip712Domain";
        readonly outputs: readonly [{
            readonly name: "fields";
            readonly internalType: "bytes1";
            readonly type: "bytes1";
        }, {
            readonly name: "name";
            readonly internalType: "string";
            readonly type: "string";
        }, {
            readonly name: "version";
            readonly internalType: "string";
            readonly type: "string";
        }, {
            readonly name: "chainId";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "verifyingContract";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "salt";
            readonly internalType: "bytes32";
            readonly type: "bytes32";
        }, {
            readonly name: "extensions";
            readonly internalType: "uint256[]";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getComponentInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "boostId";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "incentiveQuantity";
            readonly internalType: "uint8";
            readonly type: "uint8";
        }, {
            readonly name: "claimant";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "incentiveData";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "hashSignerData";
        readonly outputs: readonly [{
            readonly name: "hashedSignerData";
            readonly internalType: "bytes32";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "owner";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "ownershipHandoverExpiresAt";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "renounceOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "requestOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "signers_";
            readonly internalType: "address[]";
            readonly type: "address[]";
        }, {
            readonly name: "authorized_";
            readonly internalType: "bool[]";
            readonly type: "bool[]";
        }];
        readonly name: "setAuthorized";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "newCaller";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "setValidatorCaller";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "signers";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "interfaceId";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly name: "supportsInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "transferOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "boostId";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "incentiveId";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "claimant";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "claimData";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "validate";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }];
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {Record<number, Address>}
     */
    static bases: Record<number, Address>;
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {RegistryType}
     */
    static registryType: RegistryType;
    /**
     * The set of authorized signers
     *
     * @public
     * @async
     * @param {Address} address
     * @param {?ReadParams} [params]
     * @returns {Promise<boolean>}
     */
    signers(address: Address, params?: ReadParams<typeof signerValidatorAbi, 'signers'>): Promise<boolean>;
    /**
     * Retrieve the hash and signer data for a given hash
     *
     * @public
     * @async
     * @param {SignerValidatorSignaturePayload} payload
     * @param {?ReadParams} [params]
     * @returns {Promise<Hex>}
     */
    hashSignerData(payload: SignerValidatorSignaturePayload, params?: ReadParams<typeof signerValidatorAbi, 'hashSignerData'>): Promise<`0x${string}`>;
    /**
     * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.
     *
     * @public
     * @async
     * @param {SignerValidatorValidatePayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if the action has been validated based on the data payload
     */
    protected validate(payload: SignerValidatorValidatePayload, params?: WriteParams<typeof signerValidatorAbi, 'validate'>): Promise<boolean>;
    /**
     * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.
     *
     * @public
     * @async
     * @param {SignerValidatorValidatePayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if the action has been validated based on the data payload
     */
    protected validateRaw(payload: SignerValidatorValidatePayload, params?: ReadParams<typeof signerValidatorAbi, 'validate'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Set the authorized status of a signer
     *
     * @public
     * @async
     * @param {Address[]} addresses - The list of signers to update
     * @param {boolean[]} allowed - The authorized status of each signer
     * @param {?WriteParams} [params]
     * @returns {Promise<void>}
     */
    setAuthorized(addresses: Address[], allowed: boolean[], params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>): Promise<void>;
    /**
     * Set the authorized status of a signer
     *
     * @public
     * @async
     * @param {Address[]} addresses - The list of signers to update
     * @param {boolean[]} allowed - The authorized status of each signer
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: void; }>}
     */
    setAuthorizedRaw(addresses: Address[], allowed: boolean[], params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>): Promise<{
        hash: `0x${string}`;
        result: void;
    }>;
    /**
     * Update the authorized caller of the validator function
     *
     * @public
     * @async
     * @param {Address} address
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: void; }>}
     */
    setValidatorCallerRaw(address: Address, params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>): Promise<{
        hash: `0x${string}`;
        result: void;
    }>;
    /**
     * Update the authorized caller of the validator function
     *
     * @public
     * @async
     * @param {Address} address
     * @param {?WriteParams} [params]
     * @returns {Promise<void>}
     */
    setValidatorCaller(address: Address, params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>): Promise<void>;
    /**
     * Properly encodes the data needed to claim
     *
     * @public
     * @async
     * @param {SignerValidatorClaimDataParams} params
     * @returns {Promise<Hex>}
     */
    encodeClaimData(params: Omit<SignerValidatorClaimDataParams, 'validator'>): Promise<Hex>;
    /**
     * @inheritdoc
     *
     * @public
     * @param {?SignerValidatorPayload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {GenericDeployableParams}
     */
    buildParameters(_payload?: SignerValidatorPayload, _options?: DeployableOptions): GenericDeployableParams;
}
/**
 * Signer Validator Claim Data Payload Preparation
 *
 * @export
 * @async
 * @param {SignerValidatorClaimDataParams} param0
 * @param {{ account: Address; key: Hex; privateKey: PrivateKeyAccount; }} param0.signer
 * @param {Hex} param0.incentiveData
 * @param {number} param0.chainId
 * @param {Address} param0.validator
 * @param {number} param0.incentiveQuantity
 * @param {Address} param0.claimant
 * @param {bigint} param0.boostId
 * @returns {Promise<Hex>}
 */
export declare function prepareSignerValidatorClaimDataPayload({ signer, incentiveData, chainId, validator, incentiveQuantity, claimant, boostId, }: SignerValidatorClaimDataParams): Promise<Hex>;
/**
 * Given a {@link SignerValidatorInputParams}, properly encode the initialization payload.
 *
 * @param {SignerValidatorInputParams} param0
 * @param {Address} param0.signer
 * @param {Hex} param0.signature
 * @param {number} param0.incentiveQuantity
 * @returns {Hex}
 */
export declare function prepareSignerValidatorInputParams({ signer, signature, incentiveQuantity, }: SignerValidatorInputParams): `0x${string}`;
/**
 * Given a {@link SignerValidatorPayload}, properly encode the initialization payload.
 *
 * @param {SignerValidatorPayload} param0
 * @param {Address[]} param0.signers
 * @param {Address} param0.validatorCaller
 * @returns {Hex}
 */
export declare function prepareSignerValidatorPayload({ signers, validatorCaller, }: SignerValidatorPayload): `0x${string}`;
//# sourceMappingURL=SignerValidator.d.ts.map