{"version":3,"file":"SignerValidator.js","sources":["../../src/Validators/SignerValidator.ts"],"sourcesContent":["import {\n  readSignerValidatorHashSignerData,\n  readSignerValidatorSigners,\n  signerValidatorAbi,\n  simulateSignerValidatorSetAuthorized,\n  simulateSignerValidatorSetValidatorCaller,\n  simulateSignerValidatorValidate,\n  writeSignerValidatorSetAuthorized,\n  writeSignerValidatorSetValidatorCaller,\n  writeSignerValidatorValidate,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/validators/SignerValidator.sol/SignerValidator.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  type PrivateKeyAccount,\n  encodeAbiParameters,\n} from 'viem';\nimport { signTypedData } from 'viem/accounts';\nimport { SignerValidator as SignerValidatorBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\nexport { signerValidatorAbi };\n\n/**\n * Object reprentation of a {@link SignerValidator} initialization payload\n *\n * @export\n * @interface SignerValidatorPayload\n * @typedef {SignerValidatorPayload}\n */\nexport interface SignerValidatorPayload {\n  /**\n   * The list of authorized signers. The first address in the list will be the initial owner of the contract.\n   *\n   * @type {Address[]}\n   */\n  signers: Address[];\n  /**\n   * The authorized caller of the {@link prepareSignerValidator} function\n   * @type {Address}\n   */\n  validatorCaller: Address;\n}\n\n/**\n * Description placeholder\n *\n * @export\n * @interface SignerValidatorValidatePayload\n * @typedef {SignerValidatorValidatePayload}\n */\nexport interface SignerValidatorValidatePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {bigint}\n   */\n  incentiveId: bigint;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  claimData: Hex;\n}\n\n/**\n * Object reprentation of a {@link SignerValidator} initialization payload\n *\n * @export\n * @interface SignerValidatorPayload\n * @typedef {SignerValidatorPayload}\n */\nexport interface SignerValidatorPayload {\n  /**\n   * The list of authorized signers. The first address in the list will be the initial owner of the contract.\n   *\n   * @type {Address[]}\n   */\n  signers: Address[];\n  /**\n   * The authorized caller of the {@link prepareSignerValidator} function\n   * @type {Address}\n   */\n  validatorCaller: Address;\n}\n\n/**\n * Description placeholder\n *\n * @export\n * @interface SignerValidatorValidatePayload\n * @typedef {SignerValidatorValidatePayload}\n */\nexport interface SignerValidatorValidatePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {bigint}\n   */\n  incentiveId: bigint;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  claimData: Hex;\n}\n\n/**\n * Signer Validator Claim Data Payload\n *\n * @export\n * @interface SignerValidatorClaimDataParams\n * @typedef {SignerValidatorClaimDataParams}\n */\nexport interface SignerValidatorClaimDataParams {\n  /**\n   * The signer with which to sign the input\n   *\n   * @type {{\n   *     account: Address;\n   *     key: Hex;\n   *     privateKey: PrivateKeyAccount;\n   *   }}\n   */\n  signer: {\n    account: Address;\n    key: Hex;\n    privateKey: PrivateKeyAccount;\n  };\n  /**\n   * The encoded data to provide the underlying incentive. You can use {@link prepareAllowListIncentivePayload}, {@link prepareCGDAIncentivePayload}, {@link prepareERC20IncentivePayload}, {@link prepareERC1155IncentivePayload}, or {@link preparePointsIncentivePayload}\n   *\n   * @type {Hex}\n   */\n  incentiveData: Hex;\n  /**\n   * The chain id to target\n   *\n   * @type {number}\n   */\n  chainId: number;\n  /**\n   * The address of the validator\n   *\n   * @type {Address}\n   */\n  validator: Address;\n  /**\n   * The incentive quantity.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n  /**\n   * The address of the claimant\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The ID of the boost\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n}\n\n/**\n * Object representation of a {@link SignerValidatorInputParams} initialization payload\n *\n * @export\n * @interface SignerValidatorInputParams\n * @typedef {SignerValidatorInputParams}\n */\nexport interface SignerValidatorInputParams {\n  /**\n   * The signer address.\n   *\n   * @type {Address}\n   */\n  signer: Address;\n\n  /**\n   * The signature data.\n   *\n   * @type {string}\n   */\n  signature: Hex;\n\n  /**\n   * The incentive quantity.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n}\n\n/**\n * Object representing the payload for signing before validaton.\n *\n * @export\n * @interface SignerValidatorSignaturePayload\n * @typedef {SignerValidatorSignaturePayload}\n */\nexport interface SignerValidatorSignaturePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  incentiveData: Hex;\n}\n\n/**\n * A generic `viem.Log` event with support for `BoostCore` event types.\n *\n * @export\n * @typedef {SignerValidatorLog}\n * @template {ContractEventName<\n *     typeof signerValidatorAbi\n *   >} [event=ContractEventName<typeof signerValidatorAbi>]\n */\nexport type SignerValidatorLog<\n  event extends ContractEventName<\n    typeof signerValidatorAbi\n  > = ContractEventName<typeof signerValidatorAbi>,\n> = GenericLog<typeof signerValidatorAbi, event>;\n\n/**\n *  A simple implementation of a Validator that verifies a given signature and checks the recovered address against a set of authorized signers\n *\n * @export\n * @class SignerValidator\n * @typedef {SignerValidator}\n * @extends {DeployableTarget<SignerValidatorPayload>}\n */\nexport class SignerValidator extends DeployableTarget<\n  SignerValidatorPayload,\n  typeof signerValidatorAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = signerValidatorAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(SignerValidatorBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.VALIDATOR;\n\n  /**\n   * The set of authorized signers\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public async signers(\n    address: Address,\n    params?: ReadParams<typeof signerValidatorAbi, 'signers'>,\n  ) {\n    return await readSignerValidatorSigners(this._config, {\n      address: this.assertValidAddress(),\n      args: [address],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Retrieve the hash and signer data for a given hash\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorSignaturePayload} payload\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>}\n   */\n  public async hashSignerData(\n    payload: SignerValidatorSignaturePayload,\n    params?: ReadParams<typeof signerValidatorAbi, 'hashSignerData'>,\n  ) {\n    return await readSignerValidatorHashSignerData(this._config, {\n      address: this.assertValidAddress(),\n      args: [\n        payload.boostId,\n        payload.incentiveQuantity,\n        payload.claimant,\n        payload.incentiveData,\n      ],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorValidatePayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the action has been validated based on the data payload\n   */\n  protected async validate(\n    payload: SignerValidatorValidatePayload,\n    params?: WriteParams<typeof signerValidatorAbi, 'validate'>,\n  ) {\n    return await this.awaitResult(this.validateRaw(payload, params));\n  }\n\n  /**\n   * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorValidatePayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the action has been validated based on the data payload\n   */\n  protected async validateRaw(\n    payload: SignerValidatorValidatePayload,\n    params?: ReadParams<typeof signerValidatorAbi, 'validate'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorValidate(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [\n          payload.boostId,\n          payload.incentiveId,\n          payload.claimant,\n          payload.claimData,\n        ],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorValidate(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Set the authorized status of a signer\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of signers to update\n   * @param {boolean[]} allowed - The authorized status of each signer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setAuthorized(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>,\n  ) {\n    return await this.awaitResult(\n      this.setAuthorizedRaw(addresses, allowed, params),\n    );\n  }\n\n  /**\n   * Set the authorized status of a signer\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of signers to update\n   * @param {boolean[]} allowed - The authorized status of each signer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setAuthorizedRaw(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorSetAuthorized(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [addresses, allowed],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorSetAuthorized(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Update the authorized caller of the validator function\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setValidatorCallerRaw(\n    address: Address,\n    params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorSetValidatorCaller(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [address],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorSetValidatorCaller(\n      this._config,\n      request,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Update the authorized caller of the validator function\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setValidatorCaller(\n    address: Address,\n    params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>,\n  ) {\n    return await this.awaitResult(this.setValidatorCallerRaw(address, params));\n  }\n\n  /**\n   * Properly encodes the data needed to claim\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorClaimDataParams} params\n   * @returns {Promise<Hex>}\n   */\n  public async encodeClaimData(\n    params: Omit<SignerValidatorClaimDataParams, 'validator'>,\n  ): Promise<Hex> {\n    return await prepareSignerValidatorClaimDataPayload({\n      ...params,\n      validator: this.assertValidAddress(),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?SignerValidatorPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: SignerValidatorPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: signerValidatorAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareSignerValidatorPayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Signer Validator Claim Data Payload Preparation\n *\n * @export\n * @async\n * @param {SignerValidatorClaimDataParams} param0\n * @param {{ account: Address; key: Hex; privateKey: PrivateKeyAccount; }} param0.signer\n * @param {Hex} param0.incentiveData\n * @param {number} param0.chainId\n * @param {Address} param0.validator\n * @param {number} param0.incentiveQuantity\n * @param {Address} param0.claimant\n * @param {bigint} param0.boostId\n * @returns {Promise<Hex>}\n */\nexport async function prepareSignerValidatorClaimDataPayload({\n  signer,\n  incentiveData,\n  chainId,\n  validator,\n  incentiveQuantity,\n  claimant,\n  boostId,\n}: SignerValidatorClaimDataParams): Promise<Hex> {\n  const domain = {\n    name: 'SignerValidator',\n    version: '1',\n    chainId: chainId,\n    verifyingContract: validator,\n  };\n  const typedData = {\n    domain,\n    types: {\n      SignerValidatorData: [\n        { name: 'boostId', type: 'uint256' },\n        { name: 'incentiveQuantity', type: 'uint8' },\n        { name: 'claimant', type: 'address' },\n        { name: 'incentiveData', type: 'bytes' },\n      ],\n    },\n    primaryType: 'SignerValidatorData' as const,\n    message: {\n      boostId,\n      incentiveQuantity,\n      claimant,\n      incentiveData: incentiveData,\n    },\n  };\n\n  const trustedSignature = await signTypedData({\n    ...typedData,\n    privateKey: signer.key,\n  });\n\n  // Prepare the claim data payload using the new helper\n  const validatorData = prepareSignerValidatorInputParams({\n    signer: signer.account,\n    signature: trustedSignature,\n    incentiveQuantity, // Adjust incentive quantity as necessary\n  });\n\n  const boostClaimDataPayload = encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'BoostClaimData',\n        components: [\n          { type: 'bytes', name: 'validatorData' },\n          { type: 'bytes', name: 'incentiveData' },\n        ],\n      },\n    ],\n    [{ validatorData, incentiveData }],\n  );\n\n  return boostClaimDataPayload;\n}\n\n/**\n * Given a {@link SignerValidatorInputParams}, properly encode the initialization payload.\n *\n * @param {SignerValidatorInputParams} param0\n * @param {Address} param0.signer\n * @param {Hex} param0.signature\n * @param {number} param0.incentiveQuantity\n * @returns {Hex}\n */\nexport function prepareSignerValidatorInputParams({\n  signer,\n  signature,\n  incentiveQuantity,\n}: SignerValidatorInputParams) {\n  return encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'SignerValidatorInputParams',\n        components: [\n          { type: 'address', name: 'signer' },\n          { type: 'bytes', name: 'signature' },\n          { type: 'uint8', name: 'incentiveQuantity' },\n        ],\n      },\n    ],\n    [{ signer, signature, incentiveQuantity }],\n  );\n}\n\n/**\n * Given a {@link SignerValidatorPayload}, properly encode the initialization payload.\n *\n * @param {SignerValidatorPayload} param0\n * @param {Address[]} param0.signers\n * @param {Address} param0.validatorCaller\n * @returns {Hex}\n */\nexport function prepareSignerValidatorPayload({\n  signers,\n  validatorCaller,\n}: SignerValidatorPayload) {\n  return encodeAbiParameters(\n    [\n      { type: 'address[]', name: 'signers' },\n      { type: 'address', name: 'validatorCaller' },\n    ],\n    [signers, validatorCaller],\n  );\n}\n"],"names":["_SignerValidator","DeployableTarget","signerValidatorAbi","address","params","readSignerValidatorSigners","payload","readSignerValidatorHashSignerData","request","result","simulateSignerValidatorValidate","writeSignerValidatorValidate","addresses","allowed","simulateSignerValidatorSetAuthorized","writeSignerValidatorSetAuthorized","simulateSignerValidatorSetValidatorCaller","writeSignerValidatorSetValidatorCaller","prepareSignerValidatorClaimDataPayload","_payload","_options","options","bytecode","prepareSignerValidatorPayload","SignerValidatorBases","RegistryType","SignerValidator","signer","incentiveData","chainId","validator","incentiveQuantity","claimant","boostId","trustedSignature","signTypedData","validatorData","prepareSignerValidatorInputParams","encodeAbiParameters","signature","signers","validatorCaller"],"mappings":";;;;;;kshBAoSaA,IAAN,MAAMA,UAAwBC,EAGnC;AAAA,EAHK,cAAA;AAAA,UAAA,GAAA,SAAA,GAWL,KAAyB,MAAMC;AAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6B/B,MAAa,QACXC,GACAC,GACA;AACO,WAAA,MAAMC,EAA2B,KAAK,SAAS;AAAA,MACpD,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAM,CAACF,CAAO;AAAA;AAAA,MAEd,GAAIC;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,eACXE,GACAF,GACA;AACO,WAAA,MAAMG,EAAkC,KAAK,SAAS;AAAA,MAC3D,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAM;AAAA,QACJD,EAAQ;AAAA,QACRA,EAAQ;AAAA,QACRA,EAAQ;AAAA,QACRA,EAAQ;AAAA,MACV;AAAA;AAAA,MAEA,GAAIF;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAgB,SACdE,GACAF,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,YAAYE,GAASF,CAAM,CAAC;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAgB,YACdE,GACAF,GACA;AACA,UAAM,EAAE,SAAAI,GAAS,QAAAC,EAAO,IAAI,MAAMC;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM;AAAA,UACJJ,EAAQ;AAAA,UACRA,EAAQ;AAAA,UACRA,EAAQ;AAAA,UACRA,EAAQ;AAAA,QACV;AAAA,QACA,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIF;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMO,EAA6B,KAAK,SAASH,CAAO,GACtD,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAa,cACXG,GACAC,GACAT,GACA;AACA,WAAO,MAAM,KAAK;AAAA,MAChB,KAAK,iBAAiBQ,GAAWC,GAAST,CAAM;AAAA,IAAA;AAAA,EAEpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAa,iBACXQ,GACAC,GACAT,GACA;AACA,UAAM,EAAE,SAAAI,GAAS,QAAAC,EAAO,IAAI,MAAMK;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACF,GAAWC,CAAO;AAAA,QACzB,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIT;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMW,EAAkC,KAAK,SAASP,CAAO,GAC3D,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,sBACXN,GACAC,GACA;AACA,UAAM,EAAE,SAAAI,GAAS,QAAAC,EAAO,IAAI,MAAMO;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACb,CAAO;AAAA,QACd,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIC;AAAA,MACN;AAAA,IAAA;AAMK,WAAA,EAAE,MAJI,MAAMa;AAAAA,MACjB,KAAK;AAAA,MACLT;AAAA,IAAA,GAEa,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,mBACXN,GACAC,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,sBAAsBD,GAASC,CAAM,CAAC;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,gBACXA,GACc;AACd,WAAO,MAAMc,EAAuC;AAAA,MAClD,GAAGd;AAAA,MACH,WAAW,KAAK,mBAAmB;AAAA,IAAA,CACpC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUgB,gBACde,GACAC,GACyB;AACzB,UAAM,CAACd,GAASe,CAAO,IAAI,KAAK;AAAA,MAC9BF;AAAA,MACAC;AAAA,IAAA;AAEK,WAAA;AAAA,MACL,KAAKlB;AAAAA,MACL,UAAAoB;AAAA,MACA,MAAM,CAACC,EAA8BjB,CAAO,CAAC;AAAA,MAC7C,GAAG,KAAK,wBAAwBe,EAAQ,OAAO;AAAA,IAAA;AAAA,EAEnD;AACF;AAlPErB,EAAuB,QAAiC;AAAA,EACtD,GAAIwB;AAAA,GASNxB,EAAuB,eAA6ByB,EAAa;AA7B5D,IAAMC,IAAN1B;AAsRP,eAAsBkB,EAAuC;AAAA,EAC3D,QAAAS;AAAA,EACA,eAAAC;AAAA,EACA,SAAAC;AAAA,EACA,WAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,UAAAC;AAAA,EACA,SAAAC;AACF,GAAiD;AA0BzC,QAAAC,IAAmB,MAAMC,EAAc;AAAA,IAC3C,GApBgB;AAAA,MAChB,QAPa;AAAA,QACb,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SAAAN;AAAA,QACA,mBAAmBC;AAAA,MAAA;AAAA,MAInB,OAAO;AAAA,QACL,qBAAqB;AAAA,UACnB,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,UACnC,EAAE,MAAM,qBAAqB,MAAM,QAAQ;AAAA,UAC3C,EAAE,MAAM,YAAY,MAAM,UAAU;AAAA,UACpC,EAAE,MAAM,iBAAiB,MAAM,QAAQ;AAAA,QACzC;AAAA,MACF;AAAA,MACA,aAAa;AAAA,MACb,SAAS;AAAA,QACP,SAAAG;AAAA,QACA,mBAAAF;AAAA,QACA,UAAAC;AAAA,QACA,eAAAJ;AAAA,MACF;AAAA,IAAA;AAAA,IAKA,YAAYD,EAAO;AAAA,EAAA,CACpB,GAGKS,IAAgBC,EAAkC;AAAA,IACtD,QAAQV,EAAO;AAAA,IACf,WAAWO;AAAA,IACX,mBAAAH;AAAA;AAAA,EAAA,CACD;AAgBM,SAduBO;AAAA,IAC5B;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,QACN,YAAY;AAAA,UACV,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,UACvC,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AAAA,IACA,CAAC,EAAE,eAAAF,GAAe,eAAAR,GAAe;AAAA,EAAA;AAIrC;AAWO,SAASS,EAAkC;AAAA,EAChD,QAAAV;AAAA,EACA,WAAAY;AAAA,EACA,mBAAAR;AACF,GAA+B;AACtB,SAAAO;AAAA,IACL;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,QACN,YAAY;AAAA,UACV,EAAE,MAAM,WAAW,MAAM,SAAS;AAAA,UAClC,EAAE,MAAM,SAAS,MAAM,YAAY;AAAA,UACnC,EAAE,MAAM,SAAS,MAAM,oBAAoB;AAAA,QAC7C;AAAA,MACF;AAAA,IACF;AAAA,IACA,CAAC,EAAE,QAAAX,GAAQ,WAAAY,GAAW,mBAAAR,GAAmB;AAAA,EAAA;AAE7C;AAUO,SAASR,EAA8B;AAAA,EAC5C,SAAAiB;AAAA,EACA,iBAAAC;AACF,GAA2B;AAClB,SAAAH;AAAA,IACL;AAAA,MACE,EAAE,MAAM,aAAa,MAAM,UAAU;AAAA,MACrC,EAAE,MAAM,WAAW,MAAM,kBAAkB;AAAA,IAC7C;AAAA,IACA,CAACE,GAASC,CAAe;AAAA,EAAA;AAE7B;"}