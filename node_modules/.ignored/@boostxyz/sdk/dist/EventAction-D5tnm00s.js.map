{"version":3,"file":"EventAction-D5tnm00s.js","sources":["../../../node_modules/.pnpm/ts-pattern@5.4.0/node_modules/ts-pattern/dist/index.js","../src/Actions/EventAction.ts"],"sourcesContent":["const t=Symbol.for(\"@ts-pattern/matcher\"),e=Symbol.for(\"@ts-pattern/isVariadic\"),n=\"@ts-pattern/anonymous-select-key\",r=t=>Boolean(t&&\"object\"==typeof t),i=e=>e&&!!e[t],s=(n,o,c)=>{if(i(n)){const e=n[t](),{matched:r,selections:i}=e.match(o);return r&&i&&Object.keys(i).forEach(t=>c(t,i[t])),r}if(r(n)){if(!r(o))return!1;if(Array.isArray(n)){if(!Array.isArray(o))return!1;let t=[],r=[],a=[];for(const s of n.keys()){const o=n[s];i(o)&&o[e]?a.push(o):a.length?r.push(o):t.push(o)}if(a.length){if(a.length>1)throw new Error(\"Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.\");if(o.length<t.length+r.length)return!1;const e=o.slice(0,t.length),n=0===r.length?[]:o.slice(-r.length),i=o.slice(t.length,0===r.length?Infinity:-r.length);return t.every((t,n)=>s(t,e[n],c))&&r.every((t,e)=>s(t,n[e],c))&&(0===a.length||s(a[0],i,c))}return n.length===o.length&&n.every((t,e)=>s(t,o[e],c))}return Reflect.ownKeys(n).every(e=>{const r=n[e];return(e in o||i(a=r)&&\"optional\"===a[t]().matcherType)&&s(r,o[e],c);var a})}return Object.is(o,n)},o=e=>{var n,s,a;return r(e)?i(e)?null!=(n=null==(s=(a=e[t]()).getSelectionKeys)?void 0:s.call(a))?n:[]:Array.isArray(e)?c(e,o):c(Object.values(e),o):[]},c=(t,e)=>t.reduce((t,n)=>t.concat(e(n)),[]);function a(...t){if(1===t.length){const[e]=t;return t=>s(e,t,()=>{})}if(2===t.length){const[e,n]=t;return s(e,n,()=>{})}throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${t.length}.`)}function u(t){return Object.assign(t,{optional:()=>h(t),and:e=>m(t,e),or:e=>d(t,e),select:e=>void 0===e?y(t):y(e,t)})}function l(t){return Object.assign((t=>Object.assign(t,{[Symbol.iterator](){let n=0;const r=[{value:Object.assign(t,{[e]:!0}),done:!1},{done:!0,value:void 0}];return{next:()=>{var t;return null!=(t=r[n++])?t:r.at(-1)}}}}))(t),{optional:()=>l(h(t)),select:e=>l(void 0===e?y(t):y(e,t))})}function h(e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return void 0===t?(o(e).forEach(t=>r(t,void 0)),{matched:!0,selections:n}):{matched:s(e,t,r),selections:n}},getSelectionKeys:()=>o(e),matcherType:\"optional\"})})}const f=(t,e)=>{for(const n of t)if(!e(n))return!1;return!0},g=(t,e)=>{for(const[n,r]of t.entries())if(!e(r,n))return!1;return!0};function m(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return{matched:e.every(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:\"and\"})})}function d(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return c(e,o).forEach(t=>r(t,void 0)),{matched:e.some(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:\"or\"})})}function p(e){return{[t]:()=>({match:t=>({matched:Boolean(e(t))})})}}function y(...e){const r=\"string\"==typeof e[0]?e[0]:void 0,i=2===e.length?e[1]:\"string\"==typeof e[0]?void 0:e[0];return u({[t]:()=>({match:t=>{let e={[null!=r?r:n]:t};return{matched:void 0===i||s(i,t,(t,n)=>{e[t]=n}),selections:e}},getSelectionKeys:()=>[null!=r?r:n].concat(void 0===i?[]:o(i))})})}function v(t){return\"number\"==typeof t}function b(t){return\"string\"==typeof t}function w(t){return\"bigint\"==typeof t}const S=u(p(function(t){return!0})),O=S,j=t=>Object.assign(u(t),{startsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.startsWith(n)))));var n},endsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.endsWith(n)))));var n},minLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length>=t))(e))),length:e=>j(m(t,(t=>p(e=>b(e)&&e.length===t))(e))),maxLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length<=t))(e))),includes:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.includes(n)))));var n},regex:e=>{return j(m(t,(n=e,p(t=>b(t)&&Boolean(t.match(n))))));var n}}),K=j(p(b)),x=t=>Object.assign(u(t),{between:(e,n)=>x(m(t,((t,e)=>p(n=>v(n)&&t<=n&&e>=n))(e,n))),lt:e=>x(m(t,(t=>p(e=>v(e)&&e<t))(e))),gt:e=>x(m(t,(t=>p(e=>v(e)&&e>t))(e))),lte:e=>x(m(t,(t=>p(e=>v(e)&&e<=t))(e))),gte:e=>x(m(t,(t=>p(e=>v(e)&&e>=t))(e))),int:()=>x(m(t,p(t=>v(t)&&Number.isInteger(t)))),finite:()=>x(m(t,p(t=>v(t)&&Number.isFinite(t)))),positive:()=>x(m(t,p(t=>v(t)&&t>0))),negative:()=>x(m(t,p(t=>v(t)&&t<0)))}),E=x(p(v)),A=t=>Object.assign(u(t),{between:(e,n)=>A(m(t,((t,e)=>p(n=>w(n)&&t<=n&&e>=n))(e,n))),lt:e=>A(m(t,(t=>p(e=>w(e)&&e<t))(e))),gt:e=>A(m(t,(t=>p(e=>w(e)&&e>t))(e))),lte:e=>A(m(t,(t=>p(e=>w(e)&&e<=t))(e))),gte:e=>A(m(t,(t=>p(e=>w(e)&&e>=t))(e))),positive:()=>A(m(t,p(t=>w(t)&&t>0))),negative:()=>A(m(t,p(t=>w(t)&&t<0)))}),P=A(p(w)),T=u(p(function(t){return\"boolean\"==typeof t})),B=u(p(function(t){return\"symbol\"==typeof t})),_=u(p(function(t){return null==t})),k=u(p(function(t){return null!=t}));var N={__proto__:null,matcher:t,optional:h,array:function(...e){return l({[t]:()=>({match:t=>{if(!Array.isArray(t))return{matched:!1};if(0===e.length)return{matched:!0};const n=e[0];let r={};if(0===t.length)return o(n).forEach(t=>{r[t]=[]}),{matched:!0,selections:r};const i=(t,e)=>{r[t]=(r[t]||[]).concat([e])};return{matched:t.every(t=>s(n,t,i)),selections:r}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},set:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Set))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};if(0===e.length)return{matched:!0};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])},i=e[0];return{matched:f(t,t=>s(i,t,r)),selections:n}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},map:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Map))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])};if(0===e.length)return{matched:!0};var i;if(1===e.length)throw new Error(`\\`P.map\\` wasn't given enough arguments. Expected (key, value), received ${null==(i=e[0])?void 0:i.toString()}`);const[o,c]=e;return{matched:g(t,(t,e)=>{const n=s(o,e,r),i=s(c,t,r);return n&&i}),selections:n}},getSelectionKeys:()=>0===e.length?[]:[...o(e[0]),...o(e[1])]})})},intersection:m,union:d,not:function(e){return u({[t]:()=>({match:t=>({matched:!s(e,t,()=>{})}),getSelectionKeys:()=>[],matcherType:\"not\"})})},when:p,select:y,any:S,_:O,string:K,number:E,bigint:P,boolean:T,symbol:B,nullish:_,nonNullable:k,instanceOf:function(t){return u(p(function(t){return e=>e instanceof t}(t)))},shape:function(t){return u(p(a(t)))}};class W extends Error{constructor(t){let e;try{e=JSON.stringify(t)}catch(n){e=t}super(`Pattern matching error: no pattern matches value ${e}`),this.input=void 0,this.input=t}}const $={matched:!1,value:void 0};function z(t){return new I(t,$)}class I{constructor(t,e){this.input=void 0,this.state=void 0,this.input=t,this.state=e}with(...t){if(this.state.matched)return this;const e=t[t.length-1],r=[t[0]];let i;3===t.length&&\"function\"==typeof t[1]?i=t[1]:t.length>2&&r.push(...t.slice(1,t.length-1));let o=!1,c={};const a=(t,e)=>{o=!0,c[t]=e},u=!r.some(t=>s(t,this.input,a))||i&&!Boolean(i(this.input))?$:{matched:!0,value:e(o?n in c?c[n]:c:this.input,this.input)};return new I(this.input,u)}when(t,e){if(this.state.matched)return this;const n=Boolean(t(this.input));return new I(this.input,n?{matched:!0,value:e(this.input,this.input)}:$)}otherwise(t){return this.state.matched?this.state.value:t(this.input)}exhaustive(){if(this.state.matched)return this.state.value;throw new W(this.input)}run(){return this.exhaustive()}returnType(){return this}}export{W as NonExhaustiveError,N as P,N as Pattern,a as isMatching,z as match};\n//# sourceMappingURL=index.js.map\n","import {\n  eventActionAbi,\n  readEventActionGetActionClaimant,\n  readEventActionGetActionSteps,\n  simulateEventActionExecute,\n  writeEventActionExecute,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/actions/EventAction.sol/EventAction.json';\nimport events from '@boostxyz/signatures/events';\nimport functions from '@boostxyz/signatures/functions';\nimport { match } from 'ts-pattern';\nimport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  type Address,\n  type ContractEventName,\n  type ContractFunctionName,\n  type GetLogsReturnType,\n  type GetTransactionParameters,\n  type Hex,\n  type Log,\n  type PublicClient,\n  type Transaction,\n  decodeEventLog,\n  decodeFunctionData,\n  encodeAbiParameters,\n  fromHex,\n  isAddressEqual,\n} from 'viem';\nimport { EventAction as EventActionBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport {\n  DecodedArgsMalformedError,\n  FieldValueNotComparableError,\n  FieldValueUndefinedError,\n  FunctionDataDecodeError,\n  InvalidNumericalCriteriaError,\n  NoEventActionStepsProvidedError,\n  TooManyEventActionStepsProvidedError,\n  UnparseableAbiParamError,\n  UnrecognizedFilterTypeError,\n  ValidationAbiMissingError,\n  ValidationLogsMissingError,\n} from '../errors';\nimport {\n  type GetLogsParams,\n  type Overwrite,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\n/*\n * Action Event Payloads\n */\n\n/**\n * Filter types used to determine how criteria are evaluated.\n *\n * @export\n * @enum {number}\n */\nexport enum FilterType {\n  EQUAL = 0,\n  NOT_EQUAL = 1,\n  GREATER_THAN = 2,\n  LESS_THAN = 3,\n  CONTAINS = 4,\n  REGEX = 5,\n}\n\n/**\n * The primitive types supported for filtering.\n *\n * @export\n * @enum {number}\n */\nexport enum PrimitiveType {\n  UINT = 0,\n  ADDRESS = 1,\n  BYTES = 2,\n  STRING = 3,\n}\n\n/**\n * Object representation of a `Criteria` struct used in event actions.\n *\n * @export\n * @interface Criteria\n * @typedef {Criteria}\n */\nexport interface Criteria {\n  /**\n   * The filter type used in this criteria.\n   *\n   * @type {FilterType}\n   */\n  filterType: FilterType;\n  /**\n   * The primitive type of the field being filtered.\n   *\n   * @type {PrimitiveType}\n   */\n  fieldType: PrimitiveType;\n  /**\n   * The index in the logs argument array where the field is located.\n   *\n   * @type {number}\n   */\n  fieldIndex: number;\n  /**\n   * The filter data used for complex filtering.\n   *\n   * @type {Hex}\n   */\n  filterData: Hex;\n}\n\n/**\n * Whether a given signature is an event or function\n *\n * @export\n * @enum {number}\n */\nexport enum SignatureType {\n  EVENT = 0,\n  FUNC = 1,\n}\n\n/**\n *  The payload describing how claimants are identified\n *\n * @export\n * @interface ActionClaimant\n * @typedef {ActionClaimant}\n */\nexport interface ActionClaimant {\n  /**\n   * Whether claimaint is inferred from event or function\n   *\n   * @type {SignatureType}\n   */\n  signatureType: SignatureType;\n  /**\n   * The 4 byte signature of the event or function\n   *\n   * @type {Hex}\n   */\n  signature: Hex;\n  /**\n   * The index corresponding to claimant.\n   *\n   * @type {number}\n   */\n  fieldIndex: number;\n  /**\n   * The address of the target contract\n   *\n   * @type {Address}\n   */\n  targetContract: Address;\n  /**\n   * The chain id of the target contract.\n   * @type {number}\n   */\n  chainid: number;\n}\n\n/**\n * Object representation of an `ActionStep` struct used in event actions.\n *\n * @export\n * @interface ActionStep\n * @typedef {ActionStep}\n */\nexport interface ActionStep {\n  /**\n   * The signature of the event.\n   *\n   * @type {Hex}\n   */\n  signature: Hex;\n  /**\n   * Whether claimaint is inferred from event or function\n   *\n   * @type {SignatureType}\n   */\n  signatureType: SignatureType;\n  /**\n   * The type of action being performed.\n   *\n   * @type {number}\n   */\n  actionType?: number;\n  /**\n   * The address of the target contract.\n   *\n   * @type {Address}\n   */\n  targetContract: Address;\n  /**\n   * The chain id of the target contract.\n   * @type {number}\n   */\n  chainid: number;\n  /**\n   * The criteria used for this action step.\n   *\n   * @type {Criteria}\n   */\n  actionParameter: Criteria;\n}\n\n/**\n * Parameters for validating an action step.\n *\n * @typedef {Object} ValidateActionStepParams\n * @property {Record<Hex, AbiEvent>} [knownEvents] - Optional record of known events, keyed by their hex signature.\n * @property {AbiEvent} [event] - Optional ABI event definition.\n * @property {EventLogs} [logs] - Event logs to validate against. Required if 'hash' is not provided.\n * @property {Hex} [hash] - Transaction hash to validate against. Required if 'logs' is not provided.\n * @property {number} [chainId] - Chain ID for the transaction. Required if 'hash' is provided.\n */\nexport type ValidateActionStepParams = {\n  knownEvents?: Record<Hex, AbiEvent>;\n  event?: AbiEvent;\n} & ({ logs: EventLogs } | { hash: Hex; chainId: number });\n\n/**\n * You can either supply a simplified version of the payload, or one that explicitly declares action steps.\n *\n * @export\n * @typedef {EventActionPayload}\n */\nexport type EventActionPayload =\n  | EventActionPayloadSimple\n  | EventActionPayloadRaw;\n\nexport interface EventActionPayloadSimple {\n  /**\n   *  The payload describing how claimants are identified\n   *\n   * @type {ActionClaimant}\n   */\n  actionClaimant: ActionClaimant;\n\n  /**\n   * Up to 4 action steps.\n   * If you supply less than 4, then the last step will be reused to satisfy the EventAction.InitPayload\n   * Any more than 4 will throw an error.\n   *\n   * @type {ActionStep[]}\n   */\n  actionSteps: ActionStep[];\n}\n\nexport type ActionStepTuple = [ActionStep, ActionStep, ActionStep, ActionStep];\n\n/**\n * Typeguard to determine if a user is supplying a simple or raw EventActionPayload\n *\n * @param {*} opts\n * @returns {opts is EventActionPayloadSimple}\n */\nexport function isEventActionPayloadSimple(\n  opts: EventActionPayload,\n): opts is EventActionPayloadSimple {\n  return Array.isArray((opts as EventActionPayloadSimple).actionSteps);\n}\n\n/**\n * Object representation of an `InitPayload` struct used to initialize event actions.\n *\n * @export\n * @interface EventActionPayloadRaw\n * @typedef {EventActionPayloadRaw}\n */\nexport interface EventActionPayloadRaw {\n  /**\n   *  The payload describing how claimants are identified\n   *\n   * @type {ActionClaimant}\n   */\n  actionClaimant: ActionClaimant;\n  /**\n   * The first action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepOne: ActionStep;\n  /**\n   * The second action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepTwo: ActionStep;\n  /**\n   * The third action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepThree: ActionStep;\n  /**\n   * The fourth action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepFour: ActionStep;\n}\n\n/**\n * Array of event logs to pass into TxParams\n * @export\n * @typedef {EventLogs}\n */\nexport type EventLogs = GetLogsReturnType<AbiEvent, AbiEvent[], true>;\n\n/**\n * Getter params from the event action contract\n *\n * @export\n * @typedef {ReadEventActionParams}\n * @param {fnName} fnName - The getter function name\n */\nexport type ReadEventActionParams<\n  fnName extends ContractFunctionName<typeof eventActionAbi, 'pure' | 'view'>,\n> = ReadParams<typeof eventActionAbi, fnName>;\n\n/**\n * A generic event action\n *\n * @export\n * @class EventAction\n * @typedef {EventAction}\n * @extends {DeployableTarget<EventActionPayload>}\n */\nexport class EventAction extends DeployableTarget<\n  EventActionPayload,\n  typeof eventActionAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = eventActionAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(EventActionBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.ACTION;\n\n  /**\n   * Gets a specific action event by index\n   *\n   * @public\n   * @async\n   * @param {number} index The index of the action event to retrieve\n   * @param {?ReadEventActionParams<'getActionStep'>} [params]\n   * @returns {Promise<ActionStep>}\n   */\n  public async getActionStep(\n    index: number,\n    params?: ReadEventActionParams<'getActionStep'>,\n  ) {\n    const steps = await this.getActionSteps(params);\n    return steps.at(index);\n  }\n\n  /**\n   * Gets all action events\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionSteps'>} [params]\n   * @returns {Promise<ActionStep[]>}\n   */\n  public async getActionSteps(\n    params?: ReadEventActionParams<'getActionSteps'>,\n  ) {\n    const steps = (await readEventActionGetActionSteps(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    })) as RawActionStep[];\n    return _dedupeActionSteps(steps.map(_fromRawActionStep));\n  }\n\n  /**\n   * Gets the count of action events\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionStepsCount'>} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async getActionStepsCount(\n    params?: ReadEventActionParams<'getActionStepsCount'>,\n  ) {\n    const steps = await this.getActionSteps(params);\n    return steps.length;\n  }\n\n  /**\n   * Retrieves the payload describing how claimants can be identified from logs or function calls.\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionClaimant'>} [params]\n   * @returns {Promise<ActionClaimant>}\n   */\n  public async getActionClaimant(\n    params?: ReadEventActionParams<'getActionClaimant'>,\n  ) {\n    const result = (await readEventActionGetActionClaimant(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      ...params,\n    })) as RawActionClaimant;\n    return _fromRawActionStep(result);\n  }\n\n  /**\n   * Executes a prepared event action\n   *\n   * @public\n   * @async\n   * @param {Hex} data\n   * @param {?WriteParams} [params]\n   * @returns {Promise<readonly [boolean, `0x${string}`]>}\n   */\n  public async execute(\n    data: Hex,\n    params?: WriteParams<typeof eventActionAbi, 'execute'>,\n  ) {\n    return await this.awaitResult(this.executeRaw(data, params));\n  }\n\n  /**\n   * Executes a prepared event action\n   *\n   * @public\n   * @async\n   * @param {Hex} data\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: readonly [boolean, `0x${string}`]; }>}\n   */\n  public async executeRaw(\n    data: Hex,\n    params?: WriteParams<typeof eventActionAbi, 'execute'>,\n  ) {\n    const { request, result } = await simulateEventActionExecute(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [data],\n    });\n    const hash = await writeEventActionExecute(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Retrieves action steps, and uses them to validate against, and optionally fetch logs that match the step's signature.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of fetched with the configured client.\n   *\n   * @public\n   * @async\n   * @param ValidateActionStepParams params\n   * @returns {Promise<boolean>}\n   */\n  public async validateActionSteps(params: ValidateActionStepParams) {\n    const actionSteps = await this.getActionSteps();\n    for (const actionStep of actionSteps) {\n      if (!(await this.isActionStepValid(actionStep, params))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Validates a single action step with a given criteria against logs or function calls.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.\n   * For functions a hash is required.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step to validate. Can be a function of event step.\n   * @param {ValidateActionStepParams} params - Additional parameters for validation, including hash, known events, logs, and chain ID.\n   * @returns {Promise<boolean>}\n   */\n  public async isActionStepValid(\n    actionStep: ActionStep,\n    params: ValidateActionStepParams,\n  ) {\n    if (actionStep.signatureType === SignatureType.EVENT) {\n      const signature = actionStep.signature;\n      let event: AbiEvent;\n      // Lookup ABI based on event signature\n      if (params.knownEvents) {\n        event = params.knownEvents?.[signature] as AbiEvent;\n      } else {\n        event = (events.abi as Record<Hex, AbiEvent>)[signature] as AbiEvent;\n      }\n\n      if (!event) {\n        throw new ValidationAbiMissingError(signature);\n      }\n\n      if (this.isArraylikeIndexed(actionStep, event)) {\n        // If the field is indexed, we can't filter on it\n        throw new UnparseableAbiParamError(\n          actionStep.actionParameter.fieldIndex,\n          event,\n        );\n      }\n\n      params.event = event;\n\n      // Use the provided logs, no need to fetch receipt\n      if ('logs' in params) {\n        return this.isActionEventValid(actionStep, {\n          ...params,\n        });\n      }\n\n      const client = this._config.getClient({\n        chainId: params.chainId,\n      }) as PublicClient;\n      const receipt = await client.getTransactionReceipt({\n        hash: params.hash,\n      });\n      const decodedLogs = receipt.logs.map((log) => {\n        const { eventName, args } = decodeEventLog({\n          abi: [event],\n          data: log.data,\n          topics: log.topics,\n        });\n\n        return { ...log, eventName, args };\n      });\n\n      return this.isActionEventValid(actionStep, {\n        logs: decodedLogs,\n        ...params,\n      });\n    }\n    if (actionStep.signatureType === SignatureType.FUNC) {\n      if ('hash' in params && 'chainId' in params) {\n        const client = this._config.getClient({\n          chainId: params.chainId,\n        }) as PublicClient;\n        const transaction = await client.getTransaction({\n          hash: params.hash,\n        });\n        return this.isActionFunctionValid(actionStep, transaction);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Validates a single action event with a given criteria against logs.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step containing the event to validate.\n   * @param {ValidateActionStepParams} params - Additional parameters for validation, including known events and logs\n   * @returns {Promise<boolean>} Resolves to true if the action event is valid, throws if input is invalid, otherwise false.\n   */\n  public isActionEventValid(\n    actionStep: ActionStep,\n    params: ValidateActionStepParams,\n  ) {\n    if (!('logs' in params)) {\n      throw new ValidationLogsMissingError();\n    }\n    const criteria = actionStep.actionParameter;\n    const logs = params.logs;\n    if (!logs.length) return false;\n    for (let log of logs) {\n      if (this.validateLogAgainstCriteria(criteria, log)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Validates a single action function with a given criteria against the transaction input.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step containing the function to validate.\n   * @param {Transaction} transaction - The transaction that will be validated against.\n   * @returns {Promise<boolean>} Resolves to true if the action function is valid, throws if the inputs are invalid, otherwise false.\n   */\n  public isActionFunctionValid(\n    actionStep: ActionStep,\n    transaction: Transaction,\n  ) {\n    const criteria = actionStep.actionParameter;\n    let signature = actionStep.signature;\n\n    const func = (functions.abi as Record<Hex, AbiFunction>)[\n      signature\n    ] as AbiFunction;\n    if (!func) {\n      throw new ValidationAbiMissingError(signature);\n    }\n\n    let decodedData;\n    try {\n      decodedData = decodeFunctionData({\n        abi: [func],\n        data: transaction.input,\n      });\n    } catch (e) {\n      throw new FunctionDataDecodeError([func], e as Error);\n    }\n\n    // Validate the criteria against decoded arguments using fieldIndex\n    const decodedArgs = decodedData.args;\n\n    if (!decodedArgs || !decodedData) return false;\n\n    if (\n      !this.validateFunctionAgainstCriteria(\n        criteria,\n        decodedArgs as (string | bigint)[],\n      )\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Validates a field against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {string | bigint | Hex} fieldValue - The field value to validate.\n   * @param {Object} input - Additional context for validation.\n   * @param {EventLogs[0]} [input.log] - The event log, if validating an event.\n   * @param {readonly (string | bigint)[]} [input.decodedArgs] - The decoded function arguments, if validating a function call.\n   * @returns {Promise<boolean>} - Returns true if the field passes the criteria, false otherwise.\n   */\n  public validateFieldAgainstCriteria(\n    criteria: Criteria,\n    fieldValue: string | bigint | Hex,\n    input:\n      | { log: EventLogs[0] }\n      | { decodedArgs: readonly (string | bigint)[] },\n  ): boolean {\n    // Type narrow based on criteria.filterType\n    switch (criteria.filterType) {\n      case FilterType.EQUAL:\n        return match(criteria.fieldType)\n          .with(PrimitiveType.ADDRESS, () =>\n            isAddressEqual(criteria.filterData, fieldValue as Address),\n          )\n          .with(\n            PrimitiveType.UINT,\n            () => BigInt(fieldValue) === BigInt(criteria.filterData),\n          )\n          .with(\n            PrimitiveType.STRING,\n            () => fieldValue === fromHex(criteria.filterData, 'string'),\n          )\n          .otherwise(() => fieldValue === criteria.filterData);\n\n      case FilterType.NOT_EQUAL:\n        return match(criteria.fieldType)\n          .with(\n            PrimitiveType.ADDRESS,\n            () => !isAddressEqual(criteria.filterData, fieldValue as Address),\n          )\n          .with(\n            PrimitiveType.UINT,\n            () => BigInt(fieldValue) !== BigInt(criteria.filterData),\n          )\n          .with(\n            PrimitiveType.STRING,\n            () => fieldValue !== fromHex(criteria.filterData, 'string'),\n          )\n          .otherwise(() => fieldValue !== criteria.filterData);\n\n      case FilterType.GREATER_THAN:\n        if (criteria.fieldType === PrimitiveType.UINT) {\n          return BigInt(fieldValue) > BigInt(criteria.filterData);\n        }\n        throw new InvalidNumericalCriteriaError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.LESS_THAN:\n        if (criteria.fieldType === PrimitiveType.UINT) {\n          return BigInt(fieldValue) < BigInt(criteria.filterData);\n        }\n        throw new InvalidNumericalCriteriaError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.CONTAINS:\n        if (\n          criteria.fieldType === PrimitiveType.BYTES ||\n          criteria.fieldType === PrimitiveType.STRING\n        ) {\n          let substring;\n          if (criteria.fieldType === PrimitiveType.STRING) {\n            substring = fromHex(criteria.filterData, 'string');\n          } else {\n            // truncate the `0x` prefix\n            substring = criteria.filterData.slice(2);\n          }\n          return (fieldValue as string).includes(substring);\n        }\n        throw new FieldValueNotComparableError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.REGEX:\n        if (typeof fieldValue !== 'string') {\n          throw new FieldValueNotComparableError({\n            ...input,\n            criteria,\n            fieldValue,\n          });\n        }\n\n        if (criteria.fieldType === PrimitiveType.STRING) {\n          // fieldValue is decoded by the ABI\n          const regexString = fromHex(criteria.filterData, 'string');\n          return new RegExp(regexString).test(fieldValue);\n        }\n\n      default:\n        throw new UnrecognizedFilterTypeError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n    }\n  }\n\n  /**\n   * Validates a {@link Log} against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {Log} log - The Viem event log.\n   * @returns {Promise<boolean>} - Returns true if the log passes the criteria, false otherwise.\n   */\n  public validateLogAgainstCriteria(\n    criteria: Criteria,\n    log: EventLogs[0],\n  ): boolean {\n    if (!Array.isArray(log.args) || log.args.length <= criteria.fieldIndex) {\n      throw new DecodedArgsMalformedError({\n        log,\n        criteria,\n        fieldValue: undefined,\n      });\n    }\n\n    const fieldValue = log.args.at(criteria.fieldIndex);\n    if (fieldValue === undefined) {\n      throw new FieldValueUndefinedError({ log, criteria, fieldValue });\n    }\n    return this.validateFieldAgainstCriteria(criteria, fieldValue, { log });\n  }\n\n  /**\n   * Validates a function's decoded arguments against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {unknown[]} decodedArgs - The decoded arguments of the function call.\n   * @returns {Promise<boolean>} - Returns true if the decoded argument passes the criteria, false otherwise.\n   */\n  public validateFunctionAgainstCriteria(\n    criteria: Criteria,\n    decodedArgs: readonly (string | bigint)[],\n  ): boolean {\n    const fieldValue = decodedArgs[criteria.fieldIndex];\n    if (fieldValue === undefined) {\n      throw new FieldValueUndefinedError({\n        criteria,\n        fieldValue,\n      });\n    }\n    return this.validateFieldAgainstCriteria(criteria, fieldValue, {\n      decodedArgs,\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?EventActionPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: EventActionPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    let rawPayload: EventActionPayloadRaw;\n    if (isEventActionPayloadSimple(payload)) {\n      // filter out any falsy potential values\n      let tmpSteps: ActionStep[] = payload.actionSteps.filter((step) => !!step);\n      if (tmpSteps.length === 0) {\n        throw new NoEventActionStepsProvidedError();\n      }\n      if (tmpSteps.length > 4) {\n        throw new TooManyEventActionStepsProvidedError();\n      }\n      let steps: ActionStepTuple = Array.from({ length: 4 }, (_, i) => {\n        // use either the provided step at the given index, or reuse the previous step\n        // should aways exist\n        return tmpSteps.at(i) || tmpSteps.at(-1);\n      }) as ActionStepTuple;\n      rawPayload = {\n        actionClaimant: payload.actionClaimant,\n        actionStepOne: steps[0],\n        actionStepTwo: steps[1],\n        actionStepThree: steps[2],\n        actionStepFour: steps[3],\n      };\n    } else {\n      rawPayload = payload;\n    }\n    return {\n      abi: eventActionAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareEventActionPayload(rawPayload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n\n  public isArraylikeIndexed(step: ActionStep, event: AbiEvent) {\n    if (\n      (step.actionParameter.fieldType === PrimitiveType.STRING ||\n        step.actionParameter.fieldType === PrimitiveType.BYTES) &&\n      event.inputs[step.actionParameter.fieldIndex]?.indexed\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\nfunction _dedupeActionSteps(_steps: ActionStep[]): ActionStep[] {\n  const steps: ActionStep[] = [],\n    signatures: Record<string, boolean> = {};\n  for (let step of _steps) {\n    const signature = JSON.stringify(step);\n    if (signatures[signature]) continue;\n    steps.push(step);\n    signatures[signature] = true;\n  }\n  return steps;\n}\ntype RawActionStep = Overwrite<ActionStep, { chainid: bigint }>;\ntype RawActionClaimant = Overwrite<ActionClaimant, { chainid: bigint }>;\n\nfunction _toRawActionStep<T extends ActionStep | ActionClaimant>(obj: T) {\n  return {\n    ...obj,\n    chainid: BigInt(obj.chainid),\n  };\n}\n\nfunction _fromRawActionStep<T extends RawActionStep | RawActionClaimant>(\n  obj: T,\n) {\n  if (obj.chainid > BigInt(Number.MAX_SAFE_INTEGER)) {\n    throw new Error('Chain ID exceeds max safe integer');\n  }\n\n  return {\n    ...obj,\n    chainid: Number(obj.chainid),\n  };\n}\n\n/**\n * Typeguard to determine if a user is supplying a simple or raw EventActionPayload\n *\n * @param {*} opts\n * @returns {opts is EventActionPayloadSimple}\n */\nfunction _isEventActionPayloadSimple(\n  opts: EventActionPayload,\n): opts is EventActionPayloadSimple {\n  return Array.isArray((opts as EventActionPayloadSimple).actionSteps);\n}\n\n/**\n * Function to properly encode an event action payload.\n *\n * @param {InitPayload} param0\n * @param {ActionStep} param0.actionStepOne - The first action step to initialize.\n * @param {ActionStep} param0.actionStepTwo - The second action step to initialize.\n * @param {ActionStep} param0.actionStepThree - The third action step to initialize.\n * @param {ActionStep} param0.actionStepFour - The fourth action step to initialize.\n * @returns {Hex}\n */\nexport function prepareEventActionPayload({\n  actionClaimant,\n  actionStepOne,\n  actionStepTwo,\n  actionStepThree,\n  actionStepFour,\n}: EventActionPayloadRaw) {\n  // note chainIds are technically uint256 but viem treats them (safely) as numbers,\n  // so we encode them as uint32 here to avoid downcast issues\n  return encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'initPayload',\n        components: [\n          {\n            type: 'tuple',\n            name: 'actionClaimant',\n            components: [\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'fieldIndex' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepOne',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepTwo',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepThree',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepFour',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    [\n      {\n        actionClaimant: _toRawActionStep(actionClaimant),\n        actionStepOne: {\n          ..._toRawActionStep(actionStepOne),\n          actionType: actionStepOne.actionType || 0,\n        },\n        actionStepTwo: {\n          ..._toRawActionStep(actionStepTwo),\n          actionType: actionStepTwo.actionType || 0,\n        },\n        actionStepThree: {\n          ..._toRawActionStep(actionStepThree),\n          actionType: actionStepThree.actionType || 0,\n        },\n        actionStepFour: {\n          ..._toRawActionStep(actionStepFour),\n          actionType: actionStepFour.actionType || 0,\n        },\n      },\n    ],\n  );\n}\n"],"names":["t","e","n","r","i","s","o","c","a","u","h","m","d","y","p","v","b","w","j","x","A","W","$","z","I","FilterType","PrimitiveType","SignatureType","isEventActionPayloadSimple","opts","_EventAction","DeployableTarget","eventActionAbi","index","params","steps","readEventActionGetActionSteps","_dedupeActionSteps","_fromRawActionStep","result","readEventActionGetActionClaimant","data","request","simulateEventActionExecute","writeEventActionExecute","actionSteps","actionStep","signature","event","_a","events","ValidationAbiMissingError","UnparseableAbiParamError","decodedLogs","log","eventName","args","decodeEventLog","transaction","ValidationLogsMissingError","criteria","logs","func","functions","decodedData","decodeFunctionData","FunctionDataDecodeError","decodedArgs","fieldValue","input","match","isAddressEqual","fromHex","InvalidNumericalCriteriaError","substring","FieldValueNotComparableError","regexString","UnrecognizedFilterTypeError","DecodedArgsMalformedError","FieldValueUndefinedError","_payload","_options","payload","options","rawPayload","tmpSteps","step","NoEventActionStepsProvidedError","TooManyEventActionStepsProvidedError","_","bytecode","prepareEventActionPayload","EventActionBases","RegistryType","EventAction","_steps","signatures","_toRawActionStep","obj","actionClaimant","actionStepOne","actionStepTwo","actionStepThree","actionStepFour","encodeAbiParameters"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAMA,IAAE,OAAO,IAAI,qBAAqB,GAAEC,KAAE,OAAO,IAAI,wBAAwB,GAAEC,IAAE,oCAAmCC,IAAE,OAAG,GAAQ,KAAa,OAAO,KAAjB,WAAoBC,IAAE,CAAAH,MAAGA,KAAG,CAAC,CAACA,EAAED,CAAC,GAAEK,IAAE,CAACH,GAAEI,GAAEC,MAAI;AAAC,MAAGH,EAAEF,CAAC,GAAE;AAAC,UAAMD,IAAEC,EAAEF,CAAC,EAAG,GAAC,EAAC,SAAQG,GAAE,YAAWC,EAAC,IAAEH,EAAE,MAAMK,CAAC;AAAE,WAAOH,KAAGC,KAAG,OAAO,KAAKA,CAAC,EAAE,QAAQ,CAAAJ,MAAGO,EAAEP,GAAEI,EAAEJ,CAAC,CAAC,CAAC,GAAEG;AAAA,EAAC;AAAC,MAAGA,EAAED,CAAC,GAAE;AAAC,QAAG,CAACC,EAAEG,CAAC,EAAE,QAAM;AAAG,QAAG,MAAM,QAAQJ,CAAC,GAAE;AAAC,UAAG,CAAC,MAAM,QAAQI,CAAC,EAAE,QAAM;AAAG,UAAIN,IAAE,CAAA,GAAGG,IAAE,CAAE,GAACK,IAAE,CAAA;AAAG,iBAAU,KAAKN,EAAE,KAAM,GAAC;AAAC,cAAMI,IAAEJ,EAAE,CAAC;AAAE,QAAAE,EAAEE,CAAC,KAAGA,EAAEL,EAAC,IAAEO,EAAE,KAAKF,CAAC,IAAEE,EAAE,SAAOL,EAAE,KAAKG,CAAC,IAAEN,EAAE,KAAKM,CAAC;AAAA,MAAC;AAAC,UAAGE,EAAE,QAAO;AAAC,YAAGA,EAAE,SAAO,EAAE,OAAM,IAAI,MAAM,0FAA0F;AAAE,YAAGF,EAAE,SAAON,EAAE,SAAOG,EAAE,OAAO,QAAM;AAAG,cAAMF,IAAEK,EAAE,MAAM,GAAEN,EAAE,MAAM,GAAEE,IAAMC,EAAE,WAAN,IAAa,CAAE,IAACG,EAAE,MAAM,CAACH,EAAE,MAAM,GAAEC,IAAEE,EAAE,MAAMN,EAAE,QAAWG,EAAE,WAAN,IAAa,QAAS,CAACA,EAAE,MAAM;AAAE,eAAOH,EAAE,MAAM,CAACA,GAAEE,MAAIG,EAAEL,GAAEC,EAAEC,CAAC,GAAEK,CAAC,CAAC,KAAGJ,EAAE,MAAM,CAACH,GAAEC,MAAII,EAAEL,GAAEE,EAAED,CAAC,GAAEM,CAAC,CAAC,MAAQC,EAAE,WAAN,KAAcH,EAAEG,EAAE,CAAC,GAAEJ,GAAEG,CAAC;AAAA,MAAE;AAAC,aAAOL,EAAE,WAASI,EAAE,UAAQJ,EAAE,MAAM,CAACF,GAAEC,MAAII,EAAEL,GAAEM,EAAEL,CAAC,GAAEM,CAAC,CAAC;AAAA,IAAC;AAAC,WAAO,QAAQ,QAAQL,CAAC,EAAE,MAAM,CAAAD,MAAG;AAAC,YAAME,IAAED,EAAED,CAAC;AAAE,cAAOA,KAAKK,KAAGF,EAAEI,IAAEL,CAAC,KAAgBK,EAAER,CAAC,EAAC,EAAG,gBAApB,eAAkCK,EAAEF,GAAEG,EAAEL,CAAC,GAAEM,CAAC;AAAE,UAAIC;AAAA,IAAC,CAAC;AAAA,EAAC;AAAC,SAAO,OAAO,GAAGF,GAAEJ,CAAC;AAAC,GAAEI,IAAE,CAAAL,MAAG;AAAC,MAAIC,GAAEG,GAAEG;AAAE,SAAOL,EAAEF,CAAC,IAAEG,EAAEH,CAAC,KAASC,KAASG,KAAGG,IAAEP,EAAED,CAAC,EAAC,GAAI,qBAApB,OAAsC,SAAOK,EAAE,KAAKG,CAAC,MAA9D,OAAiEN,IAAE,KAAG,MAAM,QAAQD,CAAC,IAAEM,EAAEN,GAAEK,CAAC,IAAEC,EAAE,OAAO,OAAON,CAAC,GAAEK,CAAC,IAAE,CAAE;AAAA,GAAEC,IAAE,CAAC,GAAEN,MAAI,EAAE,OAAO,CAACD,GAAE,MAAIA,EAAE,OAAOC,EAAE,CAAC,CAAC,GAAE,CAAA,CAAE;AAA2O,SAASQ,EAAE,GAAE;AAAC,SAAO,OAAO,OAAO,GAAE,EAAC,UAAS,MAAIC,GAAE,CAAC,GAAE,KAAI,CAAAT,MAAGU,EAAE,GAAEV,CAAC,GAAE,IAAG,CAAAA,MAAGW,GAAE,GAAEX,CAAC,GAAE,QAAO,CAAAA,MAAYA,MAAT,SAAWY,EAAE,CAAC,IAAEA,EAAEZ,GAAE,CAAC,EAAC,CAAC;AAAC;AAA+R,SAASS,GAAET,GAAE;AAAC,SAAOQ,EAAE,EAAC,CAACT,CAAC,GAAE,OAAK,EAAC,OAAM,CAAAA,MAAG;AAAC,QAAIE,IAAE,CAAA;AAAG,UAAMC,IAAE,CAACH,GAAEC,MAAI;AAAC,MAAAC,EAAEF,CAAC,IAAEC;AAAA,IAAC;AAAE,WAAgBD,MAAT,UAAYM,EAAEL,CAAC,EAAE,QAAQ,CAAAD,MAAGG,EAAEH,GAAE,MAAM,CAAC,GAAE,EAAC,SAAQ,IAAG,YAAWE,EAAC,KAAG,EAAC,SAAQG,EAAEJ,GAAED,GAAEG,CAAC,GAAE,YAAWD,EAAC;AAAA,EAAC,GAAE,kBAAiB,MAAII,EAAEL,CAAC,GAAE,aAAY,WAAU,GAAE,CAAC;AAAC;AAAmI,SAASU,KAAKV,GAAE;AAAC,SAAOQ,EAAE,EAAC,CAACT,CAAC,GAAE,OAAK,EAAC,OAAM,CAAAA,MAAG;AAAC,QAAIE,IAAE,CAAE;AAAC,UAAMC,IAAE,CAACH,GAAEC,MAAI;AAAC,MAAAC,EAAEF,CAAC,IAAEC;AAAA,IAAC;AAAE,WAAM,EAAC,SAAQA,EAAE,MAAM,CAAAA,MAAGI,EAAEJ,GAAED,GAAEG,CAAC,CAAC,GAAE,YAAWD,EAAC;AAAA,EAAC,GAAE,kBAAiB,MAAIK,EAAEN,GAAEK,CAAC,GAAE,aAAY,MAAK,GAAE,CAAC;AAAC;AAAC,SAASM,MAAKX,GAAE;AAAC,SAAOQ,EAAE,EAAC,CAACT,CAAC,GAAE,OAAK,EAAC,OAAM,CAAAA,MAAG;AAAC,QAAIE,IAAE,CAAE;AAAC,UAAMC,IAAE,CAACH,GAAEC,MAAI;AAAC,MAAAC,EAAEF,CAAC,IAAEC;AAAA,IAAC;AAAE,WAAOM,EAAEN,GAAEK,CAAC,EAAE,QAAQ,CAAAN,MAAGG,EAAEH,GAAE,MAAM,CAAC,GAAE,EAAC,SAAQC,EAAE,KAAK,CAAAA,MAAGI,EAAEJ,GAAED,GAAEG,CAAC,CAAC,GAAE,YAAWD,EAAC;AAAA,EAAC,GAAE,kBAAiB,MAAIK,EAAEN,GAAEK,CAAC,GAAE,aAAY,KAAI,GAAE,CAAC;AAAC;AAAC,SAASQ,EAAEb,GAAE;AAAC,SAAM,EAAC,CAACD,CAAC,GAAE,OAAK,EAAC,OAAM,CAAAA,OAAI,EAAC,SAAQ,EAAQC,EAAED,CAAC,EAAE,GAAE,GAAE;AAAC;AAAC,SAASa,KAAKZ,GAAE;AAAC,QAAME,IAAY,OAAOF,EAAE,CAAC,KAApB,WAAsBA,EAAE,CAAC,IAAE,QAAOG,IAAMH,EAAE,WAAN,IAAaA,EAAE,CAAC,IAAY,OAAOA,EAAE,CAAC,KAApB,WAAsB,SAAOA,EAAE,CAAC;AAAE,SAAOQ,EAAE,EAAC,CAACT,CAAC,GAAE,OAAK,EAAC,OAAM,CAAAA,MAAG;AAAC,QAAIC,IAAE,EAAC,CAAOE,KAAID,CAAC,GAAEF,EAAC;AAAE,WAAM,EAAC,SAAiBI,MAAT,UAAYC,EAAED,GAAEJ,GAAE,CAACA,GAAEE,MAAI;AAAC,MAAAD,EAAED,CAAC,IAAEE;AAAA,IAAC,CAAC,GAAE,YAAWD,EAAC;AAAA,EAAC,GAAE,kBAAiB,MAAI,CAAOE,KAAID,CAAC,EAAE,OAAgBE,MAAT,SAAW,KAAGE,EAAEF,CAAC,CAAC,EAAC,GAAE,CAAC;AAAC;AAAC,SAASW,EAAE,GAAE;AAAC,SAAgB,OAAO,KAAjB;AAAkB;AAAC,SAASC,EAAE,GAAE;AAAC,SAAgB,OAAO,KAAjB;AAAkB;AAAC,SAASC,EAAE,GAAE;AAAC,SAAgB,OAAO,KAAjB;AAAkB;AAASR,EAAEK,EAAE,SAAS,GAAE;AAAC,SAAM;AAAE,CAAC,CAAC;AAAC,MAAKI,IAAE,OAAG,OAAO,OAAOT,EAAE,CAAC,GAAE,EAAC,YAAW,CAAAR,MAAG;AAAC,SAAOiB,EAAEP,EAAE,IAAGT,IAAED,GAAEa,EAAE,CAAAd,MAAGgB,EAAEhB,CAAC,KAAGA,EAAE,WAAWE,CAAC,CAAC,EAAC,CAAE;AAAE,MAAIA;AAAC,GAAE,UAAS,CAAAD,MAAG;AAAC,SAAOiB,EAAEP,EAAE,IAAGT,IAAED,GAAEa,EAAE,CAAAd,MAAGgB,EAAEhB,CAAC,KAAGA,EAAE,SAASE,CAAC,CAAC,EAAC,CAAE;AAAE,MAAIA;AAAC,GAAE,WAAU,CAAAD,MAAGiB,EAAEP,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGe,EAAEf,CAAC,KAAGA,EAAE,UAAQD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,QAAO,CAAAA,MAAGiB,EAAEP,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGe,EAAEf,CAAC,KAAGA,EAAE,WAASD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,WAAU,CAAAA,MAAGiB,EAAEP,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGe,EAAEf,CAAC,KAAGA,EAAE,UAAQD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,UAAS,CAAAA,MAAG;AAAC,SAAOiB,EAAEP,EAAE,IAAGT,IAAED,GAAEa,EAAE,CAAAd,MAAGgB,EAAEhB,CAAC,KAAGA,EAAE,SAASE,CAAC,CAAC,EAAG,CAAA;AAAE,MAAIA;AAAC,GAAE,OAAM,CAAAD,MAAG;AAAC,SAAOiB,EAAEP,EAAE,IAAGT,IAAED,GAAEa,EAAE,CAAAd,MAAGgB,EAAEhB,CAAC,KAAG,EAAQA,EAAE,MAAME,CAAC,CAAE,GAAG;AAAE,MAAIA;AAAC,EAAC,CAAC;AAAIgB,EAAEJ,EAAEE,CAAC,CAAC;AAAE,MAAAG,IAAE,OAAG,OAAO,OAAOV,EAAE,CAAC,GAAE,EAAC,SAAQ,CAACR,GAAEC,MAAIiB,EAAER,EAAE,IAAG,CAACX,GAAEC,MAAIa,EAAE,CAAAZ,MAAGa,EAAEb,CAAC,KAAGF,KAAGE,KAAGD,KAAGC,CAAC,GAAGD,GAAEC,CAAC,CAAC,CAAC,GAAE,IAAG,CAAAD,MAAGkB,EAAER,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGc,EAAEd,CAAC,KAAGA,IAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,IAAG,CAAAA,MAAGkB,EAAER,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGc,EAAEd,CAAC,KAAGA,IAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,KAAI,CAAAA,MAAGkB,EAAER,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGc,EAAEd,CAAC,KAAGA,KAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,KAAI,CAAAA,MAAGkB,EAAER,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGc,EAAEd,CAAC,KAAGA,KAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,KAAI,MAAIkB,EAAER,EAAE,GAAEG,EAAE,CAAAd,MAAGe,EAAEf,CAAC,KAAG,OAAO,UAAUA,CAAC,CAAC,CAAC,CAAC,GAAE,QAAO,MAAImB,EAAER,EAAE,GAAEG,EAAE,CAAAd,MAAGe,EAAEf,CAAC,KAAG,OAAO,SAASA,CAAC,CAAC,CAAC,CAAC,GAAE,UAAS,MAAImB,EAAER,EAAE,GAAEG,EAAE,CAAAd,MAAGe,EAAEf,CAAC,KAAGA,IAAE,CAAC,CAAC,CAAC,GAAE,UAAS,MAAImB,EAAER,EAAE,GAAEG,EAAE,CAAAd,MAAGe,EAAEf,CAAC,KAAGA,IAAE,CAAC,CAAC,CAAC,EAAC,CAAC;AAAImB,EAAEL,EAAEC,CAAC,CAAC;AAAE,MAAAK,IAAE,OAAG,OAAO,OAAOX,EAAE,CAAC,GAAE,EAAC,SAAQ,CAACR,GAAEC,MAAIkB,EAAET,EAAE,IAAG,CAACX,GAAEC,MAAIa,EAAE,CAAAZ,MAAGe,EAAEf,CAAC,KAAGF,KAAGE,KAAGD,KAAGC,CAAC,GAAGD,GAAEC,CAAC,CAAC,CAAC,GAAE,IAAG,CAAAD,MAAGmB,EAAET,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGgB,EAAEhB,CAAC,KAAGA,IAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,IAAG,CAAAA,MAAGmB,EAAET,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGgB,EAAEhB,CAAC,KAAGA,IAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,KAAI,CAAAA,MAAGmB,EAAET,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGgB,EAAEhB,CAAC,KAAGA,KAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,KAAI,CAAAA,MAAGmB,EAAET,EAAE,IAAG,CAAAX,MAAGc,EAAE,CAAAb,MAAGgB,EAAEhB,CAAC,KAAGA,KAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,GAAE,UAAS,MAAImB,EAAET,EAAE,GAAEG,EAAE,CAAAd,MAAGiB,EAAEjB,CAAC,KAAGA,IAAE,CAAC,CAAC,CAAC,GAAE,UAAS,MAAIoB,EAAET,EAAE,GAAEG,EAAE,CAAAd,MAAGiB,EAAEjB,CAAC,KAAGA,IAAE,CAAC,CAAC,CAAC,EAAC,CAAC;AAAIoB,EAAEN,EAAEG,CAAC,CAAC;AAAIR,EAAEK,EAAE,SAAS,GAAE;AAAC,SAAiB,OAAO,KAAlB;AAAmB,CAAC,CAAC;AAAIL,EAAEK,EAAE,SAAS,GAAE;AAAC,SAAgB,OAAO,KAAjB;AAAkB,CAAC,CAAC;AAAIL,EAAEK,EAAE,SAAS,GAAE;AAAC,SAAa,KAAN;AAAO,CAAC,CAAC;AAAIL,EAAEK,EAAE,SAAS,GAAE;AAAC,SAAa,KAAN;AAAO,CAAC,CAAC;AAAwmD,MAAMO,WAAU,MAAK;AAAA,EAAC,YAAYrB,GAAE;AAAC,QAAI;AAAE,QAAG;AAAC,UAAE,KAAK,UAAUA,CAAC;AAAA,IAAC,QAAS;AAAC,UAAEA;AAAA,IAAC;AAAC,UAAM,oDAAoD,CAAC,EAAE,GAAE,KAAK,QAAM,QAAO,KAAK,QAAMA;AAAA,EAAC;AAAC;AAAC,MAAMsB,IAAE,EAAC,SAAQ,IAAG,OAAM,OAAM;AAAE,SAASC,EAAE,GAAE;AAAC,SAAO,IAAIC,EAAE,GAAEF,CAAC;AAAC;AAAC,MAAME,EAAC;AAAA,EAAC,YAAYxB,GAAE,GAAE;AAAC,SAAK,QAAM,QAAO,KAAK,QAAM,QAAO,KAAK,QAAMA,GAAE,KAAK,QAAM;AAAA,EAAC;AAAA,EAAC,QAAQA,GAAE;AAAC,QAAG,KAAK,MAAM,QAAQ,QAAO;AAAK,UAAM,IAAEA,EAAEA,EAAE,SAAO,CAAC,GAAEG,IAAE,CAACH,EAAE,CAAC,CAAC;AAAE,QAAII;AAAE,IAAIJ,EAAE,WAAN,KAA0B,OAAOA,EAAE,CAAC,KAAtB,aAAwBI,IAAEJ,EAAE,CAAC,IAAEA,EAAE,SAAO,KAAGG,EAAE,KAAK,GAAGH,EAAE,MAAM,GAAEA,EAAE,SAAO,CAAC,CAAC;AAAE,QAAIM,IAAE,IAAGC,IAAE;AAAG,UAAMC,IAAE,CAACR,GAAEC,MAAI;AAAC,MAAAK,IAAE,IAAGC,EAAEP,CAAC,IAAEC;AAAA,IAAC,GAAE,IAAE,CAACE,EAAE,KAAK,CAAAH,MAAGK,EAAEL,GAAE,KAAK,OAAMQ,CAAC,CAAC,KAAGJ,KAAG,CAASA,EAAE,KAAK,KAAK,IAAGkB,IAAE,EAAC,SAAQ,IAAG,OAAM,EAAEhB,IAAEJ,KAAKK,IAAEA,EAAEL,CAAC,IAAEK,IAAE,KAAK,OAAM,KAAK,KAAK,EAAC;AAAE,WAAO,IAAIiB,EAAE,KAAK,OAAM,CAAC;AAAA,EAAC;AAAA,EAAC,KAAKxB,GAAE,GAAE;AAAC,QAAG,KAAK,MAAM,QAAQ,QAAO;AAAK,UAAM,IAAE,EAAQA,EAAE,KAAK,KAAK;AAAG,WAAO,IAAIwB,EAAE,KAAK,OAAM,IAAE,EAAC,SAAQ,IAAG,OAAM,EAAE,KAAK,OAAM,KAAK,KAAK,EAAC,IAAEF,CAAC;AAAA,EAAC;AAAA,EAAC,UAAUtB,GAAE;AAAC,WAAO,KAAK,MAAM,UAAQ,KAAK,MAAM,QAAMA,EAAE,KAAK,KAAK;AAAA,EAAC;AAAA,EAAC,aAAY;AAAC,QAAG,KAAK,MAAM,QAAQ,QAAO,KAAK,MAAM;AAAM,UAAM,IAAIqB,GAAE,KAAK,KAAK;AAAA,EAAC;AAAA,EAAC,MAAK;AAAC,WAAO,KAAK;EAAY;AAAA,EAAC,aAAY;AAAC,WAAO;AAAA,EAAI;AAAC;ACmE9kO,IAAAI,uBAAAA,OACVA,EAAAA,EAAA,QAAQ,CAAR,IAAA,SACAA,EAAAA,EAAA,YAAY,CAAZ,IAAA,aACAA,EAAAA,EAAA,eAAe,CAAf,IAAA,gBACAA,EAAAA,EAAA,YAAY,CAAZ,IAAA,aACAA,EAAAA,EAAA,WAAW,CAAX,IAAA,YACAA,EAAAA,EAAA,QAAQ,CAAR,IAAA,SANUA,IAAAA,MAAA,CAAA,CAAA,GAeAC,uBAAAA,OACVA,EAAAA,EAAA,OAAO,CAAP,IAAA,QACAA,EAAAA,EAAA,UAAU,CAAV,IAAA,WACAA,EAAAA,EAAA,QAAQ,CAAR,IAAA,SACAA,EAAAA,EAAA,SAAS,CAAT,IAAA,UAJUA,IAAAA,MAAA,CAAA,CAAA,GA+CAC,uBAAAA,OACVA,EAAAA,EAAA,QAAQ,CAAR,IAAA,SACAA,EAAAA,EAAA,OAAO,CAAP,IAAA,QAFUA,IAAAA,MAAA,CAAA,CAAA;AA4IL,SAASC,GACdC,GACkC;AAC3B,SAAA,MAAM,QAASA,EAAkC,WAAW;AACrE;AAoEO,MAAMC,IAAN,MAAMA,UAAoBC,EAG/B;AAAA,EAHK,cAAA;AAAA,UAAA,GAAA,SAAA,GAWL,KAAyB,MAAMC;AAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6B/B,MAAa,cACXC,GACAC,GACA;AAEO,YADO,MAAM,KAAK,eAAeA,CAAM,GACjC,GAAGD,CAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,eACXC,GACA;AACA,UAAMC,IAAS,MAAMC,EAA8B,KAAK,SAAS;AAAA,MAC/D,SAAS,KAAK,mBAAmB;AAAA,MACjC,GAAG,KAAK,wBAAwB;AAAA;AAAA,MAEhC,GAAIF;AAAA,IAAA,CACL;AACD,WAAOG,GAAmBF,EAAM,IAAIG,CAAkB,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,oBACXJ,GACA;AAEA,YADc,MAAM,KAAK,eAAeA,CAAM,GACjC;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,kBACXA,GACA;AACA,UAAMK,IAAU,MAAMC,EAAiC,KAAK,SAAS;AAAA,MACnE,SAAS,KAAK,mBAAmB;AAAA,MACjC,GAAG,KAAK,wBAAwB;AAAA,MAChC,GAAGN;AAAA,IAAA,CACJ;AACD,WAAOI,EAAmBC,CAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,QACXE,GACAP,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,WAAWO,GAAMP,CAAM,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,WACXO,GACAP,GACA;AACA,UAAM,EAAE,SAAAQ,GAAS,QAAAH,EAAA,IAAW,MAAMI,EAA2B,KAAK,SAAS;AAAA,MACzE,SAAS,KAAK,mBAAmB;AAAA,MACjC,GAAG,KAAK,wBAAwB;AAAA;AAAA,MAEhC,GAAIT;AAAA,MACJ,MAAM,CAACO,CAAI;AAAA,IAAA,CACZ;AAEM,WAAA,EAAE,MADI,MAAMG,EAAwB,KAAK,SAASF,CAAO,GACjD,QAAAH;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,oBAAoBL,GAAkC;AAC3D,UAAAW,IAAc,MAAM,KAAK;AAC/B,eAAWC,KAAcD;AACvB,UAAI,CAAE,MAAM,KAAK,kBAAkBC,GAAYZ,CAAM;AAC5C,eAAA;AAGJ,WAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAa,kBACXY,GACAZ,GACA;;AACI,QAAAY,EAAW,kBAAkB,GAAqB;AACpD,YAAMC,IAAYD,EAAW;AACzB,UAAAE;AAQJ,UANId,EAAO,cACDc,KAAAC,IAAAf,EAAO,gBAAP,gBAAAe,EAAqBF,KAEpBC,IAAAE,GAAO,IAA8BH,CAAS,GAGrD,CAACC;AACG,cAAA,IAAIG,EAA0BJ,CAAS;AAG/C,UAAI,KAAK,mBAAmBD,GAAYE,CAAK;AAE3C,cAAM,IAAII;AAAA,UACRN,EAAW,gBAAgB;AAAA,UAC3BE;AAAA,QAAA;AAOJ,UAHAd,EAAO,QAAQc,GAGX,UAAUd;AACL,eAAA,KAAK,mBAAmBY,GAAY;AAAA,UACzC,GAAGZ;AAAA,QAAA,CACJ;AASH,YAAMmB,KAHU,MAHD,KAAK,QAAQ,UAAU;AAAA,QACpC,SAASnB,EAAO;AAAA,MAAA,CACjB,EAC4B,sBAAsB;AAAA,QACjD,MAAMA,EAAO;AAAA,MAAA,CACd,GAC2B,KAAK,IAAI,CAACoB,MAAQ;AAC5C,cAAM,EAAE,WAAAC,GAAW,MAAAC,EAAK,IAAIC,EAAe;AAAA,UACzC,KAAK,CAACT,CAAK;AAAA,UACX,MAAMM,EAAI;AAAA,UACV,QAAQA,EAAI;AAAA,QAAA,CACb;AAED,eAAO,EAAE,GAAGA,GAAK,WAAAC,GAAW,MAAAC,EAAK;AAAA,MAAA,CAClC;AAEM,aAAA,KAAK,mBAAmBV,GAAY;AAAA,QACzC,MAAMO;AAAA,QACN,GAAGnB;AAAA,MAAA,CACJ;AAAA,IACH;AACI,QAAAY,EAAW,kBAAkB,KAC3B,UAAUZ,KAAU,aAAaA,GAAQ;AAIrC,YAAAwB,IAAc,MAHL,KAAK,QAAQ,UAAU;AAAA,QACpC,SAASxB,EAAO;AAAA,MAAA,CACjB,EACgC,eAAe;AAAA,QAC9C,MAAMA,EAAO;AAAA,MAAA,CACd;AACM,aAAA,KAAK,sBAAsBY,GAAYY,CAAW;AAAA,IAC3D;AAEK,WAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,mBACLZ,GACAZ,GACA;AACI,QAAA,EAAE,UAAUA;AACd,YAAM,IAAIyB,EAA2B;AAEvC,UAAMC,IAAWd,EAAW,iBACtBe,IAAO3B,EAAO;AAChB,QAAA,CAAC2B,EAAK,OAAe,QAAA;AACzB,aAASP,KAAOO;AACd,UAAI,KAAK,2BAA2BD,GAAUN,CAAG;AACxC,eAAA;AAGJ,WAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,sBACLR,GACAY,GACA;AACA,UAAME,IAAWd,EAAW;AAC5B,QAAIC,IAAYD,EAAW;AAErB,UAAAgB,IAAQC,GAAU,IACtBhB,CACF;AACA,QAAI,CAACe;AACG,YAAA,IAAIX,EAA0BJ,CAAS;AAG3C,QAAAiB;AACA,QAAA;AACF,MAAAA,IAAcC,EAAmB;AAAA,QAC/B,KAAK,CAACH,CAAI;AAAA,QACV,MAAMJ,EAAY;AAAA,MAAA,CACnB;AAAA,aACMzD,GAAG;AACV,YAAM,IAAIiE,GAAwB,CAACJ,CAAI,GAAG7D,CAAU;AAAA,IACtD;AAGA,UAAMkE,IAAcH,EAAY;AAIhC,WAFI,GAACG,KAAe,CAACH,KAGnB,CAAC,KAAK;AAAA,MACJJ;AAAA,MACAO;AAAA,IAAA;AAAA,EAON;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,6BACLP,GACAQ,GACAC,GAGS;AAET,YAAQT,EAAS,YAAY;AAAA,MAC3B,KAAK;AACI,eAAAU,EAAMV,EAAS,SAAS,EAC5B;AAAA,UAAK;AAAA,UAAuB,MAC3BW,EAAeX,EAAS,YAAYQ,CAAqB;AAAA,QAAA,EAE1D;AAAA,UACC;AAAA,UACA,MAAM,OAAOA,CAAU,MAAM,OAAOR,EAAS,UAAU;AAAA,QAAA,EAExD;AAAA,UACC;AAAA,UACA,MAAMQ,MAAeI,EAAQZ,EAAS,YAAY,QAAQ;AAAA,QAE3D,EAAA,UAAU,MAAMQ,MAAeR,EAAS,UAAU;AAAA,MAEvD,KAAK;AACI,eAAAU,EAAMV,EAAS,SAAS,EAC5B;AAAA,UACC;AAAA,UACA,MAAM,CAACW,EAAeX,EAAS,YAAYQ,CAAqB;AAAA,QAAA,EAEjE;AAAA,UACC;AAAA,UACA,MAAM,OAAOA,CAAU,MAAM,OAAOR,EAAS,UAAU;AAAA,QAAA,EAExD;AAAA,UACC;AAAA,UACA,MAAMQ,MAAeI,EAAQZ,EAAS,YAAY,QAAQ;AAAA,QAE3D,EAAA,UAAU,MAAMQ,MAAeR,EAAS,UAAU;AAAA,MAEvD,KAAK;AACC,YAAAA,EAAS,cAAc;AACzB,iBAAO,OAAOQ,CAAU,IAAI,OAAOR,EAAS,UAAU;AAExD,cAAM,IAAIa,EAA8B;AAAA,UACtC,GAAGJ;AAAA,UACH,UAAAT;AAAA,UACA,YAAAQ;AAAA,QAAA,CACD;AAAA,MAEH,KAAK;AACC,YAAAR,EAAS,cAAc;AACzB,iBAAO,OAAOQ,CAAU,IAAI,OAAOR,EAAS,UAAU;AAExD,cAAM,IAAIa,EAA8B;AAAA,UACtC,GAAGJ;AAAA,UACH,UAAAT;AAAA,UACA,YAAAQ;AAAA,QAAA,CACD;AAAA,MAEH,KAAK;AACH,YACER,EAAS,cAAc,KACvBA,EAAS,cAAc,GACvB;AACI,cAAAc;AACA,iBAAAd,EAAS,cAAc,IACbc,IAAAF,EAAQZ,EAAS,YAAY,QAAQ,IAGrCc,IAAAd,EAAS,WAAW,MAAM,CAAC,GAEjCQ,EAAsB,SAASM,CAAS;AAAA,QAClD;AACA,cAAM,IAAIC,EAA6B;AAAA,UACrC,GAAGN;AAAA,UACH,UAAAT;AAAA,UACA,YAAAQ;AAAA,QAAA,CACD;AAAA,MAEH,KAAK;AACC,YAAA,OAAOA,KAAe;AACxB,gBAAM,IAAIO,EAA6B;AAAA,YACrC,GAAGN;AAAA,YACH,UAAAT;AAAA,YACA,YAAAQ;AAAA,UAAA,CACD;AAGC,YAAAR,EAAS,cAAc,GAAsB;AAE/C,gBAAMgB,IAAcJ,EAAQZ,EAAS,YAAY,QAAQ;AACzD,iBAAO,IAAI,OAAOgB,CAAW,EAAE,KAAKR,CAAU;AAAA,QAChD;AAAA,MAEF;AACE,cAAM,IAAIS,GAA4B;AAAA,UACpC,GAAGR;AAAA,UACH,UAAAT;AAAA,UACA,YAAAQ;AAAA,QAAA,CACD;AAAA,IACL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,2BACLR,GACAN,GACS;AACL,QAAA,CAAC,MAAM,QAAQA,EAAI,IAAI,KAAKA,EAAI,KAAK,UAAUM,EAAS;AAC1D,YAAM,IAAIkB,GAA0B;AAAA,QAClC,KAAAxB;AAAA,QACA,UAAAM;AAAA,QACA,YAAY;AAAA,MAAA,CACb;AAGH,UAAMQ,IAAad,EAAI,KAAK,GAAGM,EAAS,UAAU;AAClD,QAAIQ,MAAe;AACjB,YAAM,IAAIW,EAAyB,EAAE,KAAAzB,GAAK,UAAAM,GAAU,YAAAQ,EAAY,CAAA;AAElE,WAAO,KAAK,6BAA6BR,GAAUQ,GAAY,EAAE,KAAAd,GAAK;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,gCACLM,GACAO,GACS;AACH,UAAAC,IAAaD,EAAYP,EAAS,UAAU;AAClD,QAAIQ,MAAe;AACjB,YAAM,IAAIW,EAAyB;AAAA,QACjC,UAAAnB;AAAA,QACA,YAAAQ;AAAA,MAAA,CACD;AAEI,WAAA,KAAK,6BAA6BR,GAAUQ,GAAY;AAAA,MAC7D,aAAAD;AAAA,IAAA,CACD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUgB,gBACda,GACAC,GACyB;AACzB,UAAM,CAACC,GAASC,CAAO,IAAI,KAAK;AAAA,MAC9BH;AAAA,MACAC;AAAA,IAAA;AAEE,QAAAG;AACA,QAAAxD,GAA2BsD,CAAO,GAAG;AAEnC,UAAAG,IAAyBH,EAAQ,YAAY,OAAO,CAACI,MAAS,CAAC,CAACA,CAAI;AACpE,UAAAD,EAAS,WAAW;AACtB,cAAM,IAAIE,GAAgC;AAExC,UAAAF,EAAS,SAAS;AACpB,cAAM,IAAIG,GAAqC;AAE7C,UAAArD,IAAyB,MAAM,KAAK,EAAE,QAAQ,EAAE,GAAG,CAACsD,GAAGrF,MAGlDiF,EAAS,GAAGjF,CAAC,KAAKiF,EAAS,GAAG,EAAE,CACxC;AACY,MAAAD,IAAA;AAAA,QACX,gBAAgBF,EAAQ;AAAA,QACxB,eAAe/C,EAAM,CAAC;AAAA,QACtB,eAAeA,EAAM,CAAC;AAAA,QACtB,iBAAiBA,EAAM,CAAC;AAAA,QACxB,gBAAgBA,EAAM,CAAC;AAAA,MAAA;AAAA,IACzB;AAEa,MAAAiD,IAAAF;AAER,WAAA;AAAA,MACL,KAAKlD;AAAAA,MACL,UAAA0D;AAAA,MACA,MAAM,CAACC,GAA0BP,CAAU,CAAC;AAAA,MAC5C,GAAG,KAAK,wBAAwBD,EAAQ,OAAO;AAAA,IAAA;AAAA,EAEnD;AAAA,EAEO,mBAAmBG,GAAkBtC,GAAiB;;AAC3D,WACG,IAAAsC,EAAK,gBAAgB,cAAc,KAClCA,EAAK,gBAAgB,cAAc,QACrCrC,IAAAD,EAAM,OAAOsC,EAAK,gBAAgB,UAAU,MAA5C,QAAArC,EAA+C;AAAA,EAKnD;AACF;AAzgBEnB,EAAuB,QAAiC;AAAA,EACtD,GAAI8D;AAAA,GASN9D,EAAuB,eAA6B+D,GAAa;AA7B5D,IAAMC,IAANhE;AA8hBP,SAASO,GAAmB0D,GAAoC;AAC9D,QAAM5D,IAAsB,CAAA,GAC1B6D,IAAsC;AACxC,WAASV,KAAQS,GAAQ;AACjB,UAAAhD,IAAY,KAAK,UAAUuC,CAAI;AACjC,IAAAU,EAAWjD,CAAS,MACxBZ,EAAM,KAAKmD,CAAI,GACfU,EAAWjD,CAAS,IAAI;AAAA,EAC1B;AACO,SAAAZ;AACT;AAIA,SAAS8D,EAAwDC,GAAQ;AAChE,SAAA;AAAA,IACL,GAAGA;AAAA,IACH,SAAS,OAAOA,EAAI,OAAO;AAAA,EAAA;AAE/B;AAEA,SAAS5D,EACP4D,GACA;AACA,MAAIA,EAAI,UAAU,OAAO,OAAO,gBAAgB;AACxC,UAAA,IAAI,MAAM,mCAAmC;AAG9C,SAAA;AAAA,IACL,GAAGA;AAAA,IACH,SAAS,OAAOA,EAAI,OAAO;AAAA,EAAA;AAE/B;AAwBO,SAASP,GAA0B;AAAA,EACxC,gBAAAQ;AAAA,EACA,eAAAC;AAAA,EACA,eAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,gBAAAC;AACF,GAA0B;AAGjB,SAAAC;AAAA,IACL;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,QACN,YAAY;AAAA,UACV;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,YAAY;AAAA,cACV,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,cACvC,EAAE,MAAM,WAAW,MAAM,YAAY;AAAA,cACrC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,cACpC,EAAE,MAAM,WAAW,MAAM,iBAAiB;AAAA,cAC1C,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,YACrC;AAAA,UACF;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,YAAY;AAAA,cACV,EAAE,MAAM,WAAW,MAAM,YAAY;AAAA,cACrC,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,cACvC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,cACpC,EAAE,MAAM,WAAW,MAAM,iBAAiB;AAAA,cAC1C,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,cACnC;AAAA,gBACE,MAAM;AAAA,gBACN,MAAM;AAAA,gBACN,YAAY;AAAA,kBACV,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,YAAY;AAAA,kBACnC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,YAAY;AAAA,cACV,EAAE,MAAM,WAAW,MAAM,YAAY;AAAA,cACrC,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,cACvC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,cACpC,EAAE,MAAM,WAAW,MAAM,iBAAiB;AAAA,cAC1C,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,cACnC;AAAA,gBACE,MAAM;AAAA,gBACN,MAAM;AAAA,gBACN,YAAY;AAAA,kBACV,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,YAAY;AAAA,kBACnC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,YAAY;AAAA,cACV,EAAE,MAAM,WAAW,MAAM,YAAY;AAAA,cACrC,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,cACvC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,cACpC,EAAE,MAAM,WAAW,MAAM,iBAAiB;AAAA,cAC1C,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,cACnC;AAAA,gBACE,MAAM;AAAA,gBACN,MAAM;AAAA,gBACN,YAAY;AAAA,kBACV,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,YAAY;AAAA,kBACnC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,YAAY;AAAA,cACV,EAAE,MAAM,WAAW,MAAM,YAAY;AAAA,cACrC,EAAE,MAAM,SAAS,MAAM,gBAAgB;AAAA,cACvC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,cACpC,EAAE,MAAM,WAAW,MAAM,iBAAiB;AAAA,cAC1C,EAAE,MAAM,WAAW,MAAM,UAAU;AAAA,cACnC;AAAA,gBACE,MAAM;AAAA,gBACN,MAAM;AAAA,gBACN,YAAY;AAAA,kBACV,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,YAAY;AAAA,kBACnC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,kBACpC,EAAE,MAAM,SAAS,MAAM,aAAa;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE;AAAA,QACE,gBAAgBP,EAAiBE,CAAc;AAAA,QAC/C,eAAe;AAAA,UACb,GAAGF,EAAiBG,CAAa;AAAA,UACjC,YAAYA,EAAc,cAAc;AAAA,QAC1C;AAAA,QACA,eAAe;AAAA,UACb,GAAGH,EAAiBI,CAAa;AAAA,UACjC,YAAYA,EAAc,cAAc;AAAA,QAC1C;AAAA,QACA,iBAAiB;AAAA,UACf,GAAGJ,EAAiBK,CAAe;AAAA,UACnC,YAAYA,EAAgB,cAAc;AAAA,QAC5C;AAAA,QACA,gBAAgB;AAAA,UACd,GAAGL,EAAiBM,CAAc;AAAA,UAClC,YAAYA,EAAe,cAAc;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAAA,EAAA;AAEJ;","x_google_ignoreList":[0]}