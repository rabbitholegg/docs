{"version":3,"file":"SimpleAllowList.cjs","sources":["../../src/AllowLists/SimpleAllowList.ts"],"sourcesContent":["import {\n  readSimpleAllowListIsAllowed,\n  readSimpleAllowListOwner,\n  simpleAllowListAbi,\n  simulateSimpleAllowListSetAllowed,\n  writeSimpleAllowListSetAllowed,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/allowlists/SimpleAllowList.sol/SimpleAllowList.json';\nimport { getAccount } from '@wagmi/core';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  encodeAbiParameters,\n  zeroAddress,\n  zeroHash,\n} from 'viem';\nimport { SimpleAllowList as SimpleAllowListBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport {\n  DeployableTargetWithRBAC,\n  Roles,\n} from '../Deployable/DeployableTargetWithRBAC';\nimport { DeployableUnknownOwnerProvidedError } from '../errors';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\nexport { simpleAllowListAbi };\n\n/**\n * Object representation of a {@link SimpleAllowList} initialization payload.\n *\n * @export\n * @interface SimpleAllowListPayload\n * @typedef {SimpleAllowListPayload}\n */\nexport interface SimpleAllowListPayload {\n  /**\n   * The allow list's owner, given the {@link LIST_MANAGER_ROLE} role.\n   *\n   * @type {Address}\n   */\n  owner: Address;\n  /**\n   * List of allowed addresses.\n   *\n   * @type {Address[]}\n   */\n  allowed: Address[];\n}\n\n/**\n * A generic `viem.Log` event with support for `SimpleAllowList` event types.\n *\n * @export\n * @typedef {SimpleAllowListLog}\n * @template {ContractEventName<\n *     typeof simpleAllowListAbi\n *   >} [event=ContractEventName<typeof simpleAllowListAbi>]\n */\nexport type SimpleAllowListLog<\n  event extends ContractEventName<\n    typeof simpleAllowListAbi\n  > = ContractEventName<typeof simpleAllowListAbi>,\n> = GenericLog<typeof simpleAllowListAbi, event>;\n\n/**\n * A constant representing the list manager's role\n *\n * @deprecated use {@link Roles} instead\n * @type {1n}\n */\nexport const LIST_MANAGER_ROLE = Roles.MANAGER;\n/**\n * A simple implementation of an AllowList that checks if a user is authorized based on a list of allowed addresses\n *\n * @export\n * @class SimpleAllowList\n * @typedef {SimpleAllowList}\n * @extends {DeployableTargetWithRBAC<SimpleAllowListPayload>}\n */\nexport class SimpleAllowList extends DeployableTargetWithRBAC<\n  SimpleAllowListPayload,\n  typeof simpleAllowListAbi\n> {\n  public override readonly abi = simpleAllowListAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(SimpleAllowListBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.ALLOW_LIST;\n\n  /**\n   * Retrieves the owner\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>} - The address of the owner\n   */\n  public async owner(\n    params?: ReadParams<typeof simpleAllowListAbi, 'owner'>,\n  ): Promise<Address> {\n    return await readSimpleAllowListOwner(this._config, {\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      address: this.assertValidAddress(),\n      args: [],\n    });\n  }\n\n  /**\n   * Check if a user is authorized.\n   *\n   * @public\n   * @async\n   * @param {Address} address - The address of the user\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} - True if the user is authorized\n   */\n  public async isAllowed(\n    address: Address,\n    params?: ReadParams<typeof simpleAllowListAbi, 'setAllowed'>,\n  ): Promise<boolean> {\n    return await readSimpleAllowListIsAllowed(this._config, {\n      address: this.assertValidAddress(),\n      args: [address, zeroHash],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Set the allowed status of a user. The length of the `users_` and `allowed_` arrays must be the same.\n   * This function can only be called by the owner\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of users to update\n   * @param {boolean[]} allowed - The allowed status of each user\n   * @param {?ReadParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setAllowed(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof simpleAllowListAbi, 'setAllowed'>,\n  ) {\n    return await this.awaitResult(\n      this.setAllowedRaw(addresses, allowed, params),\n    );\n  }\n\n  /**\n   * Set the allowed status of a user. The length of the `users_` and `allowed_` arrays must be the same.\n   * This function can only be called by the owner\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of users to update\n   * @param {boolean[]} allowed - The allowed status of each user\n   * @param {?ReadParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setAllowedRaw(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: ReadParams<typeof simpleAllowListAbi, 'setAllowed'>,\n  ) {\n    const { request, result } = await simulateSimpleAllowListSetAllowed(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [addresses, allowed],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSimpleAllowListSetAllowed(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?SimpleAllowListPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: SimpleAllowListPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    if (!payload.owner || payload.owner === zeroAddress) {\n      const owner = options.account\n        ? options.account.address\n        : options.config\n          ? getAccount(options.config).address\n          : this._account?.address;\n      if (owner) {\n        payload.owner = owner;\n      } else {\n        throw new DeployableUnknownOwnerProvidedError();\n      }\n    }\n    return {\n      abi: simpleAllowListAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareSimpleAllowListPayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Given a {@link SimpleAllowListPayload}, properly encode the initialization payload.\n *\n * @param {SimpleAllowListPayload} param0\n * @param {Address} param0.owner - The allow list's owner, given the {@link LIST_MANAGER_ROLE} role.\n * @param {Address[]} param0.allowed - List of allowed addresses.\n * @returns {Hex}\n */\nexport function prepareSimpleAllowListPayload({\n  owner,\n  allowed,\n}: SimpleAllowListPayload) {\n  return encodeAbiParameters(\n    [\n      { type: 'address', name: 'owner' },\n      { type: 'address[]', name: 'allowed' },\n    ],\n    [owner, allowed],\n  );\n}\n"],"names":["LIST_MANAGER_ROLE","Roles","_SimpleAllowList","DeployableTargetWithRBAC","simpleAllowListAbi","params","readSimpleAllowListOwner","address","readSimpleAllowListIsAllowed","zeroHash","addresses","allowed","request","result","simulateSimpleAllowListSetAllowed","writeSimpleAllowListSetAllowed","_payload","_options","payload","options","zeroAddress","owner","getAccount","_a","DeployableUnknownOwnerProvidedError","bytecode","prepareSimpleAllowListPayload","SimpleAllowListBases","RegistryType","SimpleAllowList","encodeAbiParameters"],"mappings":"2raA+EaA,EAAoBC,EAAM,MAAA,QAS1BC,EAAN,MAAMA,UAAwBC,EAAAA,wBAGnC,CAHK,aAAA,CAAA,MAAA,GAAA,SAAA,EAIL,KAAyB,IAAMC,GAAA,CA4B/B,MAAa,MACXC,EACkB,CACX,OAAA,MAAMC,EAAAA,GAAyB,KAAK,QAAS,CAClD,GAAG,KAAK,wBAAwB,EAEhC,GAAID,EACJ,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAAC,CAAA,CACR,CACH,CAWA,MAAa,UACXE,EACAF,EACkB,CACX,OAAA,MAAMG,EAAAA,GAA6B,KAAK,QAAS,CACtD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACD,EAASE,UAAQ,EACxB,GAAG,KAAK,wBAAwB,EAEhC,GAAIJ,CAAA,CACL,CACH,CAaA,MAAa,WACXK,EACAC,EACAN,EACA,CACA,OAAO,MAAM,KAAK,YAChB,KAAK,cAAcK,EAAWC,EAASN,CAAM,CAAA,CAEjD,CAaA,MAAa,cACXK,EACAC,EACAN,EACA,CACA,KAAM,CAAE,QAAAO,EAAS,OAAAC,CAAO,EAAI,MAAMC,EAAA,GAChC,KAAK,QACL,CACE,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACJ,EAAWC,CAAO,EACzB,GAAG,KAAK,wBAAwB,EAEhC,GAAIN,CACN,CAAA,EAGK,MAAA,CAAE,KADI,MAAMU,EAA+B,GAAA,KAAK,QAASH,CAAO,EACxD,OAAAC,EACjB,CAUgB,gBACdG,EACAC,EACyB,OACzB,KAAM,CAACC,EAASC,CAAO,EAAI,KAAK,yBAC9BH,EACAC,CAAA,EAEF,GAAI,CAACC,EAAQ,OAASA,EAAQ,QAAUE,EAAAA,YAAa,CACnD,MAAMC,EAAQF,EAAQ,QAClBA,EAAQ,QAAQ,QAChBA,EAAQ,OACNG,EAAA,WAAWH,EAAQ,MAAM,EAAE,SAC3BI,EAAA,KAAK,WAAL,YAAAA,EAAe,QACrB,GAAIF,EACFH,EAAQ,MAAQG,MAEhB,OAAM,IAAIG,EAAoC,mCAElD,CACO,MAAA,CACL,IAAKpB,EAAA,EACL,SAAAqB,EACA,KAAM,CAACC,EAA8BR,CAAO,CAAC,EAC7C,GAAG,KAAK,wBAAwBC,EAAQ,OAAO,CAAA,CAEnD,CACF,EA5IEjB,EAAuB,MAAiC,CACtD,GAAIyB,EAAA,eAAA,EASNzB,EAAuB,aAA6B0B,EAAa,aAAA,WAtB5D,IAAMC,EAAN3B,EAkKA,SAASwB,EAA8B,CAC5C,MAAAL,EACA,QAAAV,CACF,EAA2B,CAClB,OAAAmB,EAAA,oBACL,CACE,CAAE,KAAM,UAAW,KAAM,OAAQ,EACjC,CAAE,KAAM,YAAa,KAAM,SAAU,CACvC,EACA,CAACT,EAAOV,CAAO,CAAA,CAEnB"}