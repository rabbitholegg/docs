{"version":3,"file":"utils.cjs","sources":["../src/utils.ts"],"sourcesContent":["import {\n  type Config,\n  type ReadContractParameters,\n  type WatchContractEventParameters,\n  type WriteContractParameters,\n  getAccount,\n  getClient,\n  waitForTransactionReceipt,\n} from '@wagmi/core';\nimport type { ExtractAbiEvent } from 'abitype';\nimport type {\n  Abi,\n  AbiEvent,\n  Address,\n  ContractEventName,\n  ContractFunctionName,\n  GetLogsParameters,\n  Hash,\n  Hex,\n  Log,\n  WaitForTransactionReceiptParameters,\n} from 'viem';\nimport { isHex, keccak256, slice, toHex } from 'viem';\nimport {\n  InvalidProtocolChainIdError,\n  NoConnectedChainIdError,\n  NoContractAddressUponReceiptError,\n} from './errors';\n\nexport type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;\n\n/**\n * Enum encapsulating all the different types of targets used in the Boost V2 Protocol.\n *\n * @export\n * @enum {number}\n */\nexport enum RegistryType {\n  ACTION = 0,\n  ALLOW_LIST = 1,\n  BUDGET = 2,\n  INCENTIVE = 3,\n  VALIDATOR = 4,\n}\n\n/**\n * Helper type that encapsulates common writeContract parameters without fields like `abi`, `args`, `functionName`, `address` that are expected to be provided the SDK.\n * See (writeContract)[https://viem.sh/docs/contract/writeContract]\n *\n * @export\n * @typedef {WriteParams}\n * @template {Abi} abi\n * @template {ContractFunctionName<abi>} functionName\n */\nexport type WriteParams<\n  abi extends Abi = Abi,\n  functionName extends ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = Partial<\n  Omit<\n    WriteContractParameters<abi, functionName>,\n    'address' | 'args' | 'functionName' | 'abi'\n  >\n>;\n\n/**\n * Helper type that encapsulates common readContract parameters without fields like `abi`, `args`, `functionName`, `address` that are expected to be provided the SDK.\n * See (readContract)[https://viem.sh/docs/contract/readContract]\n *\n * @export\n * @typedef {ReadParams}\n * @template {Abi} abi\n * @template {ContractFunctionName<abi>} functionName\n */\nexport type ReadParams<\n  abi extends Abi,\n  functionName extends ContractFunctionName<abi>,\n> = Partial<\n  Omit<\n    ReadContractParameters<abi, functionName>,\n    'address' | 'args' | 'functionName' | 'abi'\n  >\n>;\n\n/**\n * Helper type that encapsulates common `watchContractEvent` parameters without fields like `address`, and `abi` that are expected to be provided the SDK.\n * See (watchContractEvent)[https://wagmi.sh/core/api/actions/watchContractEvent]\n *\n * @export\n * @typedef {WatchParams}\n * @template {Abi} abi\n * @template {ContractEventName<abi> | undefined} [eventName=undefined]\n */\nexport type WatchParams<\n  abi extends Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n> = Partial<\n  Omit<WatchContractEventParameters<abi, eventName>, 'address' | 'abi'>\n>;\n\n/**\n * Helper type that encapsulates common `getLogs` parameters without fields like `address` that are expected to be provided the SDK.\n * See (getLogs)[https://viem.sh/docs/actions/public/getLogs#getlogs]\n *\n * @export\n * @typedef {GetLogsParams}\n * @template {Abi} abi\n * @template {ContractEventName<abi>} event\n * @template {ExtractAbiEvent<abi, event>} [abiEvent=ExtractAbiEvent<abi, event>]\n * @template {| readonly AbiEvent[]\n *     | readonly unknown[]\n *     | undefined} [abiEvents=abiEvent extends AbiEvent ? [abiEvent] : undefined]\n */\nexport type GetLogsParams<\n  abi extends Abi,\n  event extends ContractEventName<abi>,\n  abiEvent extends ExtractAbiEvent<abi, event> = ExtractAbiEvent<abi, event>,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n> = Partial<Omit<GetLogsParameters<abiEvent, abiEvents>, 'address'>> & {\n  chainId?: number | undefined;\n};\n\n/**\n * A generic `viem.Log` event with typed `args` support via a given `Abi` and `ContractEventName`\n *\n * @export\n * @typedef {GenericLog}\n * @template {Abi} abi\n * @template {ContractEventName<abi>} [event=ContractEventName<abi>]\n */\nexport type GenericLog<\n  abi extends Abi,\n  event extends ContractEventName<abi> = ContractEventName<abi>,\n> = Log<bigint, number, false, ExtractAbiEvent<abi, event>, false>;\n\n/**\n * Helper utility to convert a string to a `bytes4` type\n *\n * @export\n * @param {string} input\n * @returns {Hex}\n */\nexport function bytes4(input: string) {\n  return slice(isHex(input) ? keccak256(input) : keccak256(toHex(input)), 0, 4);\n}\n\n/**\n * Utility function to wait for a transaction receipt, and extract the contractAddress\n *\n * @export\n * @async\n * @param {WagmiConfig} config - [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)\n * @param {Promise<Hash>} hash - A transaction hash promise\n * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams] - @see {@link WaitForTransactionReceiptParameters}\n * @returns {Promise<Address>}\n * @throws {@link NoContractAddressUponReceiptError} if no `contractAddress` exists after the transaction has been received\n */\nexport async function getDeployedContractAddress(\n  config: Config,\n  hash: Promise<Hash>,\n  waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n) {\n  const receipt = await waitForTransactionReceipt(config, {\n    ...waitParams,\n    hash: await hash,\n  });\n  if (!receipt.contractAddress)\n    throw new NoContractAddressUponReceiptError(receipt);\n  return receipt.contractAddress;\n}\n\n/**\n * Utility type to encapsulate a transaction hash, and the simulated result prior to submitting the transaction.\n *\n * @export\n * @typedef {HashAndSimulatedResult}\n * @template [T=unknown]\n */\nexport type HashAndSimulatedResult<T = unknown> = { hash: Hash; result: T };\n\n/**\n * Helper function to wait for a transaction receipt given a hash promise.\n *\n * @export\n * @async\n * @template [Result=unknown]\n * @param {WagmiConfig} config\n * @param {Promise<HashAndSimulatedResult<Result>>} hashPromise\n * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]\n * @returns {Promise<Result>}\n */\nexport async function awaitResult<Result = unknown>(\n  config: Config,\n  hashPromise: Promise<HashAndSimulatedResult<Result>>,\n  waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n): Promise<Result> {\n  const { hash, result } = await hashPromise;\n  await waitForTransactionReceipt(config, {\n    ...waitParams,\n    hash,\n  });\n  return result;\n}\n\n/**\n * Given a wagmi config and a map of chain id's to addresses, determine an address/chainId combo that maps to the currently connected chain id, or throw a typed error.\n *\n * @export\n * @param {Config} config\n * @param {Record<string, Address>} addressByChainId\n * @param {number} desiredChainId\n * @returns {{ chainId: number, address: Address }}\n * @throws {@link InvalidProtocolChainIdError}\n */\nexport function assertValidAddressByChainId(\n  config: Config,\n  addressByChainId: Record<number, Address>,\n  desiredChainId?: number,\n): { chainId: number; address: Address } {\n  let chainId: number | undefined = undefined;\n  const wagmiAccount = getAccount(config);\n  // if manually providing a chain id for some contract operation, try to use it\n  if (desiredChainId !== undefined) {\n    if (addressByChainId[desiredChainId]) chainId = desiredChainId;\n  } else if (wagmiAccount.chainId !== undefined) {\n    // otherwise if we can get the current chain id off the connected account and it matches one of ours, use it\n    if (addressByChainId[wagmiAccount.chainId]) chainId = wagmiAccount.chainId;\n  }\n  // chainId is still undefined, try to get chain id off viem client\n  if (chainId === undefined) {\n    const client = getClient(config);\n    if (client?.chain.id && addressByChainId[client?.chain.id])\n      chainId = client.chain.id;\n  }\n  // if chainId is STILL undefined, use our default addresses\n  // TODO: update this when on prod network\n  if (chainId === undefined) chainId = Number(__DEFAULT_CHAIN_ID__);\n  if (!addressByChainId[chainId])\n    throw new InvalidProtocolChainIdError(\n      chainId,\n      Object.keys(addressByChainId).map(Number),\n    );\n  // biome-ignore lint/style/noNonNullAssertion: this type should be narrowed by the above statement but isn't?\n  return { chainId, address: addressByChainId[chainId]! };\n}\n"],"names":["RegistryType","bytes4","input","slice","isHex","keccak256","toHex","getDeployedContractAddress","config","hash","waitParams","receipt","waitForTransactionReceipt","NoContractAddressUponReceiptError","awaitResult","hashPromise","result","assertValidAddressByChainId","addressByChainId","desiredChainId","chainId","wagmiAccount","getAccount","client","getClient","InvalidProtocolChainIdError"],"mappings":"2JAqCY,IAAAA,GAAAA,IACVA,EAAAA,EAAA,OAAS,CAAT,EAAA,SACAA,EAAAA,EAAA,WAAa,CAAb,EAAA,aACAA,EAAAA,EAAA,OAAS,CAAT,EAAA,SACAA,EAAAA,EAAA,UAAY,CAAZ,EAAA,YACAA,EAAAA,EAAA,UAAY,CAAZ,EAAA,YALUA,IAAAA,GAAA,CAAA,CAAA,EA2GL,SAASC,EAAOC,EAAe,CACpC,OAAOC,EAAM,MAAAC,EAAA,MAAMF,CAAK,EAAIG,EAAU,UAAAH,CAAK,EAAIG,EAAA,UAAUC,EAAM,MAAAJ,CAAK,CAAC,EAAG,EAAG,CAAC,CAC9E,CAasB,eAAAK,EACpBC,EACAC,EACAC,EACA,CACM,MAAAC,EAAU,MAAMC,EAAA,0BAA0BJ,EAAQ,CACtD,GAAGE,EACH,KAAM,MAAMD,CAAA,CACb,EACD,GAAI,CAACE,EAAQ,gBACL,MAAA,IAAIE,EAAAA,kCAAkCF,CAAO,EACrD,OAAOA,EAAQ,eACjB,CAsBsB,eAAAG,EACpBN,EACAO,EACAL,EACiB,CACjB,KAAM,CAAE,KAAAD,EAAM,OAAAO,CAAO,EAAI,MAAMD,EAC/B,aAAMH,EAAAA,0BAA0BJ,EAAQ,CACtC,GAAGE,EACH,KAAAD,CAAA,CACD,EACMO,CACT,CAYgB,SAAAC,EACdT,EACAU,EACAC,EACuC,CACvC,IAAIC,EACE,MAAAC,EAAeC,aAAWd,CAAM,EAStC,GAPIW,IAAmB,OACjBD,EAAiBC,CAAc,IAAaC,EAAAD,GACvCE,EAAa,UAAY,QAE9BH,EAAiBG,EAAa,OAAO,MAAaA,EAAa,SAGjED,IAAY,OAAW,CACnB,MAAAG,EAASC,YAAUhB,CAAM,EAC3Be,GAAA,MAAAA,EAAQ,MAAM,IAAML,EAAiBK,GAAA,YAAAA,EAAQ,MAAM,EAAE,IACvDH,EAAUG,EAAO,MAAM,GAC3B,CAII,GADAH,IAAY,SAAqBA,EAAO,UACxC,CAACF,EAAiBE,CAAO,EAC3B,MAAM,IAAIK,EAAA,4BACRL,EACA,OAAO,KAAKF,CAAgB,EAAE,IAAI,MAAM,CAAA,EAG5C,MAAO,CAAE,QAAAE,EAAS,QAASF,EAAiBE,CAAO,CAAG,CACxD"}