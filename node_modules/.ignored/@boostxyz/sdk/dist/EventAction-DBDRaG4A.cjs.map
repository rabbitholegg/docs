{"version":3,"file":"EventAction-DBDRaG4A.cjs","sources":["../../../node_modules/.pnpm/ts-pattern@5.4.0/node_modules/ts-pattern/dist/index.js","../src/Actions/EventAction.ts"],"sourcesContent":["const t=Symbol.for(\"@ts-pattern/matcher\"),e=Symbol.for(\"@ts-pattern/isVariadic\"),n=\"@ts-pattern/anonymous-select-key\",r=t=>Boolean(t&&\"object\"==typeof t),i=e=>e&&!!e[t],s=(n,o,c)=>{if(i(n)){const e=n[t](),{matched:r,selections:i}=e.match(o);return r&&i&&Object.keys(i).forEach(t=>c(t,i[t])),r}if(r(n)){if(!r(o))return!1;if(Array.isArray(n)){if(!Array.isArray(o))return!1;let t=[],r=[],a=[];for(const s of n.keys()){const o=n[s];i(o)&&o[e]?a.push(o):a.length?r.push(o):t.push(o)}if(a.length){if(a.length>1)throw new Error(\"Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.\");if(o.length<t.length+r.length)return!1;const e=o.slice(0,t.length),n=0===r.length?[]:o.slice(-r.length),i=o.slice(t.length,0===r.length?Infinity:-r.length);return t.every((t,n)=>s(t,e[n],c))&&r.every((t,e)=>s(t,n[e],c))&&(0===a.length||s(a[0],i,c))}return n.length===o.length&&n.every((t,e)=>s(t,o[e],c))}return Reflect.ownKeys(n).every(e=>{const r=n[e];return(e in o||i(a=r)&&\"optional\"===a[t]().matcherType)&&s(r,o[e],c);var a})}return Object.is(o,n)},o=e=>{var n,s,a;return r(e)?i(e)?null!=(n=null==(s=(a=e[t]()).getSelectionKeys)?void 0:s.call(a))?n:[]:Array.isArray(e)?c(e,o):c(Object.values(e),o):[]},c=(t,e)=>t.reduce((t,n)=>t.concat(e(n)),[]);function a(...t){if(1===t.length){const[e]=t;return t=>s(e,t,()=>{})}if(2===t.length){const[e,n]=t;return s(e,n,()=>{})}throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${t.length}.`)}function u(t){return Object.assign(t,{optional:()=>h(t),and:e=>m(t,e),or:e=>d(t,e),select:e=>void 0===e?y(t):y(e,t)})}function l(t){return Object.assign((t=>Object.assign(t,{[Symbol.iterator](){let n=0;const r=[{value:Object.assign(t,{[e]:!0}),done:!1},{done:!0,value:void 0}];return{next:()=>{var t;return null!=(t=r[n++])?t:r.at(-1)}}}}))(t),{optional:()=>l(h(t)),select:e=>l(void 0===e?y(t):y(e,t))})}function h(e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return void 0===t?(o(e).forEach(t=>r(t,void 0)),{matched:!0,selections:n}):{matched:s(e,t,r),selections:n}},getSelectionKeys:()=>o(e),matcherType:\"optional\"})})}const f=(t,e)=>{for(const n of t)if(!e(n))return!1;return!0},g=(t,e)=>{for(const[n,r]of t.entries())if(!e(r,n))return!1;return!0};function m(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return{matched:e.every(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:\"and\"})})}function d(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return c(e,o).forEach(t=>r(t,void 0)),{matched:e.some(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:\"or\"})})}function p(e){return{[t]:()=>({match:t=>({matched:Boolean(e(t))})})}}function y(...e){const r=\"string\"==typeof e[0]?e[0]:void 0,i=2===e.length?e[1]:\"string\"==typeof e[0]?void 0:e[0];return u({[t]:()=>({match:t=>{let e={[null!=r?r:n]:t};return{matched:void 0===i||s(i,t,(t,n)=>{e[t]=n}),selections:e}},getSelectionKeys:()=>[null!=r?r:n].concat(void 0===i?[]:o(i))})})}function v(t){return\"number\"==typeof t}function b(t){return\"string\"==typeof t}function w(t){return\"bigint\"==typeof t}const S=u(p(function(t){return!0})),O=S,j=t=>Object.assign(u(t),{startsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.startsWith(n)))));var n},endsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.endsWith(n)))));var n},minLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length>=t))(e))),length:e=>j(m(t,(t=>p(e=>b(e)&&e.length===t))(e))),maxLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length<=t))(e))),includes:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.includes(n)))));var n},regex:e=>{return j(m(t,(n=e,p(t=>b(t)&&Boolean(t.match(n))))));var n}}),K=j(p(b)),x=t=>Object.assign(u(t),{between:(e,n)=>x(m(t,((t,e)=>p(n=>v(n)&&t<=n&&e>=n))(e,n))),lt:e=>x(m(t,(t=>p(e=>v(e)&&e<t))(e))),gt:e=>x(m(t,(t=>p(e=>v(e)&&e>t))(e))),lte:e=>x(m(t,(t=>p(e=>v(e)&&e<=t))(e))),gte:e=>x(m(t,(t=>p(e=>v(e)&&e>=t))(e))),int:()=>x(m(t,p(t=>v(t)&&Number.isInteger(t)))),finite:()=>x(m(t,p(t=>v(t)&&Number.isFinite(t)))),positive:()=>x(m(t,p(t=>v(t)&&t>0))),negative:()=>x(m(t,p(t=>v(t)&&t<0)))}),E=x(p(v)),A=t=>Object.assign(u(t),{between:(e,n)=>A(m(t,((t,e)=>p(n=>w(n)&&t<=n&&e>=n))(e,n))),lt:e=>A(m(t,(t=>p(e=>w(e)&&e<t))(e))),gt:e=>A(m(t,(t=>p(e=>w(e)&&e>t))(e))),lte:e=>A(m(t,(t=>p(e=>w(e)&&e<=t))(e))),gte:e=>A(m(t,(t=>p(e=>w(e)&&e>=t))(e))),positive:()=>A(m(t,p(t=>w(t)&&t>0))),negative:()=>A(m(t,p(t=>w(t)&&t<0)))}),P=A(p(w)),T=u(p(function(t){return\"boolean\"==typeof t})),B=u(p(function(t){return\"symbol\"==typeof t})),_=u(p(function(t){return null==t})),k=u(p(function(t){return null!=t}));var N={__proto__:null,matcher:t,optional:h,array:function(...e){return l({[t]:()=>({match:t=>{if(!Array.isArray(t))return{matched:!1};if(0===e.length)return{matched:!0};const n=e[0];let r={};if(0===t.length)return o(n).forEach(t=>{r[t]=[]}),{matched:!0,selections:r};const i=(t,e)=>{r[t]=(r[t]||[]).concat([e])};return{matched:t.every(t=>s(n,t,i)),selections:r}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},set:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Set))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};if(0===e.length)return{matched:!0};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])},i=e[0];return{matched:f(t,t=>s(i,t,r)),selections:n}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},map:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Map))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])};if(0===e.length)return{matched:!0};var i;if(1===e.length)throw new Error(`\\`P.map\\` wasn't given enough arguments. Expected (key, value), received ${null==(i=e[0])?void 0:i.toString()}`);const[o,c]=e;return{matched:g(t,(t,e)=>{const n=s(o,e,r),i=s(c,t,r);return n&&i}),selections:n}},getSelectionKeys:()=>0===e.length?[]:[...o(e[0]),...o(e[1])]})})},intersection:m,union:d,not:function(e){return u({[t]:()=>({match:t=>({matched:!s(e,t,()=>{})}),getSelectionKeys:()=>[],matcherType:\"not\"})})},when:p,select:y,any:S,_:O,string:K,number:E,bigint:P,boolean:T,symbol:B,nullish:_,nonNullable:k,instanceOf:function(t){return u(p(function(t){return e=>e instanceof t}(t)))},shape:function(t){return u(p(a(t)))}};class W extends Error{constructor(t){let e;try{e=JSON.stringify(t)}catch(n){e=t}super(`Pattern matching error: no pattern matches value ${e}`),this.input=void 0,this.input=t}}const $={matched:!1,value:void 0};function z(t){return new I(t,$)}class I{constructor(t,e){this.input=void 0,this.state=void 0,this.input=t,this.state=e}with(...t){if(this.state.matched)return this;const e=t[t.length-1],r=[t[0]];let i;3===t.length&&\"function\"==typeof t[1]?i=t[1]:t.length>2&&r.push(...t.slice(1,t.length-1));let o=!1,c={};const a=(t,e)=>{o=!0,c[t]=e},u=!r.some(t=>s(t,this.input,a))||i&&!Boolean(i(this.input))?$:{matched:!0,value:e(o?n in c?c[n]:c:this.input,this.input)};return new I(this.input,u)}when(t,e){if(this.state.matched)return this;const n=Boolean(t(this.input));return new I(this.input,n?{matched:!0,value:e(this.input,this.input)}:$)}otherwise(t){return this.state.matched?this.state.value:t(this.input)}exhaustive(){if(this.state.matched)return this.state.value;throw new W(this.input)}run(){return this.exhaustive()}returnType(){return this}}export{W as NonExhaustiveError,N as P,N as Pattern,a as isMatching,z as match};\n//# sourceMappingURL=index.js.map\n","import {\n  eventActionAbi,\n  readEventActionGetActionClaimant,\n  readEventActionGetActionSteps,\n  simulateEventActionExecute,\n  writeEventActionExecute,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/actions/EventAction.sol/EventAction.json';\nimport events from '@boostxyz/signatures/events';\nimport functions from '@boostxyz/signatures/functions';\nimport { match } from 'ts-pattern';\nimport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  type Address,\n  type ContractEventName,\n  type ContractFunctionName,\n  type GetLogsReturnType,\n  type GetTransactionParameters,\n  type Hex,\n  type Log,\n  type PublicClient,\n  type Transaction,\n  decodeEventLog,\n  decodeFunctionData,\n  encodeAbiParameters,\n  fromHex,\n  isAddressEqual,\n} from 'viem';\nimport { EventAction as EventActionBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport {\n  DecodedArgsMalformedError,\n  FieldValueNotComparableError,\n  FieldValueUndefinedError,\n  FunctionDataDecodeError,\n  InvalidNumericalCriteriaError,\n  NoEventActionStepsProvidedError,\n  TooManyEventActionStepsProvidedError,\n  UnparseableAbiParamError,\n  UnrecognizedFilterTypeError,\n  ValidationAbiMissingError,\n  ValidationLogsMissingError,\n} from '../errors';\nimport {\n  type GetLogsParams,\n  type Overwrite,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\n/*\n * Action Event Payloads\n */\n\n/**\n * Filter types used to determine how criteria are evaluated.\n *\n * @export\n * @enum {number}\n */\nexport enum FilterType {\n  EQUAL = 0,\n  NOT_EQUAL = 1,\n  GREATER_THAN = 2,\n  LESS_THAN = 3,\n  CONTAINS = 4,\n  REGEX = 5,\n}\n\n/**\n * The primitive types supported for filtering.\n *\n * @export\n * @enum {number}\n */\nexport enum PrimitiveType {\n  UINT = 0,\n  ADDRESS = 1,\n  BYTES = 2,\n  STRING = 3,\n}\n\n/**\n * Object representation of a `Criteria` struct used in event actions.\n *\n * @export\n * @interface Criteria\n * @typedef {Criteria}\n */\nexport interface Criteria {\n  /**\n   * The filter type used in this criteria.\n   *\n   * @type {FilterType}\n   */\n  filterType: FilterType;\n  /**\n   * The primitive type of the field being filtered.\n   *\n   * @type {PrimitiveType}\n   */\n  fieldType: PrimitiveType;\n  /**\n   * The index in the logs argument array where the field is located.\n   *\n   * @type {number}\n   */\n  fieldIndex: number;\n  /**\n   * The filter data used for complex filtering.\n   *\n   * @type {Hex}\n   */\n  filterData: Hex;\n}\n\n/**\n * Whether a given signature is an event or function\n *\n * @export\n * @enum {number}\n */\nexport enum SignatureType {\n  EVENT = 0,\n  FUNC = 1,\n}\n\n/**\n *  The payload describing how claimants are identified\n *\n * @export\n * @interface ActionClaimant\n * @typedef {ActionClaimant}\n */\nexport interface ActionClaimant {\n  /**\n   * Whether claimaint is inferred from event or function\n   *\n   * @type {SignatureType}\n   */\n  signatureType: SignatureType;\n  /**\n   * The 4 byte signature of the event or function\n   *\n   * @type {Hex}\n   */\n  signature: Hex;\n  /**\n   * The index corresponding to claimant.\n   *\n   * @type {number}\n   */\n  fieldIndex: number;\n  /**\n   * The address of the target contract\n   *\n   * @type {Address}\n   */\n  targetContract: Address;\n  /**\n   * The chain id of the target contract.\n   * @type {number}\n   */\n  chainid: number;\n}\n\n/**\n * Object representation of an `ActionStep` struct used in event actions.\n *\n * @export\n * @interface ActionStep\n * @typedef {ActionStep}\n */\nexport interface ActionStep {\n  /**\n   * The signature of the event.\n   *\n   * @type {Hex}\n   */\n  signature: Hex;\n  /**\n   * Whether claimaint is inferred from event or function\n   *\n   * @type {SignatureType}\n   */\n  signatureType: SignatureType;\n  /**\n   * The type of action being performed.\n   *\n   * @type {number}\n   */\n  actionType?: number;\n  /**\n   * The address of the target contract.\n   *\n   * @type {Address}\n   */\n  targetContract: Address;\n  /**\n   * The chain id of the target contract.\n   * @type {number}\n   */\n  chainid: number;\n  /**\n   * The criteria used for this action step.\n   *\n   * @type {Criteria}\n   */\n  actionParameter: Criteria;\n}\n\n/**\n * Parameters for validating an action step.\n *\n * @typedef {Object} ValidateActionStepParams\n * @property {Record<Hex, AbiEvent>} [knownEvents] - Optional record of known events, keyed by their hex signature.\n * @property {AbiEvent} [event] - Optional ABI event definition.\n * @property {EventLogs} [logs] - Event logs to validate against. Required if 'hash' is not provided.\n * @property {Hex} [hash] - Transaction hash to validate against. Required if 'logs' is not provided.\n * @property {number} [chainId] - Chain ID for the transaction. Required if 'hash' is provided.\n */\nexport type ValidateActionStepParams = {\n  knownEvents?: Record<Hex, AbiEvent>;\n  event?: AbiEvent;\n} & ({ logs: EventLogs } | { hash: Hex; chainId: number });\n\n/**\n * You can either supply a simplified version of the payload, or one that explicitly declares action steps.\n *\n * @export\n * @typedef {EventActionPayload}\n */\nexport type EventActionPayload =\n  | EventActionPayloadSimple\n  | EventActionPayloadRaw;\n\nexport interface EventActionPayloadSimple {\n  /**\n   *  The payload describing how claimants are identified\n   *\n   * @type {ActionClaimant}\n   */\n  actionClaimant: ActionClaimant;\n\n  /**\n   * Up to 4 action steps.\n   * If you supply less than 4, then the last step will be reused to satisfy the EventAction.InitPayload\n   * Any more than 4 will throw an error.\n   *\n   * @type {ActionStep[]}\n   */\n  actionSteps: ActionStep[];\n}\n\nexport type ActionStepTuple = [ActionStep, ActionStep, ActionStep, ActionStep];\n\n/**\n * Typeguard to determine if a user is supplying a simple or raw EventActionPayload\n *\n * @param {*} opts\n * @returns {opts is EventActionPayloadSimple}\n */\nexport function isEventActionPayloadSimple(\n  opts: EventActionPayload,\n): opts is EventActionPayloadSimple {\n  return Array.isArray((opts as EventActionPayloadSimple).actionSteps);\n}\n\n/**\n * Object representation of an `InitPayload` struct used to initialize event actions.\n *\n * @export\n * @interface EventActionPayloadRaw\n * @typedef {EventActionPayloadRaw}\n */\nexport interface EventActionPayloadRaw {\n  /**\n   *  The payload describing how claimants are identified\n   *\n   * @type {ActionClaimant}\n   */\n  actionClaimant: ActionClaimant;\n  /**\n   * The first action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepOne: ActionStep;\n  /**\n   * The second action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepTwo: ActionStep;\n  /**\n   * The third action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepThree: ActionStep;\n  /**\n   * The fourth action step.\n   *\n   * @type {ActionStep}\n   */\n  actionStepFour: ActionStep;\n}\n\n/**\n * Array of event logs to pass into TxParams\n * @export\n * @typedef {EventLogs}\n */\nexport type EventLogs = GetLogsReturnType<AbiEvent, AbiEvent[], true>;\n\n/**\n * Getter params from the event action contract\n *\n * @export\n * @typedef {ReadEventActionParams}\n * @param {fnName} fnName - The getter function name\n */\nexport type ReadEventActionParams<\n  fnName extends ContractFunctionName<typeof eventActionAbi, 'pure' | 'view'>,\n> = ReadParams<typeof eventActionAbi, fnName>;\n\n/**\n * A generic event action\n *\n * @export\n * @class EventAction\n * @typedef {EventAction}\n * @extends {DeployableTarget<EventActionPayload>}\n */\nexport class EventAction extends DeployableTarget<\n  EventActionPayload,\n  typeof eventActionAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = eventActionAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(EventActionBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.ACTION;\n\n  /**\n   * Gets a specific action event by index\n   *\n   * @public\n   * @async\n   * @param {number} index The index of the action event to retrieve\n   * @param {?ReadEventActionParams<'getActionStep'>} [params]\n   * @returns {Promise<ActionStep>}\n   */\n  public async getActionStep(\n    index: number,\n    params?: ReadEventActionParams<'getActionStep'>,\n  ) {\n    const steps = await this.getActionSteps(params);\n    return steps.at(index);\n  }\n\n  /**\n   * Gets all action events\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionSteps'>} [params]\n   * @returns {Promise<ActionStep[]>}\n   */\n  public async getActionSteps(\n    params?: ReadEventActionParams<'getActionSteps'>,\n  ) {\n    const steps = (await readEventActionGetActionSteps(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    })) as RawActionStep[];\n    return _dedupeActionSteps(steps.map(_fromRawActionStep));\n  }\n\n  /**\n   * Gets the count of action events\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionStepsCount'>} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async getActionStepsCount(\n    params?: ReadEventActionParams<'getActionStepsCount'>,\n  ) {\n    const steps = await this.getActionSteps(params);\n    return steps.length;\n  }\n\n  /**\n   * Retrieves the payload describing how claimants can be identified from logs or function calls.\n   *\n   * @public\n   * @async\n   * @param {?ReadEventActionParams<'getActionClaimant'>} [params]\n   * @returns {Promise<ActionClaimant>}\n   */\n  public async getActionClaimant(\n    params?: ReadEventActionParams<'getActionClaimant'>,\n  ) {\n    const result = (await readEventActionGetActionClaimant(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      ...params,\n    })) as RawActionClaimant;\n    return _fromRawActionStep(result);\n  }\n\n  /**\n   * Executes a prepared event action\n   *\n   * @public\n   * @async\n   * @param {Hex} data\n   * @param {?WriteParams} [params]\n   * @returns {Promise<readonly [boolean, `0x${string}`]>}\n   */\n  public async execute(\n    data: Hex,\n    params?: WriteParams<typeof eventActionAbi, 'execute'>,\n  ) {\n    return await this.awaitResult(this.executeRaw(data, params));\n  }\n\n  /**\n   * Executes a prepared event action\n   *\n   * @public\n   * @async\n   * @param {Hex} data\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: readonly [boolean, `0x${string}`]; }>}\n   */\n  public async executeRaw(\n    data: Hex,\n    params?: WriteParams<typeof eventActionAbi, 'execute'>,\n  ) {\n    const { request, result } = await simulateEventActionExecute(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [data],\n    });\n    const hash = await writeEventActionExecute(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Retrieves action steps, and uses them to validate against, and optionally fetch logs that match the step's signature.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of fetched with the configured client.\n   *\n   * @public\n   * @async\n   * @param ValidateActionStepParams params\n   * @returns {Promise<boolean>}\n   */\n  public async validateActionSteps(params: ValidateActionStepParams) {\n    const actionSteps = await this.getActionSteps();\n    for (const actionStep of actionSteps) {\n      if (!(await this.isActionStepValid(actionStep, params))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Validates a single action step with a given criteria against logs or function calls.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.\n   * For functions a hash is required.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step to validate. Can be a function of event step.\n   * @param {ValidateActionStepParams} params - Additional parameters for validation, including hash, known events, logs, and chain ID.\n   * @returns {Promise<boolean>}\n   */\n  public async isActionStepValid(\n    actionStep: ActionStep,\n    params: ValidateActionStepParams,\n  ) {\n    if (actionStep.signatureType === SignatureType.EVENT) {\n      const signature = actionStep.signature;\n      let event: AbiEvent;\n      // Lookup ABI based on event signature\n      if (params.knownEvents) {\n        event = params.knownEvents?.[signature] as AbiEvent;\n      } else {\n        event = (events.abi as Record<Hex, AbiEvent>)[signature] as AbiEvent;\n      }\n\n      if (!event) {\n        throw new ValidationAbiMissingError(signature);\n      }\n\n      if (this.isArraylikeIndexed(actionStep, event)) {\n        // If the field is indexed, we can't filter on it\n        throw new UnparseableAbiParamError(\n          actionStep.actionParameter.fieldIndex,\n          event,\n        );\n      }\n\n      params.event = event;\n\n      // Use the provided logs, no need to fetch receipt\n      if ('logs' in params) {\n        return this.isActionEventValid(actionStep, {\n          ...params,\n        });\n      }\n\n      const client = this._config.getClient({\n        chainId: params.chainId,\n      }) as PublicClient;\n      const receipt = await client.getTransactionReceipt({\n        hash: params.hash,\n      });\n      const decodedLogs = receipt.logs.map((log) => {\n        const { eventName, args } = decodeEventLog({\n          abi: [event],\n          data: log.data,\n          topics: log.topics,\n        });\n\n        return { ...log, eventName, args };\n      });\n\n      return this.isActionEventValid(actionStep, {\n        logs: decodedLogs,\n        ...params,\n      });\n    }\n    if (actionStep.signatureType === SignatureType.FUNC) {\n      if ('hash' in params && 'chainId' in params) {\n        const client = this._config.getClient({\n          chainId: params.chainId,\n        }) as PublicClient;\n        const transaction = await client.getTransaction({\n          hash: params.hash,\n        });\n        return this.isActionFunctionValid(actionStep, transaction);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Validates a single action event with a given criteria against logs.\n   * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step containing the event to validate.\n   * @param {ValidateActionStepParams} params - Additional parameters for validation, including known events and logs\n   * @returns {Promise<boolean>} Resolves to true if the action event is valid, throws if input is invalid, otherwise false.\n   */\n  public isActionEventValid(\n    actionStep: ActionStep,\n    params: ValidateActionStepParams,\n  ) {\n    if (!('logs' in params)) {\n      throw new ValidationLogsMissingError();\n    }\n    const criteria = actionStep.actionParameter;\n    const logs = params.logs;\n    if (!logs.length) return false;\n    for (let log of logs) {\n      if (this.validateLogAgainstCriteria(criteria, log)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Validates a single action function with a given criteria against the transaction input.\n   *\n   * @public\n   * @async\n   * @param {ActionStep} actionStep - The action step containing the function to validate.\n   * @param {Transaction} transaction - The transaction that will be validated against.\n   * @returns {Promise<boolean>} Resolves to true if the action function is valid, throws if the inputs are invalid, otherwise false.\n   */\n  public isActionFunctionValid(\n    actionStep: ActionStep,\n    transaction: Transaction,\n  ) {\n    const criteria = actionStep.actionParameter;\n    let signature = actionStep.signature;\n\n    const func = (functions.abi as Record<Hex, AbiFunction>)[\n      signature\n    ] as AbiFunction;\n    if (!func) {\n      throw new ValidationAbiMissingError(signature);\n    }\n\n    let decodedData;\n    try {\n      decodedData = decodeFunctionData({\n        abi: [func],\n        data: transaction.input,\n      });\n    } catch (e) {\n      throw new FunctionDataDecodeError([func], e as Error);\n    }\n\n    // Validate the criteria against decoded arguments using fieldIndex\n    const decodedArgs = decodedData.args;\n\n    if (!decodedArgs || !decodedData) return false;\n\n    if (\n      !this.validateFunctionAgainstCriteria(\n        criteria,\n        decodedArgs as (string | bigint)[],\n      )\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Validates a field against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {string | bigint | Hex} fieldValue - The field value to validate.\n   * @param {Object} input - Additional context for validation.\n   * @param {EventLogs[0]} [input.log] - The event log, if validating an event.\n   * @param {readonly (string | bigint)[]} [input.decodedArgs] - The decoded function arguments, if validating a function call.\n   * @returns {Promise<boolean>} - Returns true if the field passes the criteria, false otherwise.\n   */\n  public validateFieldAgainstCriteria(\n    criteria: Criteria,\n    fieldValue: string | bigint | Hex,\n    input:\n      | { log: EventLogs[0] }\n      | { decodedArgs: readonly (string | bigint)[] },\n  ): boolean {\n    // Type narrow based on criteria.filterType\n    switch (criteria.filterType) {\n      case FilterType.EQUAL:\n        return match(criteria.fieldType)\n          .with(PrimitiveType.ADDRESS, () =>\n            isAddressEqual(criteria.filterData, fieldValue as Address),\n          )\n          .with(\n            PrimitiveType.UINT,\n            () => BigInt(fieldValue) === BigInt(criteria.filterData),\n          )\n          .with(\n            PrimitiveType.STRING,\n            () => fieldValue === fromHex(criteria.filterData, 'string'),\n          )\n          .otherwise(() => fieldValue === criteria.filterData);\n\n      case FilterType.NOT_EQUAL:\n        return match(criteria.fieldType)\n          .with(\n            PrimitiveType.ADDRESS,\n            () => !isAddressEqual(criteria.filterData, fieldValue as Address),\n          )\n          .with(\n            PrimitiveType.UINT,\n            () => BigInt(fieldValue) !== BigInt(criteria.filterData),\n          )\n          .with(\n            PrimitiveType.STRING,\n            () => fieldValue !== fromHex(criteria.filterData, 'string'),\n          )\n          .otherwise(() => fieldValue !== criteria.filterData);\n\n      case FilterType.GREATER_THAN:\n        if (criteria.fieldType === PrimitiveType.UINT) {\n          return BigInt(fieldValue) > BigInt(criteria.filterData);\n        }\n        throw new InvalidNumericalCriteriaError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.LESS_THAN:\n        if (criteria.fieldType === PrimitiveType.UINT) {\n          return BigInt(fieldValue) < BigInt(criteria.filterData);\n        }\n        throw new InvalidNumericalCriteriaError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.CONTAINS:\n        if (\n          criteria.fieldType === PrimitiveType.BYTES ||\n          criteria.fieldType === PrimitiveType.STRING\n        ) {\n          let substring;\n          if (criteria.fieldType === PrimitiveType.STRING) {\n            substring = fromHex(criteria.filterData, 'string');\n          } else {\n            // truncate the `0x` prefix\n            substring = criteria.filterData.slice(2);\n          }\n          return (fieldValue as string).includes(substring);\n        }\n        throw new FieldValueNotComparableError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n\n      case FilterType.REGEX:\n        if (typeof fieldValue !== 'string') {\n          throw new FieldValueNotComparableError({\n            ...input,\n            criteria,\n            fieldValue,\n          });\n        }\n\n        if (criteria.fieldType === PrimitiveType.STRING) {\n          // fieldValue is decoded by the ABI\n          const regexString = fromHex(criteria.filterData, 'string');\n          return new RegExp(regexString).test(fieldValue);\n        }\n\n      default:\n        throw new UnrecognizedFilterTypeError({\n          ...input,\n          criteria,\n          fieldValue,\n        });\n    }\n  }\n\n  /**\n   * Validates a {@link Log} against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {Log} log - The Viem event log.\n   * @returns {Promise<boolean>} - Returns true if the log passes the criteria, false otherwise.\n   */\n  public validateLogAgainstCriteria(\n    criteria: Criteria,\n    log: EventLogs[0],\n  ): boolean {\n    if (!Array.isArray(log.args) || log.args.length <= criteria.fieldIndex) {\n      throw new DecodedArgsMalformedError({\n        log,\n        criteria,\n        fieldValue: undefined,\n      });\n    }\n\n    const fieldValue = log.args.at(criteria.fieldIndex);\n    if (fieldValue === undefined) {\n      throw new FieldValueUndefinedError({ log, criteria, fieldValue });\n    }\n    return this.validateFieldAgainstCriteria(criteria, fieldValue, { log });\n  }\n\n  /**\n   * Validates a function's decoded arguments against a given criteria.\n   *\n   * @param {Criteria} criteria - The criteria to validate against.\n   * @param {unknown[]} decodedArgs - The decoded arguments of the function call.\n   * @returns {Promise<boolean>} - Returns true if the decoded argument passes the criteria, false otherwise.\n   */\n  public validateFunctionAgainstCriteria(\n    criteria: Criteria,\n    decodedArgs: readonly (string | bigint)[],\n  ): boolean {\n    const fieldValue = decodedArgs[criteria.fieldIndex];\n    if (fieldValue === undefined) {\n      throw new FieldValueUndefinedError({\n        criteria,\n        fieldValue,\n      });\n    }\n    return this.validateFieldAgainstCriteria(criteria, fieldValue, {\n      decodedArgs,\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?EventActionPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: EventActionPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    let rawPayload: EventActionPayloadRaw;\n    if (isEventActionPayloadSimple(payload)) {\n      // filter out any falsy potential values\n      let tmpSteps: ActionStep[] = payload.actionSteps.filter((step) => !!step);\n      if (tmpSteps.length === 0) {\n        throw new NoEventActionStepsProvidedError();\n      }\n      if (tmpSteps.length > 4) {\n        throw new TooManyEventActionStepsProvidedError();\n      }\n      let steps: ActionStepTuple = Array.from({ length: 4 }, (_, i) => {\n        // use either the provided step at the given index, or reuse the previous step\n        // should aways exist\n        return tmpSteps.at(i) || tmpSteps.at(-1);\n      }) as ActionStepTuple;\n      rawPayload = {\n        actionClaimant: payload.actionClaimant,\n        actionStepOne: steps[0],\n        actionStepTwo: steps[1],\n        actionStepThree: steps[2],\n        actionStepFour: steps[3],\n      };\n    } else {\n      rawPayload = payload;\n    }\n    return {\n      abi: eventActionAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareEventActionPayload(rawPayload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n\n  public isArraylikeIndexed(step: ActionStep, event: AbiEvent) {\n    if (\n      (step.actionParameter.fieldType === PrimitiveType.STRING ||\n        step.actionParameter.fieldType === PrimitiveType.BYTES) &&\n      event.inputs[step.actionParameter.fieldIndex]?.indexed\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\nfunction _dedupeActionSteps(_steps: ActionStep[]): ActionStep[] {\n  const steps: ActionStep[] = [],\n    signatures: Record<string, boolean> = {};\n  for (let step of _steps) {\n    const signature = JSON.stringify(step);\n    if (signatures[signature]) continue;\n    steps.push(step);\n    signatures[signature] = true;\n  }\n  return steps;\n}\ntype RawActionStep = Overwrite<ActionStep, { chainid: bigint }>;\ntype RawActionClaimant = Overwrite<ActionClaimant, { chainid: bigint }>;\n\nfunction _toRawActionStep<T extends ActionStep | ActionClaimant>(obj: T) {\n  return {\n    ...obj,\n    chainid: BigInt(obj.chainid),\n  };\n}\n\nfunction _fromRawActionStep<T extends RawActionStep | RawActionClaimant>(\n  obj: T,\n) {\n  if (obj.chainid > BigInt(Number.MAX_SAFE_INTEGER)) {\n    throw new Error('Chain ID exceeds max safe integer');\n  }\n\n  return {\n    ...obj,\n    chainid: Number(obj.chainid),\n  };\n}\n\n/**\n * Typeguard to determine if a user is supplying a simple or raw EventActionPayload\n *\n * @param {*} opts\n * @returns {opts is EventActionPayloadSimple}\n */\nfunction _isEventActionPayloadSimple(\n  opts: EventActionPayload,\n): opts is EventActionPayloadSimple {\n  return Array.isArray((opts as EventActionPayloadSimple).actionSteps);\n}\n\n/**\n * Function to properly encode an event action payload.\n *\n * @param {InitPayload} param0\n * @param {ActionStep} param0.actionStepOne - The first action step to initialize.\n * @param {ActionStep} param0.actionStepTwo - The second action step to initialize.\n * @param {ActionStep} param0.actionStepThree - The third action step to initialize.\n * @param {ActionStep} param0.actionStepFour - The fourth action step to initialize.\n * @returns {Hex}\n */\nexport function prepareEventActionPayload({\n  actionClaimant,\n  actionStepOne,\n  actionStepTwo,\n  actionStepThree,\n  actionStepFour,\n}: EventActionPayloadRaw) {\n  // note chainIds are technically uint256 but viem treats them (safely) as numbers,\n  // so we encode them as uint32 here to avoid downcast issues\n  return encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'initPayload',\n        components: [\n          {\n            type: 'tuple',\n            name: 'actionClaimant',\n            components: [\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'fieldIndex' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepOne',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepTwo',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepThree',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            name: 'actionStepFour',\n            components: [\n              { type: 'bytes32', name: 'signature' },\n              { type: 'uint8', name: 'signatureType' },\n              { type: 'uint8', name: 'actionType' },\n              { type: 'address', name: 'targetContract' },\n              { type: 'uint256', name: 'chainid' },\n              {\n                type: 'tuple',\n                name: 'actionParameter',\n                components: [\n                  { type: 'uint8', name: 'filterType' },\n                  { type: 'uint8', name: 'fieldType' },\n                  { type: 'uint8', name: 'fieldIndex' },\n                  { type: 'bytes', name: 'filterData' },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    [\n      {\n        actionClaimant: _toRawActionStep(actionClaimant),\n        actionStepOne: {\n          ..._toRawActionStep(actionStepOne),\n          actionType: actionStepOne.actionType || 0,\n        },\n        actionStepTwo: {\n          ..._toRawActionStep(actionStepTwo),\n          actionType: actionStepTwo.actionType || 0,\n        },\n        actionStepThree: {\n          ..._toRawActionStep(actionStepThree),\n          actionType: actionStepThree.actionType || 0,\n        },\n        actionStepFour: {\n          ..._toRawActionStep(actionStepFour),\n          actionType: actionStepFour.actionType || 0,\n        },\n      },\n    ],\n  );\n}\n"],"names":["t","e","n","r","i","s","o","c","a","h","m","d","y","p","v","b","w","j","x","W","$","z","I","u","FilterType","PrimitiveType","SignatureType","isEventActionPayloadSimple","opts","_EventAction","DeployableTarget","eventActionAbi","index","params","steps","readEventActionGetActionSteps","_dedupeActionSteps","_fromRawActionStep","result","readEventActionGetActionClaimant","data","request","simulateEventActionExecute","writeEventActionExecute","actionSteps","actionStep","signature","event","_a","events","ValidationAbiMissingError","UnparseableAbiParamError","decodedLogs","log","eventName","args","decodeEventLog","transaction","ValidationLogsMissingError","criteria","logs","func","functions","decodedData","decodeFunctionData","FunctionDataDecodeError","decodedArgs","fieldValue","input","match","isAddressEqual","fromHex","InvalidNumericalCriteriaError","substring","FieldValueNotComparableError","regexString","UnrecognizedFilterTypeError","DecodedArgsMalformedError","FieldValueUndefinedError","_payload","_options","payload","options","rawPayload","tmpSteps","step","NoEventActionStepsProvidedError","TooManyEventActionStepsProvidedError","_","bytecode","prepareEventActionPayload","EventActionBases","RegistryType","EventAction","_steps","signatures","_toRawActionStep","obj","actionClaimant","actionStepOne","actionStepTwo","actionStepThree","actionStepFour","encodeAbiParameters"],"mappings":"k80BAAMA,EAAE,OAAO,IAAI,qBAAqB,EAAEC,GAAE,OAAO,IAAI,wBAAwB,EAAEC,EAAE,mCAAmCC,EAAE,GAAG,GAAQ,GAAa,OAAO,GAAjB,UAAoBC,EAAEH,GAAGA,GAAG,CAAC,CAACA,EAAED,CAAC,EAAEK,EAAE,CAACH,EAAEI,EAAEC,IAAI,CAAC,GAAGH,EAAEF,CAAC,EAAE,CAAC,MAAMD,EAAEC,EAAEF,CAAC,EAAG,EAAC,CAAC,QAAQG,EAAE,WAAWC,CAAC,EAAEH,EAAE,MAAMK,CAAC,EAAE,OAAOH,GAAGC,GAAG,OAAO,KAAKA,CAAC,EAAE,QAAQJ,GAAGO,EAAEP,EAAEI,EAAEJ,CAAC,CAAC,CAAC,EAAEG,CAAC,CAAC,GAAGA,EAAED,CAAC,EAAE,CAAC,GAAG,CAACC,EAAEG,CAAC,EAAE,MAAM,GAAG,GAAG,MAAM,QAAQJ,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,QAAQI,CAAC,EAAE,MAAM,GAAG,IAAIN,EAAE,CAAA,EAAGG,EAAE,CAAE,EAACK,EAAE,CAAA,EAAG,UAAU,KAAKN,EAAE,KAAM,EAAC,CAAC,MAAMI,EAAEJ,EAAE,CAAC,EAAEE,EAAEE,CAAC,GAAGA,EAAEL,EAAC,EAAEO,EAAE,KAAKF,CAAC,EAAEE,EAAE,OAAOL,EAAE,KAAKG,CAAC,EAAEN,EAAE,KAAKM,CAAC,CAAC,CAAC,GAAGE,EAAE,OAAO,CAAC,GAAGA,EAAE,OAAO,EAAE,MAAM,IAAI,MAAM,0FAA0F,EAAE,GAAGF,EAAE,OAAON,EAAE,OAAOG,EAAE,OAAO,MAAM,GAAG,MAAMF,EAAEK,EAAE,MAAM,EAAEN,EAAE,MAAM,EAAEE,EAAMC,EAAE,SAAN,EAAa,CAAE,EAACG,EAAE,MAAM,CAACH,EAAE,MAAM,EAAEC,EAAEE,EAAE,MAAMN,EAAE,OAAWG,EAAE,SAAN,EAAa,IAAS,CAACA,EAAE,MAAM,EAAE,OAAOH,EAAE,MAAM,CAACA,EAAEE,IAAIG,EAAEL,EAAEC,EAAEC,CAAC,EAAEK,CAAC,CAAC,GAAGJ,EAAE,MAAM,CAACH,EAAEC,IAAII,EAAEL,EAAEE,EAAED,CAAC,EAAEM,CAAC,CAAC,IAAQC,EAAE,SAAN,GAAcH,EAAEG,EAAE,CAAC,EAAEJ,EAAEG,CAAC,EAAE,CAAC,OAAOL,EAAE,SAASI,EAAE,QAAQJ,EAAE,MAAM,CAACF,EAAEC,IAAII,EAAEL,EAAEM,EAAEL,CAAC,EAAEM,CAAC,CAAC,CAAC,CAAC,OAAO,QAAQ,QAAQL,CAAC,EAAE,MAAMD,GAAG,CAAC,MAAME,EAAED,EAAED,CAAC,EAAE,OAAOA,KAAKK,GAAGF,EAAEI,EAAEL,CAAC,GAAgBK,EAAER,CAAC,EAAC,EAAG,cAApB,aAAkCK,EAAEF,EAAEG,EAAEL,CAAC,EAAEM,CAAC,EAAE,IAAIC,CAAC,CAAC,CAAC,CAAC,OAAO,OAAO,GAAGF,EAAEJ,CAAC,CAAC,EAAEI,EAAEL,GAAG,CAAC,IAAIC,EAAEG,EAAEG,EAAE,OAAOL,EAAEF,CAAC,EAAEG,EAAEH,CAAC,GAASC,GAASG,GAAGG,EAAEP,EAAED,CAAC,EAAC,GAAI,mBAApB,KAAsC,OAAOK,EAAE,KAAKG,CAAC,IAA9D,KAAiEN,EAAE,GAAG,MAAM,QAAQD,CAAC,EAAEM,EAAEN,EAAEK,CAAC,EAAEC,EAAE,OAAO,OAAON,CAAC,EAAEK,CAAC,EAAE,CAAE,CAAA,EAAEC,EAAE,CAAC,EAAEN,IAAI,EAAE,OAAO,CAACD,EAAE,IAAIA,EAAE,OAAOC,EAAE,CAAC,CAAC,EAAE,CAAA,CAAE,EAA2O,SAAS,EAAE,EAAE,CAAC,OAAO,OAAO,OAAO,EAAE,CAAC,SAAS,IAAIQ,GAAE,CAAC,EAAE,IAAIR,GAAGS,EAAE,EAAET,CAAC,EAAE,GAAGA,GAAGU,GAAE,EAAEV,CAAC,EAAE,OAAOA,GAAYA,IAAT,OAAWW,EAAE,CAAC,EAAEA,EAAEX,EAAE,CAAC,CAAC,CAAC,CAAC,CAA+R,SAASQ,GAAER,EAAE,CAAC,OAAO,EAAE,CAAC,CAACD,CAAC,EAAE,KAAK,CAAC,MAAMA,GAAG,CAAC,IAAIE,EAAE,CAAA,EAAG,MAAMC,EAAE,CAACH,EAAEC,IAAI,CAACC,EAAEF,CAAC,EAAEC,CAAC,EAAE,OAAgBD,IAAT,QAAYM,EAAEL,CAAC,EAAE,QAAQD,GAAGG,EAAEH,EAAE,MAAM,CAAC,EAAE,CAAC,QAAQ,GAAG,WAAWE,CAAC,GAAG,CAAC,QAAQG,EAAEJ,EAAED,EAAEG,CAAC,EAAE,WAAWD,CAAC,CAAC,EAAE,iBAAiB,IAAII,EAAEL,CAAC,EAAE,YAAY,UAAU,EAAE,CAAC,CAAC,CAAmI,SAASS,KAAKT,EAAE,CAAC,OAAO,EAAE,CAAC,CAACD,CAAC,EAAE,KAAK,CAAC,MAAMA,GAAG,CAAC,IAAIE,EAAE,CAAE,EAAC,MAAMC,EAAE,CAACH,EAAEC,IAAI,CAACC,EAAEF,CAAC,EAAEC,CAAC,EAAE,MAAM,CAAC,QAAQA,EAAE,MAAMA,GAAGI,EAAEJ,EAAED,EAAEG,CAAC,CAAC,EAAE,WAAWD,CAAC,CAAC,EAAE,iBAAiB,IAAIK,EAAEN,EAAEK,CAAC,EAAE,YAAY,KAAK,EAAE,CAAC,CAAC,CAAC,SAASK,MAAKV,EAAE,CAAC,OAAO,EAAE,CAAC,CAACD,CAAC,EAAE,KAAK,CAAC,MAAMA,GAAG,CAAC,IAAIE,EAAE,CAAE,EAAC,MAAMC,EAAE,CAACH,EAAEC,IAAI,CAACC,EAAEF,CAAC,EAAEC,CAAC,EAAE,OAAOM,EAAEN,EAAEK,CAAC,EAAE,QAAQN,GAAGG,EAAEH,EAAE,MAAM,CAAC,EAAE,CAAC,QAAQC,EAAE,KAAKA,GAAGI,EAAEJ,EAAED,EAAEG,CAAC,CAAC,EAAE,WAAWD,CAAC,CAAC,EAAE,iBAAiB,IAAIK,EAAEN,EAAEK,CAAC,EAAE,YAAY,IAAI,EAAE,CAAC,CAAC,CAAC,SAASO,EAAEZ,EAAE,CAAC,MAAM,CAAC,CAACD,CAAC,EAAE,KAAK,CAAC,MAAMA,IAAI,CAAC,QAAQ,EAAQC,EAAED,CAAC,CAAE,EAAE,EAAE,CAAC,CAAC,SAASY,KAAKX,EAAE,CAAC,MAAME,EAAY,OAAOF,EAAE,CAAC,GAApB,SAAsBA,EAAE,CAAC,EAAE,OAAOG,EAAMH,EAAE,SAAN,EAAaA,EAAE,CAAC,EAAY,OAAOA,EAAE,CAAC,GAApB,SAAsB,OAAOA,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,CAACD,CAAC,EAAE,KAAK,CAAC,MAAMA,GAAG,CAAC,IAAIC,EAAE,CAAC,CAAOE,GAAID,CAAC,EAAEF,CAAC,EAAE,MAAM,CAAC,QAAiBI,IAAT,QAAYC,EAAED,EAAEJ,EAAE,CAACA,EAAEE,IAAI,CAACD,EAAED,CAAC,EAAEE,CAAC,CAAC,EAAE,WAAWD,CAAC,CAAC,EAAE,iBAAiB,IAAI,CAAOE,GAAID,CAAC,EAAE,OAAgBE,IAAT,OAAW,GAAGE,EAAEF,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAASU,EAAE,EAAE,CAAC,OAAgB,OAAO,GAAjB,QAAkB,CAAC,SAASC,EAAE,EAAE,CAAC,OAAgB,OAAO,GAAjB,QAAkB,CAAC,SAASC,EAAE,EAAE,CAAC,OAAgB,OAAO,GAAjB,QAAkB,CAAS,EAAEH,EAAE,SAAS,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAC,MAAKI,EAAE,GAAG,OAAO,OAAO,EAAE,CAAC,EAAE,CAAC,WAAWhB,GAAG,CAAC,OAAOgB,EAAEP,EAAE,GAAGR,EAAED,EAAEY,EAAEb,GAAGe,EAAEf,CAAC,GAAGA,EAAE,WAAWE,CAAC,CAAC,EAAC,CAAE,EAAE,IAAIA,CAAC,EAAE,SAASD,GAAG,CAAC,OAAOgB,EAAEP,EAAE,GAAGR,EAAED,EAAEY,EAAEb,GAAGe,EAAEf,CAAC,GAAGA,EAAE,SAASE,CAAC,CAAC,EAAC,CAAE,EAAE,IAAIA,CAAC,EAAE,UAAUD,GAAGgB,EAAEP,EAAE,GAAGV,GAAGa,EAAEZ,GAAGc,EAAEd,CAAC,GAAGA,EAAE,QAAQD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,OAAOA,GAAGgB,EAAEP,EAAE,GAAGV,GAAGa,EAAEZ,GAAGc,EAAEd,CAAC,GAAGA,EAAE,SAASD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,UAAUA,GAAGgB,EAAEP,EAAE,GAAGV,GAAGa,EAAEZ,GAAGc,EAAEd,CAAC,GAAGA,EAAE,QAAQD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,SAASA,GAAG,CAAC,OAAOgB,EAAEP,EAAE,GAAGR,EAAED,EAAEY,EAAEb,GAAGe,EAAEf,CAAC,GAAGA,EAAE,SAASE,CAAC,CAAC,EAAG,CAAA,EAAE,IAAIA,CAAC,EAAE,MAAMD,GAAG,CAAC,OAAOgB,EAAEP,EAAE,GAAGR,EAAED,EAAEY,EAAEb,GAAGe,EAAEf,CAAC,GAAG,EAAQA,EAAE,MAAME,CAAC,CAAE,GAAG,EAAE,IAAIA,CAAC,CAAC,CAAC,EAAIe,EAAEJ,EAAEE,CAAC,CAAC,EAAE,MAAAG,EAAE,GAAG,OAAO,OAAO,EAAE,CAAC,EAAE,CAAC,QAAQ,CAACjB,EAAEC,IAAIgB,EAAER,EAAE,GAAG,CAACV,EAAEC,IAAIY,EAAEX,GAAGY,EAAEZ,CAAC,GAAGF,GAAGE,GAAGD,GAAGC,CAAC,GAAGD,EAAEC,CAAC,CAAC,CAAC,EAAE,GAAGD,GAAGiB,EAAER,EAAE,GAAGV,GAAGa,EAAEZ,GAAGa,EAAEb,CAAC,GAAGA,EAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,GAAGA,GAAGiB,EAAER,EAAE,GAAGV,GAAGa,EAAEZ,GAAGa,EAAEb,CAAC,GAAGA,EAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,IAAIA,GAAGiB,EAAER,EAAE,GAAGV,GAAGa,EAAEZ,GAAGa,EAAEb,CAAC,GAAGA,GAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,IAAIA,GAAGiB,EAAER,EAAE,GAAGV,GAAGa,EAAEZ,GAAGa,EAAEb,CAAC,GAAGA,GAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,IAAI,IAAIiB,EAAER,EAAE,EAAEG,EAAEb,GAAGc,EAAEd,CAAC,GAAG,OAAO,UAAUA,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,IAAIkB,EAAER,EAAE,EAAEG,EAAEb,GAAGc,EAAEd,CAAC,GAAG,OAAO,SAASA,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,IAAIkB,EAAER,EAAE,EAAEG,EAAEb,GAAGc,EAAEd,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,EAAE,SAAS,IAAIkB,EAAER,EAAE,EAAEG,EAAEb,GAAGc,EAAEd,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAIkB,EAAEL,EAAEC,CAAC,CAAC,EAAE,MAAA,EAAE,GAAG,OAAO,OAAO,EAAE,CAAC,EAAE,CAAC,QAAQ,CAACb,EAAEC,IAAI,EAAEQ,EAAE,GAAG,CAACV,EAAEC,IAAIY,EAAEX,GAAGc,EAAEd,CAAC,GAAGF,GAAGE,GAAGD,GAAGC,CAAC,GAAGD,EAAEC,CAAC,CAAC,CAAC,EAAE,GAAGD,GAAG,EAAES,EAAE,GAAGV,GAAGa,EAAEZ,GAAGe,EAAEf,CAAC,GAAGA,EAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,GAAGA,GAAG,EAAES,EAAE,GAAGV,GAAGa,EAAEZ,GAAGe,EAAEf,CAAC,GAAGA,EAAED,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,IAAIA,GAAG,EAAES,EAAE,GAAGV,GAAGa,EAAEZ,GAAGe,EAAEf,CAAC,GAAGA,GAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,IAAIA,GAAG,EAAES,EAAE,GAAGV,GAAGa,EAAEZ,GAAGe,EAAEf,CAAC,GAAGA,GAAGD,CAAC,GAAGC,CAAC,CAAC,CAAC,EAAE,SAAS,IAAI,EAAES,EAAE,EAAEG,EAAEb,GAAGgB,EAAEhB,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,EAAE,SAAS,IAAI,EAAEU,EAAE,EAAEG,EAAEb,GAAGgB,EAAEhB,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAI,EAAEa,EAAEG,CAAC,CAAC,EAAI,EAAEH,EAAE,SAAS,EAAE,CAAC,OAAiB,OAAO,GAAlB,SAAmB,CAAC,CAAC,EAAI,EAAEA,EAAE,SAAS,EAAE,CAAC,OAAgB,OAAO,GAAjB,QAAkB,CAAC,CAAC,EAAI,EAAEA,EAAE,SAAS,EAAE,CAAC,OAAa,GAAN,IAAO,CAAC,CAAC,EAAI,EAAEA,EAAE,SAAS,EAAE,CAAC,OAAa,GAAN,IAAO,CAAC,CAAC,EAAwmD,MAAMM,WAAU,KAAK,CAAC,YAAYnB,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,KAAK,UAAUA,CAAC,CAAC,MAAS,CAAC,EAAEA,CAAC,CAAC,MAAM,oDAAoD,CAAC,EAAE,EAAE,KAAK,MAAM,OAAO,KAAK,MAAMA,CAAC,CAAC,CAAC,MAAMoB,EAAE,CAAC,QAAQ,GAAG,MAAM,MAAM,EAAE,SAASC,EAAE,EAAE,CAAC,OAAO,IAAIC,EAAE,EAAEF,CAAC,CAAC,CAAC,MAAME,CAAC,CAAC,YAAYtB,EAAE,EAAE,CAAC,KAAK,MAAM,OAAO,KAAK,MAAM,OAAO,KAAK,MAAMA,EAAE,KAAK,MAAM,CAAC,CAAC,QAAQA,EAAE,CAAC,GAAG,KAAK,MAAM,QAAQ,OAAO,KAAK,MAAM,EAAEA,EAAEA,EAAE,OAAO,CAAC,EAAEG,EAAE,CAACH,EAAE,CAAC,CAAC,EAAE,IAAII,EAAMJ,EAAE,SAAN,GAA0B,OAAOA,EAAE,CAAC,GAAtB,WAAwBI,EAAEJ,EAAE,CAAC,EAAEA,EAAE,OAAO,GAAGG,EAAE,KAAK,GAAGH,EAAE,MAAM,EAAEA,EAAE,OAAO,CAAC,CAAC,EAAE,IAAIM,EAAE,GAAGC,EAAE,GAAG,MAAMC,EAAE,CAACR,EAAEC,IAAI,CAACK,EAAE,GAAGC,EAAEP,CAAC,EAAEC,CAAC,EAAEsB,EAAE,CAACpB,EAAE,KAAKH,GAAGK,EAAEL,EAAE,KAAK,MAAMQ,CAAC,CAAC,GAAGJ,GAAG,CAASA,EAAE,KAAK,KAAK,EAAGgB,EAAE,CAAC,QAAQ,GAAG,MAAM,EAAEd,EAAEJ,KAAKK,EAAEA,EAAEL,CAAC,EAAEK,EAAE,KAAK,MAAM,KAAK,KAAK,CAAC,EAAE,OAAO,IAAIe,EAAE,KAAK,MAAMC,CAAC,CAAC,CAAC,KAAKvB,EAAE,EAAE,CAAC,GAAG,KAAK,MAAM,QAAQ,OAAO,KAAK,MAAM,EAAE,EAAQA,EAAE,KAAK,KAAK,EAAG,OAAO,IAAIsB,EAAE,KAAK,MAAM,EAAE,CAAC,QAAQ,GAAG,MAAM,EAAE,KAAK,MAAM,KAAK,KAAK,CAAC,EAAEF,CAAC,CAAC,CAAC,UAAUpB,EAAE,CAAC,OAAO,KAAK,MAAM,QAAQ,KAAK,MAAM,MAAMA,EAAE,KAAK,KAAK,CAAC,CAAC,YAAY,CAAC,GAAG,KAAK,MAAM,QAAQ,OAAO,KAAK,MAAM,MAAM,MAAM,IAAImB,GAAE,KAAK,KAAK,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,YAAY,CAAC,YAAY,CAAC,OAAO,IAAI,CAAC,CCmE9kO,IAAAK,GAAAA,IACVA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QACAA,EAAAA,EAAA,UAAY,CAAZ,EAAA,YACAA,EAAAA,EAAA,aAAe,CAAf,EAAA,eACAA,EAAAA,EAAA,UAAY,CAAZ,EAAA,YACAA,EAAAA,EAAA,SAAW,CAAX,EAAA,WACAA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QANUA,IAAAA,GAAA,CAAA,CAAA,EAeAC,GAAAA,IACVA,EAAAA,EAAA,KAAO,CAAP,EAAA,OACAA,EAAAA,EAAA,QAAU,CAAV,EAAA,UACAA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QACAA,EAAAA,EAAA,OAAS,CAAT,EAAA,SAJUA,IAAAA,GAAA,CAAA,CAAA,EA+CAC,GAAAA,IACVA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QACAA,EAAAA,EAAA,KAAO,CAAP,EAAA,OAFUA,IAAAA,GAAA,CAAA,CAAA,EA4IL,SAASC,EACdC,EACkC,CAC3B,OAAA,MAAM,QAASA,EAAkC,WAAW,CACrE,CAoEO,MAAMC,EAAN,MAAMA,UAAoBC,EAAAA,gBAG/B,CAHK,aAAA,CAAA,MAAA,GAAA,SAAA,EAWL,KAAyB,IAAMC,GAAA,CA6B/B,MAAa,cACXC,EACAC,EACA,CAEO,OADO,MAAM,KAAK,eAAeA,CAAM,GACjC,GAAGD,CAAK,CACvB,CAUA,MAAa,eACXC,EACA,CACA,MAAMC,EAAS,MAAMC,KAA8B,KAAK,QAAS,CAC/D,QAAS,KAAK,mBAAmB,EACjC,GAAG,KAAK,wBAAwB,EAEhC,GAAIF,CAAA,CACL,EACD,OAAOG,GAAmBF,EAAM,IAAIG,CAAkB,CAAC,CACzD,CAUA,MAAa,oBACXJ,EACA,CAEA,OADc,MAAM,KAAK,eAAeA,CAAM,GACjC,MACf,CAUA,MAAa,kBACXA,EACA,CACA,MAAMK,EAAU,MAAMC,KAAiC,KAAK,QAAS,CACnE,QAAS,KAAK,mBAAmB,EACjC,GAAG,KAAK,wBAAwB,EAChC,GAAGN,CAAA,CACJ,EACD,OAAOI,EAAmBC,CAAM,CAClC,CAWA,MAAa,QACXE,EACAP,EACA,CACA,OAAO,MAAM,KAAK,YAAY,KAAK,WAAWO,EAAMP,CAAM,CAAC,CAC7D,CAWA,MAAa,WACXO,EACAP,EACA,CACA,KAAM,CAAE,QAAAQ,EAAS,OAAAH,CAAA,EAAW,MAAMI,EAAA,GAA2B,KAAK,QAAS,CACzE,QAAS,KAAK,mBAAmB,EACjC,GAAG,KAAK,wBAAwB,EAEhC,GAAIT,EACJ,KAAM,CAACO,CAAI,CAAA,CACZ,EAEM,MAAA,CAAE,KADI,MAAMG,EAAwB,GAAA,KAAK,QAASF,CAAO,EACjD,OAAAH,EACjB,CAWA,MAAa,oBAAoBL,EAAkC,CAC3D,MAAAW,EAAc,MAAM,KAAK,iBAC/B,UAAWC,KAAcD,EACvB,GAAI,CAAE,MAAM,KAAK,kBAAkBC,EAAYZ,CAAM,EAC5C,MAAA,GAGJ,MAAA,EACT,CAaA,MAAa,kBACXY,EACAZ,EACA,OACI,GAAAY,EAAW,gBAAkB,EAAqB,CACpD,MAAMC,EAAYD,EAAW,UACzB,IAAAE,EAQJ,GANId,EAAO,YACDc,GAAAC,EAAAf,EAAO,cAAP,YAAAe,EAAqBF,GAEpBC,EAAAE,EAAO,IAA8BH,CAAS,EAGrD,CAACC,EACG,MAAA,IAAIG,EAAAA,0BAA0BJ,CAAS,EAG/C,GAAI,KAAK,mBAAmBD,EAAYE,CAAK,EAE3C,MAAM,IAAII,EAAA,yBACRN,EAAW,gBAAgB,WAC3BE,CAAA,EAOJ,GAHAd,EAAO,MAAQc,EAGX,SAAUd,EACL,OAAA,KAAK,mBAAmBY,EAAY,CACzC,GAAGZ,CAAA,CACJ,EASH,MAAMmB,GAHU,MAHD,KAAK,QAAQ,UAAU,CACpC,QAASnB,EAAO,OAAA,CACjB,EAC4B,sBAAsB,CACjD,KAAMA,EAAO,IAAA,CACd,GAC2B,KAAK,IAAKoB,GAAQ,CAC5C,KAAM,CAAE,UAAAC,EAAW,KAAAC,CAAK,EAAIC,iBAAe,CACzC,IAAK,CAACT,CAAK,EACX,KAAMM,EAAI,KACV,OAAQA,EAAI,MAAA,CACb,EAED,MAAO,CAAE,GAAGA,EAAK,UAAAC,EAAW,KAAAC,CAAK,CAAA,CAClC,EAEM,OAAA,KAAK,mBAAmBV,EAAY,CACzC,KAAMO,EACN,GAAGnB,CAAA,CACJ,CACH,CACI,GAAAY,EAAW,gBAAkB,GAC3B,SAAUZ,GAAU,YAAaA,EAAQ,CAIrC,MAAAwB,EAAc,MAHL,KAAK,QAAQ,UAAU,CACpC,QAASxB,EAAO,OAAA,CACjB,EACgC,eAAe,CAC9C,KAAMA,EAAO,IAAA,CACd,EACM,OAAA,KAAK,sBAAsBY,EAAYY,CAAW,CAC3D,CAEK,MAAA,EACT,CAYO,mBACLZ,EACAZ,EACA,CACI,GAAA,EAAE,SAAUA,GACd,MAAM,IAAIyB,EAA2B,2BAEvC,MAAMC,EAAWd,EAAW,gBACtBe,EAAO3B,EAAO,KAChB,GAAA,CAAC2B,EAAK,OAAe,MAAA,GACzB,QAASP,KAAOO,EACd,GAAI,KAAK,2BAA2BD,EAAUN,CAAG,EACxC,MAAA,GAGJ,MAAA,EACT,CAUO,sBACLR,EACAY,EACA,CACA,MAAME,EAAWd,EAAW,gBAC5B,IAAIC,EAAYD,EAAW,UAErB,MAAAgB,EAAQC,EAAU,IACtBhB,CACF,EACA,GAAI,CAACe,EACG,MAAA,IAAIX,EAAAA,0BAA0BJ,CAAS,EAG3C,IAAAiB,EACA,GAAA,CACFA,EAAcC,EAAAA,mBAAmB,CAC/B,IAAK,CAACH,CAAI,EACV,KAAMJ,EAAY,KAAA,CACnB,QACMxD,EAAG,CACV,MAAM,IAAIgE,EAAAA,wBAAwB,CAACJ,CAAI,EAAG5D,CAAU,CACtD,CAGA,MAAMiE,EAAcH,EAAY,KAIhC,MAFI,GAACG,GAAe,CAACH,GAGnB,CAAC,KAAK,gCACJJ,EACAO,CAAA,EAON,CAWO,6BACLP,EACAQ,EACAC,EAGS,CAET,OAAQT,EAAS,WAAY,CAC3B,IAAK,GACI,OAAAU,EAAMV,EAAS,SAAS,EAC5B,KAAK,EAAuB,IAC3BW,iBAAeX,EAAS,WAAYQ,CAAqB,CAAA,EAE1D,KACC,EACA,IAAM,OAAOA,CAAU,IAAM,OAAOR,EAAS,UAAU,CAAA,EAExD,KACC,EACA,IAAMQ,IAAeI,EAAQ,QAAAZ,EAAS,WAAY,QAAQ,CAE3D,EAAA,UAAU,IAAMQ,IAAeR,EAAS,UAAU,EAEvD,IAAK,GACI,OAAAU,EAAMV,EAAS,SAAS,EAC5B,KACC,EACA,IAAM,CAACW,EAAe,eAAAX,EAAS,WAAYQ,CAAqB,CAAA,EAEjE,KACC,EACA,IAAM,OAAOA,CAAU,IAAM,OAAOR,EAAS,UAAU,CAAA,EAExD,KACC,EACA,IAAMQ,IAAeI,EAAQ,QAAAZ,EAAS,WAAY,QAAQ,CAE3D,EAAA,UAAU,IAAMQ,IAAeR,EAAS,UAAU,EAEvD,IAAK,GACC,GAAAA,EAAS,YAAc,EACzB,OAAO,OAAOQ,CAAU,EAAI,OAAOR,EAAS,UAAU,EAExD,MAAM,IAAIa,EAAAA,8BAA8B,CACtC,GAAGJ,EACH,SAAAT,EACA,WAAAQ,CAAA,CACD,EAEH,IAAK,GACC,GAAAR,EAAS,YAAc,EACzB,OAAO,OAAOQ,CAAU,EAAI,OAAOR,EAAS,UAAU,EAExD,MAAM,IAAIa,EAAAA,8BAA8B,CACtC,GAAGJ,EACH,SAAAT,EACA,WAAAQ,CAAA,CACD,EAEH,IAAK,GACH,GACER,EAAS,YAAc,GACvBA,EAAS,YAAc,EACvB,CACI,IAAAc,EACA,OAAAd,EAAS,YAAc,EACbc,EAAAF,EAAAA,QAAQZ,EAAS,WAAY,QAAQ,EAGrCc,EAAAd,EAAS,WAAW,MAAM,CAAC,EAEjCQ,EAAsB,SAASM,CAAS,CAClD,CACA,MAAM,IAAIC,EAAAA,6BAA6B,CACrC,GAAGN,EACH,SAAAT,EACA,WAAAQ,CAAA,CACD,EAEH,IAAK,GACC,GAAA,OAAOA,GAAe,SACxB,MAAM,IAAIO,EAAAA,6BAA6B,CACrC,GAAGN,EACH,SAAAT,EACA,WAAAQ,CAAA,CACD,EAGC,GAAAR,EAAS,YAAc,EAAsB,CAE/C,MAAMgB,EAAcJ,EAAA,QAAQZ,EAAS,WAAY,QAAQ,EACzD,OAAO,IAAI,OAAOgB,CAAW,EAAE,KAAKR,CAAU,CAChD,CAEF,QACE,MAAM,IAAIS,EAAAA,4BAA4B,CACpC,GAAGR,EACH,SAAAT,EACA,WAAAQ,CAAA,CACD,CACL,CACF,CASO,2BACLR,EACAN,EACS,CACL,GAAA,CAAC,MAAM,QAAQA,EAAI,IAAI,GAAKA,EAAI,KAAK,QAAUM,EAAS,WAC1D,MAAM,IAAIkB,EAAAA,0BAA0B,CAClC,IAAAxB,EACA,SAAAM,EACA,WAAY,MAAA,CACb,EAGH,MAAMQ,EAAad,EAAI,KAAK,GAAGM,EAAS,UAAU,EAClD,GAAIQ,IAAe,OACjB,MAAM,IAAIW,EAAyB,yBAAA,CAAE,IAAAzB,EAAK,SAAAM,EAAU,WAAAQ,CAAY,CAAA,EAElE,OAAO,KAAK,6BAA6BR,EAAUQ,EAAY,CAAE,IAAAd,EAAK,CACxE,CASO,gCACLM,EACAO,EACS,CACH,MAAAC,EAAaD,EAAYP,EAAS,UAAU,EAClD,GAAIQ,IAAe,OACjB,MAAM,IAAIW,EAAAA,yBAAyB,CACjC,SAAAnB,EACA,WAAAQ,CAAA,CACD,EAEI,OAAA,KAAK,6BAA6BR,EAAUQ,EAAY,CAC7D,YAAAD,CAAA,CACD,CACH,CAUgB,gBACda,EACAC,EACyB,CACzB,KAAM,CAACC,EAASC,CAAO,EAAI,KAAK,yBAC9BH,EACAC,CAAA,EAEE,IAAAG,EACA,GAAAxD,EAA2BsD,CAAO,EAAG,CAEnC,IAAAG,EAAyBH,EAAQ,YAAY,OAAQI,GAAS,CAAC,CAACA,CAAI,EACpE,GAAAD,EAAS,SAAW,EACtB,MAAM,IAAIE,EAAgC,gCAExC,GAAAF,EAAS,OAAS,EACpB,MAAM,IAAIG,EAAqC,qCAE7C,IAAArD,EAAyB,MAAM,KAAK,CAAE,OAAQ,CAAE,EAAG,CAACsD,EAAGpF,IAGlDgF,EAAS,GAAGhF,CAAC,GAAKgF,EAAS,GAAG,EAAE,CACxC,EACYD,EAAA,CACX,eAAgBF,EAAQ,eACxB,cAAe/C,EAAM,CAAC,EACtB,cAAeA,EAAM,CAAC,EACtB,gBAAiBA,EAAM,CAAC,EACxB,eAAgBA,EAAM,CAAC,CAAA,CACzB,MAEaiD,EAAAF,EAER,MAAA,CACL,IAAKlD,EAAA,EACL,SAAA0D,EACA,KAAM,CAACC,EAA0BP,CAAU,CAAC,EAC5C,GAAG,KAAK,wBAAwBD,EAAQ,OAAO,CAAA,CAEnD,CAEO,mBAAmBG,EAAkBtC,EAAiB,OAC3D,MACG,IAAAsC,EAAK,gBAAgB,YAAc,GAClCA,EAAK,gBAAgB,YAAc,MACrCrC,EAAAD,EAAM,OAAOsC,EAAK,gBAAgB,UAAU,IAA5C,MAAArC,EAA+C,SAKnD,CACF,EAzgBEnB,EAAuB,MAAiC,CACtD,GAAI8D,EAAA,WAAA,EASN9D,EAAuB,aAA6B+D,EAAa,aAAA,OA7B5D,IAAMC,EAANhE,EA8hBP,SAASO,GAAmB0D,EAAoC,CAC9D,MAAM5D,EAAsB,CAAA,EAC1B6D,EAAsC,GACxC,QAASV,KAAQS,EAAQ,CACjB,MAAAhD,EAAY,KAAK,UAAUuC,CAAI,EACjCU,EAAWjD,CAAS,IACxBZ,EAAM,KAAKmD,CAAI,EACfU,EAAWjD,CAAS,EAAI,GAC1B,CACO,OAAAZ,CACT,CAIA,SAAS8D,EAAwDC,EAAQ,CAChE,MAAA,CACL,GAAGA,EACH,QAAS,OAAOA,EAAI,OAAO,CAAA,CAE/B,CAEA,SAAS5D,EACP4D,EACA,CACA,GAAIA,EAAI,QAAU,OAAO,OAAO,gBAAgB,EACxC,MAAA,IAAI,MAAM,mCAAmC,EAG9C,MAAA,CACL,GAAGA,EACH,QAAS,OAAOA,EAAI,OAAO,CAAA,CAE/B,CAwBO,SAASP,EAA0B,CACxC,eAAAQ,EACA,cAAAC,EACA,cAAAC,EACA,gBAAAC,EACA,eAAAC,CACF,EAA0B,CAGjB,OAAAC,EAAA,oBACL,CACE,CACE,KAAM,QACN,KAAM,cACN,WAAY,CACV,CACE,KAAM,QACN,KAAM,iBACN,WAAY,CACV,CAAE,KAAM,QAAS,KAAM,eAAgB,EACvC,CAAE,KAAM,UAAW,KAAM,WAAY,EACrC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,UAAW,KAAM,gBAAiB,EAC1C,CAAE,KAAM,UAAW,KAAM,SAAU,CACrC,CACF,EACA,CACE,KAAM,QACN,KAAM,gBACN,WAAY,CACV,CAAE,KAAM,UAAW,KAAM,WAAY,EACrC,CAAE,KAAM,QAAS,KAAM,eAAgB,EACvC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,UAAW,KAAM,gBAAiB,EAC1C,CAAE,KAAM,UAAW,KAAM,SAAU,EACnC,CACE,KAAM,QACN,KAAM,kBACN,WAAY,CACV,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,WAAY,EACnC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,YAAa,CACtC,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,KAAM,gBACN,WAAY,CACV,CAAE,KAAM,UAAW,KAAM,WAAY,EACrC,CAAE,KAAM,QAAS,KAAM,eAAgB,EACvC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,UAAW,KAAM,gBAAiB,EAC1C,CAAE,KAAM,UAAW,KAAM,SAAU,EACnC,CACE,KAAM,QACN,KAAM,kBACN,WAAY,CACV,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,WAAY,EACnC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,YAAa,CACtC,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,KAAM,kBACN,WAAY,CACV,CAAE,KAAM,UAAW,KAAM,WAAY,EACrC,CAAE,KAAM,QAAS,KAAM,eAAgB,EACvC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,UAAW,KAAM,gBAAiB,EAC1C,CAAE,KAAM,UAAW,KAAM,SAAU,EACnC,CACE,KAAM,QACN,KAAM,kBACN,WAAY,CACV,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,WAAY,EACnC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,YAAa,CACtC,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,KAAM,iBACN,WAAY,CACV,CAAE,KAAM,UAAW,KAAM,WAAY,EACrC,CAAE,KAAM,QAAS,KAAM,eAAgB,EACvC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,UAAW,KAAM,gBAAiB,EAC1C,CAAE,KAAM,UAAW,KAAM,SAAU,EACnC,CACE,KAAM,QACN,KAAM,kBACN,WAAY,CACV,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,WAAY,EACnC,CAAE,KAAM,QAAS,KAAM,YAAa,EACpC,CAAE,KAAM,QAAS,KAAM,YAAa,CACtC,CACF,CACF,CACF,CACF,CACF,CACF,EACA,CACE,CACE,eAAgBP,EAAiBE,CAAc,EAC/C,cAAe,CACb,GAAGF,EAAiBG,CAAa,EACjC,WAAYA,EAAc,YAAc,CAC1C,EACA,cAAe,CACb,GAAGH,EAAiBI,CAAa,EACjC,WAAYA,EAAc,YAAc,CAC1C,EACA,gBAAiB,CACf,GAAGJ,EAAiBK,CAAe,EACnC,WAAYA,EAAgB,YAAc,CAC5C,EACA,eAAgB,CACd,GAAGL,EAAiBM,CAAc,EAClC,WAAYA,EAAe,YAAc,CAC3C,CACF,CACF,CAAA,CAEJ","x_google_ignoreList":[0]}