import { managedBudgetAbi } from '@boostxyz/evm';
import { type Address, type ContractEventName } from 'viem';
import type { DeployableOptions, GenericDeployableParams } from '../Deployable/Deployable';
import { DeployableTargetWithRBAC } from '../Deployable/DeployableTargetWithRBAC';
import { type ERC1155TransferPayload, type FungibleTransferPayload } from '../transfers';
import { type GenericLog, type ReadParams, RegistryType, type WriteParams } from '../utils';
export { managedBudgetAbi };
export type { ERC1155TransferPayload, FungibleTransferPayload };
/**
 * The object representation of a `ManagedBudgetPayload.InitPayload`
 *
 * @export
 * @interface ManagedBudgetPayload
 * @typedef {ManagedBudgetPayload}
 */
export interface ManagedBudgetPayload {
    /**
     * The budget's owner
     *
     * @type {Address}
     */
    owner: Address;
    /**
     * List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.
     *
     * @type {Address[]}
     */
    authorized: Address[];
    /**
     * List of roles to assign to the corresponding account by index.
     *
     * @type {ManagedBudgetRoles[]}
     */
    roles: ManagedBudgetRoles[];
}
/**
 *  Enum representing available roles for use in the `ManagedBudget`.
 * `MANAGER` can disburse funds.
 * `ADMIN` can additionally manage authorized users on the budget.
 *
 * @export
 * @type {{ readonly MANAGER: 1n; readonly ADMIN_ROLE: 2n; }}
 * @enum {bigint}
 */
export declare enum ManagedBudgetRoles {
    MANAGER,
    ADMIN
}
/**
 * A generic `viem.Log` event with support for `ManagedBudget` event types.
 *
 * @export
 * @typedef {ManagedBudgetLog}
 * @template {ContractEventName<typeof managedBudgetAbi>} [event=ContractEventName<
 *     typeof managedBudgetAbi
 *   >]
 */
export type ManagedBudgetLog<event extends ContractEventName<typeof managedBudgetAbi> = ContractEventName<typeof managedBudgetAbi>> = GenericLog<typeof managedBudgetAbi, event>;
/**
 * Typeguard to determine if a transfer payload is a Fungible Transfer
 *
 * @export
 * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
 * @returns {transfer is FungibleTransferPayload}
 */
export declare function isFungibleTransfer(transfer: FungibleTransferPayload | ERC1155TransferPayload): transfer is FungibleTransferPayload;
/**
 * Typeguard to determine if a transfer payload is an ERC1155 Transfer
 *
 * @export
 * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
 * @returns {transfer is ERC1155TransferPayload}
 */
export declare function isERC1155TransferPayload(transfer: FungibleTransferPayload | ERC1155TransferPayload): transfer is ERC1155TransferPayload;
/**
 * Given either a Fungible transfer, or ERC1155 transfer, will properly encode parameters for transfers, claims, disbursements, allocations, etc.
 *
 * @export
 * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
 * @returns {Hex}
 * @throws {@link UnknownTransferPayloadSupplied}
 */
export declare function prepareTransfer(transfer: FungibleTransferPayload | ERC1155TransferPayload): `0x${string}`;
/**
 * A minimal budget implementation that simply holds and distributes tokens (ERC20-like and native)
 * This type of budget supports ETH, ERC20, and ERC1155 assets only
 *
 * @export
 * @class ManagedBudget
 * @typedef {ManagedBudget}
 * @extends {DeployableTargetWithRBAC<ManagedBudgetPayload>}
 */
export declare class ManagedBudget extends DeployableTargetWithRBAC<ManagedBudgetPayload, typeof managedBudgetAbi> {
    /**
     * @inheritdoc
     *
     * @public
     * @readonly
     * @type {*}
     */
    readonly abi: readonly [{
        readonly type: "constructor";
        readonly inputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "AlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "CloneAlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InitializerNotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "asset";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "available";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "required";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "InsufficientFunds";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "asset";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "amount";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "InvalidAllocation";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitialization";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitializationData";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "LengthMismatch";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NewOwnerIsZeroAddress";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NoHandoverRequest";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotInitializing";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Reentrancy";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "asset";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "to";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "amount";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "TransferFailed";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "asset";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "to";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: false;
        }, {
            readonly name: "amount";
            readonly internalType: "uint256";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly name: "Distributed";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "version";
            readonly internalType: "uint64";
            readonly type: "uint64";
            readonly indexed: false;
        }];
        readonly name: "Initialized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverCanceled";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverRequested";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "oldOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipTransferred";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
            readonly indexed: true;
        }];
        readonly name: "RolesUpdated";
    }, {
        readonly type: "fallback";
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "ADMIN_ROLE";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "MANAGER_ROLE";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "allocate";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "available";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "tokenId_";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "available";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "cancelOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "clawback";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "completeOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "disburse";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes[]";
            readonly type: "bytes[]";
        }];
        readonly name: "disburseBatch";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "distributed";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "tokenId_";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "distributed";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getComponentInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "grantRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "accounts_";
            readonly internalType: "address[]";
            readonly type: "address[]";
        }, {
            readonly name: "roles_";
            readonly internalType: "uint256[]";
            readonly type: "uint256[]";
        }];
        readonly name: "grantRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "hasAllRoles";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "hasAnyRole";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "account_";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "isAuthorized";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "uint256[]";
            readonly type: "uint256[]";
        }, {
            readonly name: "";
            readonly internalType: "uint256[]";
            readonly type: "uint256[]";
        }, {
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "onERC1155BatchReceived";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "onERC1155Received";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "owner";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "ownershipHandoverExpiresAt";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "reconcile";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "renounceOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "renounceRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "requestOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "revokeRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "accounts_";
            readonly internalType: "address[]";
            readonly type: "address[]";
        }, {
            readonly name: "roles_";
            readonly internalType: "uint256[]";
            readonly type: "uint256[]";
        }];
        readonly name: "revokeRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "rolesOf";
        readonly outputs: readonly [{
            readonly name: "roles";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "accounts_";
            readonly internalType: "address[]";
            readonly type: "address[]";
        }, {
            readonly name: "authorized_";
            readonly internalType: "bool[]";
            readonly type: "bool[]";
        }];
        readonly name: "setAuthorized";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "interfaceId";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly name: "supportsInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "total";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "asset_";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "tokenId_";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "total";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "transferOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "receive";
        readonly stateMutability: "payable";
    }];
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {Record<number, Address>}
     */
    static bases: Record<number, Address>;
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {RegistryType}
     */
    static registryType: RegistryType;
    /**
     *  Allocates assets to the budget.
     *  The caller must have already approved the contract to transfer the asset
     *  If the asset transfer fails, the allocation will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if the allocation was successful
     */
    allocate(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'allocate'>): Promise<boolean>;
    /**
     *  Allocates assets to the budget.
     *  The caller must have already approved the contract to transfer the asset
     *  If the asset transfer fails, the allocation will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the allocation was successful
     */
    allocateRaw(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'allocate'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Clawbacks assets from the budget.
     * Only the owner can directly clawback assets from the budget
     * If the amount is zero, the entire balance of the asset will be transferred to the receiver
     * If the asset transfer fails, the reclamation will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if the request was successful
     */
    clawback(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'clawback'>): Promise<boolean>;
    /**
     * Clawbacks assets from the budget.
     * Only the owner can directly clawback assets from the budget
     * If the amount is zero, the entire balance of the asset will be transferred to the receiver
     * If the asset transfer fails, the reclamation will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the request was successful
     */
    clawbackRaw(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'clawback'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Disburses assets from the budget to a single recipient
     * If the asset transfer fails, the disbursement will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if the disbursement was successful
     */
    disburse(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'disburse'>): Promise<boolean>;
    /**
     * Disburses assets from the budget to a single recipient
     * If the asset transfer fails, the disbursement will revert
     *
     * @public
     * @async
     * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the disbursement was successful
     */
    disburseRaw(transfer: FungibleTransferPayload | ERC1155TransferPayload, params?: WriteParams<typeof managedBudgetAbi, 'disburse'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Disburses assets from the budget to multiple recipients
     *
     * @public
     * @async
     * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - True if all disbursements were successful
     */
    disburseBatch(transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>, params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>): Promise<boolean>;
    /**
     * Disburses assets from the budget to multiple recipients
     *
     * @public
     * @async
     * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if all disbursements were successful
     */
    disburseBatchRaw(transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>, params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Get the owner of the budget
     *
     * @public
     * @param {?ReadParams} [params]
     * @returns {Promise<Address>}
     */
    owner(params?: ReadParams<typeof managedBudgetAbi, 'owner'>): Promise<`0x${string}`>;
    /**
     * Get the total amount of assets allocated to the budget, including any that have been distributed
     * If a tokenId is provided, get the total amount of ERC1155 assets allocated to the budget, including any that have been distributed
     *
     * @public
     * @param {Address} [asset="0x0000000000000000000000000000000000000000"] - The address of the asset
     * @param {?(bigint | undefined)} [tokenId] - The ID of the token
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>} - The total amount of assets
     */
    total(asset?: Address, tokenId?: bigint | undefined, params?: ReadParams<typeof managedBudgetAbi, 'total'>): Promise<never>;
    /**
     * Get the amount of assets available for distribution from the budget.
     * If a tokenId is provided, get the amount of ERC1155 assets available for distribution from the budget
     *
     * @public
     * @param {Address} [asset="0x0000000000000000000000000000000000000000"]
     * @param {?(bigint | undefined)} [tokenId]
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>} - The amount of assets available
     */
    available(asset?: Address, tokenId?: bigint | undefined, params?: ReadParams<typeof managedBudgetAbi, 'available'>): Promise<never>;
    /**
     * Get the amount of assets that have been distributed from the budget.
     * If a tokenId is provided, get the amount of ERC1155 assets that have been distributed from the budget
     *
     * @public
     * @param {Address} [asset="0x0000000000000000000000000000000000000000"]
     * @param {?(bigint | undefined)} [tokenId]
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>} - The amount of assets distributed
     */
    distributed(asset?: Address, tokenId?: bigint | undefined, params?: ReadParams<typeof managedBudgetAbi, 'distributed'>): Promise<never>;
    /**
     * @inheritdoc
     *
     * @public
     * @param {?ManagedBudgetPayload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {GenericDeployableParams}
     */
    buildParameters(_payload?: ManagedBudgetPayload, _options?: DeployableOptions): GenericDeployableParams;
}
/**
 * Given a {@link ManagedBudgetPayload}, properly encode a `ManagedBudget.InitPayload` for use with {@link ManagedBudget} initialization.
 *
 * @param {ManagedBudgetPayload} param0
 * @param {Address} param0.owner - The budget's owner
 * @param {{}} param0.authorized - List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.
 * @param {{}} param0.roles - List of roles to assign to the corresponding account by index.
 * @returns {Hex}
 */
export declare const prepareManagedBudgetPayload: ({ owner, authorized, roles, }: ManagedBudgetPayload) => `0x${string}`;
//# sourceMappingURL=ManagedBudget.d.ts.map