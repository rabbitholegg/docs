{"version":3,"file":"ManagedBudget.cjs","sources":["../../src/Budgets/ManagedBudget.ts"],"sourcesContent":["import {\n  managedBudgetAbi,\n  readManagedBudgetAvailable,\n  readManagedBudgetDistributed,\n  readManagedBudgetHasAllRoles,\n  readManagedBudgetHasAnyRole,\n  readManagedBudgetIsAuthorized,\n  readManagedBudgetOwner,\n  readManagedBudgetRolesOf,\n  readManagedBudgetTotal,\n  simulateManagedBudgetAllocate,\n  simulateManagedBudgetClawback,\n  simulateManagedBudgetDisburse,\n  simulateManagedBudgetDisburseBatch,\n  simulateManagedBudgetGrantRoles,\n  simulateManagedBudgetRevokeRoles,\n  simulateManagedBudgetSetAuthorized,\n  writeManagedBudgetAllocate,\n  writeManagedBudgetClawback,\n  writeManagedBudgetDisburse,\n  writeManagedBudgetDisburseBatch,\n  writeManagedBudgetGrantRoles,\n  writeManagedBudgetRevokeRoles,\n  writeManagedBudgetSetAuthorized,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/budgets/ManagedBudget.sol/ManagedBudget.json';\nimport { getAccount } from '@wagmi/core';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  encodeAbiParameters,\n  parseAbiParameters,\n  zeroAddress,\n} from 'viem';\nimport { ManagedBudget as ManagedBudgetBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport { DeployableTargetWithRBAC } from '../Deployable/DeployableTargetWithRBAC';\nimport {\n  DeployableUnknownOwnerProvidedError,\n  UnknownTransferPayloadSupplied,\n} from '../errors';\nimport {\n  type ERC1155TransferPayload,\n  type FungibleTransferPayload,\n  prepareERC1155Transfer,\n  prepareFungibleTransfer,\n} from '../transfers';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\nexport { managedBudgetAbi };\nexport type { ERC1155TransferPayload, FungibleTransferPayload };\n\n/**\n * The object representation of a `ManagedBudgetPayload.InitPayload`\n *\n * @export\n * @interface ManagedBudgetPayload\n * @typedef {ManagedBudgetPayload}\n */\nexport interface ManagedBudgetPayload {\n  /**\n   * The budget's owner\n   *\n   * @type {Address}\n   */\n  owner: Address;\n  /**\n   * List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.\n   *\n   * @type {Address[]}\n   */\n  authorized: Address[];\n  /**\n   * List of roles to assign to the corresponding account by index.\n   *\n   * @type {ManagedBudgetRoles[]}\n   */\n  roles: ManagedBudgetRoles[];\n}\n\n/**\n *  Enum representing available roles for use in the `ManagedBudget`.\n * `MANAGER` can disburse funds.\n * `ADMIN` can additionally manage authorized users on the budget.\n *\n * @export\n * @type {{ readonly MANAGER: 1n; readonly ADMIN_ROLE: 2n; }}\n * @enum {bigint}\n */\nexport enum ManagedBudgetRoles {\n  //@ts-expect-error ts doesn't like bigint enum values\n  MANAGER = 1n,\n  //@ts-expect-error ts doesn't like bigint enum values\n  ADMIN = 2n,\n}\n\n/**\n * A generic `viem.Log` event with support for `ManagedBudget` event types.\n *\n * @export\n * @typedef {ManagedBudgetLog}\n * @template {ContractEventName<typeof managedBudgetAbi>} [event=ContractEventName<\n *     typeof managedBudgetAbi\n *   >]\n */\nexport type ManagedBudgetLog<\n  event extends ContractEventName<typeof managedBudgetAbi> = ContractEventName<\n    typeof managedBudgetAbi\n  >,\n> = GenericLog<typeof managedBudgetAbi, event>;\n\n/**\n * Typeguard to determine if a transfer payload is a Fungible Transfer\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {transfer is FungibleTransferPayload}\n */\nexport function isFungibleTransfer(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n): transfer is FungibleTransferPayload {\n  return (transfer as ERC1155TransferPayload).tokenId === undefined;\n}\n\n/**\n * Typeguard to determine if a transfer payload is an ERC1155 Transfer\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {transfer is ERC1155TransferPayload}\n */\nexport function isERC1155TransferPayload(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n): transfer is ERC1155TransferPayload {\n  return (transfer as ERC1155TransferPayload).tokenId !== undefined;\n}\n\n/**\n * Given either a Fungible transfer, or ERC1155 transfer, will properly encode parameters for transfers, claims, disbursements, allocations, etc.\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {Hex}\n * @throws {@link UnknownTransferPayloadSupplied}\n */\nexport function prepareTransfer(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n) {\n  if (isFungibleTransfer(transfer)) {\n    return prepareFungibleTransfer(transfer);\n  }\n  if (isERC1155TransferPayload(transfer)) {\n    return prepareERC1155Transfer(transfer);\n  }\n  throw new UnknownTransferPayloadSupplied(transfer);\n}\n\n/**\n * A minimal budget implementation that simply holds and distributes tokens (ERC20-like and native)\n * This type of budget supports ETH, ERC20, and ERC1155 assets only\n *\n * @export\n * @class ManagedBudget\n * @typedef {ManagedBudget}\n * @extends {DeployableTargetWithRBAC<ManagedBudgetPayload>}\n */\nexport class ManagedBudget extends DeployableTargetWithRBAC<\n  ManagedBudgetPayload,\n  typeof managedBudgetAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = managedBudgetAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(ManagedBudgetBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.BUDGET;\n\n  /**\n   *  Allocates assets to the budget.\n   *  The caller must have already approved the contract to transfer the asset\n   *  If the asset transfer fails, the allocation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the allocation was successful\n   */\n  public async allocate(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'allocate'>,\n  ) {\n    return await this.awaitResult(this.allocateRaw(transfer, params));\n  }\n\n  /**\n   *  Allocates assets to the budget.\n   *  The caller must have already approved the contract to transfer the asset\n   *  If the asset transfer fails, the allocation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the allocation was successful\n   */\n  public async allocateRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'allocate'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetAllocate(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetAllocate(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Clawbacks assets from the budget.\n   * Only the owner can directly clawback assets from the budget\n   * If the amount is zero, the entire balance of the asset will be transferred to the receiver\n   * If the asset transfer fails, the reclamation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the request was successful\n   */\n  public async clawback(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'clawback'>,\n  ) {\n    return await this.awaitResult(this.clawbackRaw(transfer, params));\n  }\n\n  /**\n   * Clawbacks assets from the budget.\n   * Only the owner can directly clawback assets from the budget\n   * If the amount is zero, the entire balance of the asset will be transferred to the receiver\n   * If the asset transfer fails, the reclamation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the request was successful\n   */\n  public async clawbackRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'clawback'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetClawback(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetClawback(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Disburses assets from the budget to a single recipient\n   * If the asset transfer fails, the disbursement will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the disbursement was successful\n   */\n  public async disburse(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburse'>,\n  ) {\n    return await this.awaitResult(this.disburseRaw(transfer, params));\n  }\n\n  /**\n   * Disburses assets from the budget to a single recipient\n   * If the asset transfer fails, the disbursement will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the disbursement was successful\n   */\n  public async disburseRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburse'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetDisburse(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetDisburse(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Disburses assets from the budget to multiple recipients\n   *\n   * @public\n   * @async\n   * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if all disbursements were successful\n   */\n  public async disburseBatch(\n    transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>,\n  ) {\n    return await this.awaitResult(this.disburseBatchRaw(transfers, params));\n  }\n\n  /**\n   * Disburses assets from the budget to multiple recipients\n   *\n   * @public\n   * @async\n   * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if all disbursements were successful\n   */\n  public async disburseBatchRaw(\n    transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetDisburseBatch(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [transfers.map(prepareTransfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetDisburseBatch(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get the owner of the budget\n   *\n   * @public\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public owner(params?: ReadParams<typeof managedBudgetAbi, 'owner'>) {\n    return readManagedBudgetOwner(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the total amount of assets allocated to the budget, including any that have been distributed\n   * If a tokenId is provided, get the total amount of ERC1155 assets allocated to the budget, including any that have been distributed\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"] - The address of the asset\n   * @param {?(bigint | undefined)} [tokenId] - The ID of the token\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The total amount of assets\n   */\n  public total(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'total'>,\n  ) {\n    return readManagedBudgetTotal(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the amount of assets available for distribution from the budget.\n   * If a tokenId is provided, get the amount of ERC1155 assets available for distribution from the budget\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"]\n   * @param {?(bigint | undefined)} [tokenId]\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The amount of assets available\n   */\n  public available(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'available'>,\n  ) {\n    return readManagedBudgetAvailable(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the amount of assets that have been distributed from the budget.\n   * If a tokenId is provided, get the amount of ERC1155 assets that have been distributed from the budget\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"]\n   * @param {?(bigint | undefined)} [tokenId]\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The amount of assets distributed\n   */\n  public distributed(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'distributed'>,\n  ) {\n    return readManagedBudgetDistributed(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?ManagedBudgetPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: ManagedBudgetPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    if (!payload.owner || payload.owner === zeroAddress) {\n      const owner = options.account\n        ? options.account.address\n        : options.config\n          ? getAccount(options.config).address\n          : this._account?.address;\n      if (owner) {\n        payload.owner = owner;\n      } else {\n        throw new DeployableUnknownOwnerProvidedError();\n      }\n    }\n    return {\n      abi: managedBudgetAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareManagedBudgetPayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Given a {@link ManagedBudgetPayload}, properly encode a `ManagedBudget.InitPayload` for use with {@link ManagedBudget} initialization.\n *\n * @param {ManagedBudgetPayload} param0\n * @param {Address} param0.owner - The budget's owner\n * @param {{}} param0.authorized - List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.\n * @param {{}} param0.roles - List of roles to assign to the corresponding account by index.\n * @returns {Hex}\n */\nexport const prepareManagedBudgetPayload = ({\n  owner,\n  authorized,\n  roles,\n}: ManagedBudgetPayload) => {\n  return encodeAbiParameters(\n    parseAbiParameters([\n      'ManagedBudgetPayload payload',\n      'struct ManagedBudgetPayload { address owner; address[] authorized; uint256[] roles; }',\n    ]),\n    [{ owner, authorized, roles: roles as unknown as Array<bigint> }],\n  );\n};\n"],"names":["ManagedBudgetRoles","isFungibleTransfer","transfer","isERC1155TransferPayload","prepareTransfer","prepareFungibleTransfer","prepareERC1155Transfer","UnknownTransferPayloadSupplied","_ManagedBudget","DeployableTargetWithRBAC","managedBudgetAbi","params","request","result","simulateManagedBudgetAllocate","writeManagedBudgetAllocate","simulateManagedBudgetClawback","writeManagedBudgetClawback","simulateManagedBudgetDisburse","writeManagedBudgetDisburse","transfers","simulateManagedBudgetDisburseBatch","writeManagedBudgetDisburseBatch","readManagedBudgetOwner","asset","zeroAddress","tokenId","readManagedBudgetTotal","readManagedBudgetAvailable","readManagedBudgetDistributed","_payload","_options","payload","options","owner","getAccount","_a","DeployableUnknownOwnerProvidedError","bytecode","prepareManagedBudgetPayload","ManagedBudgetBases","RegistryType","ManagedBudget","authorized","roles","encodeAbiParameters","parseAbiParameters"],"mappings":"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"}