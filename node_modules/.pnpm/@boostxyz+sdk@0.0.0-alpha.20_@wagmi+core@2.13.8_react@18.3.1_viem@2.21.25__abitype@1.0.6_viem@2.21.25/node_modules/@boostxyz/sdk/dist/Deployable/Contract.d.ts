import { type Config } from '@wagmi/core';
import type { ExtractAbiEvent } from 'abitype';
import { type Abi, type Address, type ContractEventName, type GetLogsReturnType, type WaitForTransactionReceiptParameters, type WatchContractEventOnLogsParameter } from 'viem';
import { type GetLogsParams, type HashAndSimulatedResult, type WatchParams } from '../utils';
/**
 * A basic Contract class to encapsulate configuration and a potential address
 *
 * @export
 * @class Contract
 * @typedef {Contract}
 * @template {Abi} [ContractAbi=[]]
 * @template {ContractEventName<ContractAbi>} [ContractEvent=any]
 */
export declare class Contract<ContractAbi extends Abi> {
    readonly abi: ContractAbi;
    /**
     * @see [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)
     * @protected
     * @type {WagmiConfig}
     */
    protected _config: Config;
    /**
     * The internally managed address for this contract
     *
     * @protected
     * @type {(Address | undefined)}
     */
    protected _address: Address | undefined;
    /**
     * Creates an instance of Contract.
     *
     * @constructor
     * @param {Config} config
     * @param {(Address | undefined)} address
     */
    constructor(config: Config, address: Address | undefined);
    /**
     * A getter returning this contract's deployed address, if it exists.
     *
     * @public
     * @readonly
     * @type {Address | undefined}
     */
    get address(): `0x${string}` | undefined;
    /**
     * Will set this contract's address and return the instance for chaining. Does not verify that provided address is valid.
     *
     * @public
     * @param {Address} address
     * @returns {this}
     */
    at(address: Address): this;
    /**
     * Will set this contract's internal [Wagmi Configuration](https://en.wikipedia.org/wiki/Factorial) and return the instance for chaining.
     *
     * @public
     * @param {Config} config
     * @returns {this}
     */
    withConfig(config: Config): this;
    /**
     * Utility function to validate the existence of an address on this Contract.
     *
     * @public
     * @returns {Address}
     * @throws {@link ContractAddressRequiredError} if no address exists on this Contract instance
     */
    assertValidAddress(): `0x${string}`;
    /**
     * A typed wrapper for (viem.getLogs)[https://viem.sh/docs/actions/public/getLogs#getlogs].
     * Accepts `eventName` and `eventNames` as optional parameters to narrow the returned log types.
     * @example
     * ```ts
     * const logs = contract.getLogs({ eventName: 'EventName' })
     * const logs = contract.getLogs({ eventNames: ['EventName'] })
     *
     * @public
     * @async
     * @template {ContractEvent} event
     * @template {ExtractAbiEvent<
     *       ContractAbi,
     *       event
     *     >} [abiEvent=ExtractAbiEvent<ContractAbi, event>]
     * @param {?Omit<
     *       GetLogsParams<ContractAbi, event, abiEvent, abiEvent[]>,
     *       'event' | 'events'
     *     > & {
     *       eventName?: event;
     *       eventNames?: event[];
     *     }} [params]
     * @returns {Promise<GetLogsReturnType<abiEvent, abiEvent[]>>}
     */
    getLogs<event extends ContractEventName<ContractAbi>, const abiEvent extends ExtractAbiEvent<ContractAbi, event> = ExtractAbiEvent<ContractAbi, event>>(params?: Omit<GetLogsParams<ContractAbi, event, abiEvent, abiEvent[]>, 'event' | 'events'> & {
        eventName?: event;
        eventNames?: event[];
    }): Promise<GetLogsReturnType<abiEvent, abiEvent[]>>;
    /**
     * A typed wrapper for `wagmi.watchContractEvent`
     *
     * @public
     * @template {ContractEvent} event
     * @param {(
     *       log: WatchContractEventOnLogsParameter<ContractAbi, event, true>[number],
     *     ) => unknown} cb
     * @param {?WatchParams<ContractAbi, event> & {
     *       eventName?: event;
     *     }} [params]
     * @returns {() => void}
     */
    subscribe<event extends ContractEventName<ContractAbi>>(cb: (log: WatchContractEventOnLogsParameter<ContractAbi, event, true>[number]) => unknown, params?: WatchParams<ContractAbi, event> & {
        eventName?: event;
    }): () => void;
    /**
     * @see {@link awaitResult}
     * @protected
     * @async
     * @template [Result=unknown]
     * @param {Promise<HashAndSimulatedResult<Result>>} hashPromise
     * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]
     * @returns {Promise<Result>}
     */
    protected awaitResult<Result = unknown>(hashPromise: Promise<HashAndSimulatedResult<Result>>, waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>): Promise<Result>;
}
//# sourceMappingURL=Contract.d.ts.map