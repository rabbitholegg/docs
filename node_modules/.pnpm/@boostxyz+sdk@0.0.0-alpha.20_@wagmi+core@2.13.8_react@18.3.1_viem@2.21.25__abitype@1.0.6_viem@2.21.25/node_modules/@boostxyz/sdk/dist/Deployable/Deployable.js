import { deployContract as i } from "@wagmi/core";
import { DeployableAlreadyDeployedError as s, DeployableBuildParametersUnspecifiedError as n, DeployableWagmiConfigurationRequiredError as l } from "../errors.js";
import { getDeployedContractAddress as c } from "../utils.js";
import { Contract as d } from "./Contract.js";
class m extends d {
  /**
   * Creates an instance of Deployable.
   *
   * @constructor
   * @param {DeployableOptions} param0
   * @param {?Account} [param0.account]
   * @param {Config} param0.config
   * @param {DeployablePayloadOrAddress<Payload>} payload
   */
  constructor({ account: t, config: o }, a) {
    typeof a == "string" ? super(o, a) : (super(o, void 0), this._payload = a), t && (this._account = t);
  }
  /**
   * Returns the attached deployable payload, if it exists
   *
   * @readonly
   * @type {Payload}
   */
  get payload() {
    return this._payload;
  }
  /**
   * Attaches a new payload for use with this deployable's initialization
   *
   * @public
   * @param {Payload} payload
   * @returns {this}
   */
  withPayload(t) {
    return this._payload = t, this;
  }
  /**
   * High level deployment function to deploy and await the contract address.
   * This is mainly a convenience method to easily deploy a contract, but will not initialize a `Cloneable`,
   * which makes it useless for Boost components.
   * Obviously you can ignore the TS warnings and use this, but you shouldn't in most all cases.
   *
   * @public
   * @async
   * @param {?Payload} [_payload]
   * @param {?DeployableOptions} [_options]
   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams] - See [viem.WaitForTransactionReceipt](https://v1.viem.sh/docs/actions/public/waitForTransactionReceipt.html#waitfortransactionreceipt)
   * @returns {Promise<this>}
   */
  async deploy(t, o, a) {
    const e = (o == null ? void 0 : o.config) || this._config, r = await c(
      e,
      this.deployRaw(t, o),
      a
    );
    return this._address = r, this;
  }
  /**
   * The lower level contract deployment function that does not await for the transaction receipt.
   * This is mainly a convenience method to easily deploy a contract, but will not initialize a `Cloneable`,
   * which makes it useless for Boost components.
   * Obviously you can ignore the TS warnings and use this, but you shouldn't in most all cases.
   *
   * @public
   * @async
   * @param {?Payload} [_payload]
   * @param {?DeployableOptions} [_options]
   * @returns {Promise<Hash>}
   * @throws {@link DeployableAlreadyDeployedError}
   * @throws {@link DeployableWagmiConfigurationRequiredError}
   * @throws {@link DeployableMissingPayloadError}
   */
  async deployRaw(t, o) {
    if (this.address) throw new s(this.address);
    const [a, e] = this.validateDeploymentConfig(
      t,
      o
    );
    return await i(e.config, {
      ...this.buildParameters(a),
      ...this.optionallyAttachAccount(e.account)
    });
  }
  /**
   * Internal function to attach the connected account to write methods to avoid manually passing in an account each call.
   *
   * @protected
   * @param {?Account} [account]
   * @returns {({ account: Account; } | { account?: undefined; })}
   */
  optionallyAttachAccount(t) {
    return t ? { account: t } : this._account ? { account: this._account } : {};
  }
  /**
   * Base parameter constructor, should return a partial `viem.deployContract` parameters shape including abi, bytecode, and arguments, if any.
   * Expected to be overridden by protocol contracts.
   *
   * @public
   * @param {?Payload} [_payload]
   * @param {?DeployableOptions} [_options]
   * @returns {GenericDeployableParams}
   */
  buildParameters(t, o) {
    throw new n();
  }
  /**
   * Internal method used to ensure that a Wagmi configuration and payload are always present when deploying.
   *
   * @protected
   * @template [P=Payload]
   * @param {?P} [_payload]
   * @param {?DeployableOptions} [_options]
   * @returns {[P, DeployableOptions]}
   * @throws {@link DeployableWagmiConfigurationRequiredError}
   * @throws {@link DeployableMissingPayloadError}
   */
  validateDeploymentConfig(t, o) {
    const a = o || {
      config: this._config,
      account: this._account
    };
    if (!a) throw new l();
    return [t || this._payload, a];
  }
}
export {
  m as Deployable
};
//# sourceMappingURL=Deployable.js.map
