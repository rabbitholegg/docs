{"version":3,"file":"DeployableTarget.cjs","sources":["../../src/Deployable/DeployableTarget.ts"],"sourcesContent":["import {\n  type aCloneableAbi,\n  readACloneableGetComponentInterface,\n  readACloneableSupportsInterface,\n} from '@boostxyz/evm';\nimport { deployContract } from '@wagmi/core';\nimport {\n  type Abi,\n  type Address,\n  type Hash,\n  type Hex,\n  type WaitForTransactionReceiptParameters,\n  isAddress,\n  isAddressEqual,\n  zeroAddress,\n} from 'viem';\nimport {\n  DeployableAlreadyDeployedError,\n  DeployableMissingPayloadError,\n} from '../errors';\nimport { type ReadParams, RegistryType } from '../utils';\nimport {\n  Deployable,\n  type DeployableOptions,\n  type DeployablePayloadOrAddress,\n} from './Deployable';\n\n/**\n * A base class representing a generic base Boost Protocol target contract, extended by Actions, AllowLists, Budgets, Incentives, and Validators.\n *\n * @export\n * @class DeployableTarget\n * @typedef {DeployableTarget}\n * @template [Payload=unknown]\n * @extends {Deployable<Payload>}\n */\nexport class DeployableTarget<\n  Payload,\n  ContractAbi extends Abi,\n> extends Deployable<Payload, ContractAbi> {\n  /**\n   * A static property representing a map of stringified chain ID's to the address of the base implementation on chain, used when cloning base contracts.\n   *\n   * @static\n   * @readonly\n   * @type {Record<string, Address>}\n   */\n  static readonly bases: Record<number, Address> = {};\n  /**\n   * The target's registry type.\n   *\n   * @static\n   * @readonly\n   * @type {RegistryType}\n   */\n  static readonly registryType: RegistryType = RegistryType.ACTION;\n  /**\n   * A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  readonly _isBase: boolean = true;\n  public get isBase() {\n    if (\n      !!this.address &&\n      Object.values(this.bases).some((base) =>\n        // biome-ignore lint/style/noNonNullAssertion: won't evaluate this if address checked and defined above\n        isAddressEqual(this.address!, base),\n      )\n    )\n      return true;\n    return this._isBase;\n  }\n\n  /**\n   * Creates an instance of DeployableTarget.\n   *\n   * @constructor\n   * @param {DeployableOptions} options\n   * @param {DeployablePayloadOrAddress<Payload>} payload - Either a given implementation's initialization payload, or an address to an existing on chain target.\n   * @param {?boolean} [isBase] - A property asserting that the protocol should eiher clone and initialize a new target from the base implementation, or re-use an existing contract without initializing.\n   */\n  constructor(\n    options: DeployableOptions,\n    payload?: DeployablePayloadOrAddress<Payload>,\n    isBase?: boolean,\n  ) {\n    super(options, payload);\n    // if supplying a custom address, safe enough to assume it is not a base address which makes reusing contracts like budgets easier\n    if (\n      typeof payload === 'string' &&\n      isAddress(payload) &&\n      payload !== zeroAddress &&\n      !Object.values(this.bases).some((base) => {\n        if (!payload || !base) return false;\n        return isAddressEqual(payload, base);\n      })\n    )\n      isBase = false;\n    if (isBase !== undefined) this._isBase = isBase;\n  }\n\n  /**\n   * A getter that will return the base implementation's static addresses by numerical chain ID\n   *\n   * @public\n   * @readonly\n   * @type {Record<number, Address>}\n   */\n  public get bases(): Record<number, Address> {\n    return (this.constructor as typeof DeployableTarget).bases;\n  }\n\n  /**\n   * A getter that returns the registry type of the base implementation\n   *\n   * @public\n   * @readonly\n   * @type {RegistryType}\n   */\n  public get registryType(): RegistryType {\n    return (this.constructor as typeof DeployableTarget).registryType;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @async\n   * @param {?Payload} [payload]\n   * @param {?DeployableOptions} [options]\n   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]\n   * @returns {Promise<this>}\n   */\n  protected override async deploy(\n    payload?: Payload,\n    options?: DeployableOptions,\n    waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n  ) {\n    await super.deploy(payload, options, waitParams);\n    this.assertValidAddress();\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @async\n   * @param {?Payload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {Promise<Hash>}\n   */\n  protected override async deployRaw(\n    _payload?: Payload,\n    _options?: DeployableOptions,\n  ): Promise<Hash> {\n    if (this.address) throw new DeployableAlreadyDeployedError(this.address);\n    const payload = _payload || this._payload;\n    const config = _options?.config || this._config;\n    const { args, ...deployment } = this.buildParameters(payload);\n    return await deployContract(config, {\n      ...deployment,\n      ...this.optionallyAttachAccount(_options?.account),\n      // Deployable targets don't construct with arguments, they initialize with encoded payloads\n      args: [],\n    });\n  }\n\n  /**\n   * Check if the contract supports the given interface\n   *\n   * @public\n   * @async\n   * @param {Hex} interfaceId - The interface identifier\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} - True if the contract supports the interface\n   */\n  public async supportsInterface(\n    interfaceId: Hex,\n    params?: ReadParams<typeof aCloneableAbi, 'supportsInterface'>,\n  ) {\n    return await readACloneableSupportsInterface(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [interfaceId],\n    });\n  }\n\n  /**\n   *  Return a cloneable's unique identifier for downstream consumers to differentiate various targets\n   *  All implementations must override this function\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>}\n   */\n  public async getComponentInterface(\n    params?: ReadParams<typeof aCloneableAbi, 'getComponentInterface'>,\n  ) {\n    return await readACloneableGetComponentInterface(this._config, {\n      address: this.assertValidAddress(),\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n      args: [],\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @protected\n   * @template [P=Payload]\n   * @param {?P} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {[P, DeployableOptions]}\n   */\n  protected override validateDeploymentConfig<P = Payload>(\n    _payload?: P,\n    _options?: DeployableOptions,\n  ) {\n    const payload = _payload || this._payload;\n    if (!payload) throw new DeployableMissingPayloadError();\n    return super.validateDeploymentConfig(payload, _options) as [\n      P,\n      DeployableOptions,\n    ];\n  }\n}\n"],"names":["_DeployableTarget","Deployable","options","payload","isBase","isAddress","zeroAddress","base","isAddressEqual","waitParams","_payload","_options","DeployableAlreadyDeployedError","config","args","deployment","deployContract","interfaceId","params","readACloneableSupportsInterface","readACloneableGetComponentInterface","DeployableMissingPayloadError","RegistryType","DeployableTarget"],"mappings":"2PAoCaA,EAAN,MAAMA,UAGHC,EAAAA,UAAiC,CA4CzC,YACEC,EACAC,EACAC,EACA,CACA,MAAMF,EAASC,CAAO,EA1BxB,KAAS,QAAmB,GA6BxB,OAAOA,GAAY,UACnBE,EAAU,UAAAF,CAAO,GACjBA,IAAYG,EAAAA,aACZ,CAAC,OAAO,OAAO,KAAK,KAAK,EAAE,KAAMC,GAC3B,CAACJ,GAAW,CAACI,EAAa,GACvBC,EAAA,eAAeL,EAASI,CAAI,CACpC,IAEQH,EAAA,IACPA,IAAW,SAAW,KAAK,QAAUA,EAC3C,CAtCA,IAAW,QAAS,CAEhB,OAAE,KAAK,SACP,OAAO,OAAO,KAAK,KAAK,EAAE,KAAMG,GAE9BC,iBAAe,KAAK,QAAUD,CAAI,CACpC,EAEO,GACF,KAAK,OACd,CAqCA,IAAW,OAAiC,CAC1C,OAAQ,KAAK,YAAwC,KACvD,CASA,IAAW,cAA6B,CACtC,OAAQ,KAAK,YAAwC,YACvD,CAYA,MAAyB,OACvBJ,EACAD,EACAO,EACA,CACA,aAAM,MAAM,OAAON,EAASD,EAASO,CAAU,EAC/C,KAAK,mBAAmB,EACjB,IACT,CAWA,MAAyB,UACvBC,EACAC,EACe,CACf,GAAI,KAAK,QAAS,MAAM,IAAIC,EAAAA,+BAA+B,KAAK,OAAO,EACjE,MAAAT,EAAUO,GAAY,KAAK,SAC3BG,GAASF,GAAA,YAAAA,EAAU,SAAU,KAAK,QAClC,CAAE,KAAAG,EAAM,GAAGC,GAAe,KAAK,gBAAgBZ,CAAO,EACrD,OAAA,MAAMa,iBAAeH,EAAQ,CAClC,GAAGE,EACH,GAAG,KAAK,wBAAwBJ,GAAA,YAAAA,EAAU,OAAO,EAEjD,KAAM,CAAC,CAAA,CACR,CACH,CAWA,MAAa,kBACXM,EACAC,EACA,CACO,OAAA,MAAMC,EAAAA,GAAgC,KAAK,QAAS,CACzD,QAAS,KAAK,mBAAmB,EACjC,GAAG,KAAK,wBAAwB,EAEhC,GAAID,EACJ,KAAM,CAACD,CAAW,CAAA,CACnB,CACH,CAWA,MAAa,sBACXC,EACA,CACO,OAAA,MAAME,EAAAA,GAAoC,KAAK,QAAS,CAC7D,QAAS,KAAK,mBAAmB,EACjC,GAAG,KAAK,wBAAwB,EAEhC,GAAIF,EACJ,KAAM,CAAC,CAAA,CACR,CACH,CAWmB,yBACjBR,EACAC,EACA,CACM,MAAAR,EAAUO,GAAY,KAAK,SACjC,GAAI,CAACP,EAAe,MAAA,IAAIkB,EAAAA,8BACjB,OAAA,MAAM,yBAAyBlB,EAASQ,CAAQ,CAIzD,CACF,EA1LEX,EAAgB,MAAiC,GAQjDA,EAAgB,aAA6BsB,EAAa,aAAA,OAnBrD,IAAMC,EAANvB"}