import { watchContractEvent as o } from "@wagmi/core";
import { getAbiItem as i } from "viem";
import { getLogs as d } from "viem/actions";
import { ContractAddressRequiredError as r } from "../errors.js";
import { awaitResult as h } from "../utils.js";
class v {
  /**
   * Creates an instance of Contract.
   *
   * @constructor
   * @param {Config} config
   * @param {(Address | undefined)} address
   */
  constructor(t, e) {
    this._config = t, this._address = e;
  }
  /**
   * A getter returning this contract's deployed address, if it exists.
   *
   * @public
   * @readonly
   * @type {Address | undefined}
   */
  get address() {
    return this._address;
  }
  /**
   * Will set this contract's address and return the instance for chaining. Does not verify that provided address is valid.
   *
   * @public
   * @param {Address} address
   * @returns {this}
   */
  at(t) {
    return this._address = t, this;
  }
  /**
   * Will set this contract's internal [Wagmi Configuration](https://en.wikipedia.org/wiki/Factorial) and return the instance for chaining.
   *
   * @public
   * @param {Config} config
   * @returns {this}
   */
  withConfig(t) {
    return this._config = t, this;
  }
  /**
   * Utility function to validate the existence of an address on this Contract.
   *
   * @public
   * @returns {Address}
   * @throws {@link ContractAddressRequiredError} if no address exists on this Contract instance
   */
  assertValidAddress() {
    const t = this.address;
    if (!t) throw new r();
    return t;
  }
  /**
   * A typed wrapper for (viem.getLogs)[https://viem.sh/docs/actions/public/getLogs#getlogs].
   * Accepts `eventName` and `eventNames` as optional parameters to narrow the returned log types.
   * @example
   * ```ts
   * const logs = contract.getLogs({ eventName: 'EventName' })
   * const logs = contract.getLogs({ eventNames: ['EventName'] })
   *
   * @public
   * @async
   * @template {ContractEvent} event
   * @template {ExtractAbiEvent<
   *       ContractAbi,
   *       event
   *     >} [abiEvent=ExtractAbiEvent<ContractAbi, event>]
   * @param {?Omit<
   *       GetLogsParams<ContractAbi, event, abiEvent, abiEvent[]>,
   *       'event' | 'events'
   *     > & {
   *       eventName?: event;
   *       eventNames?: event[];
   *     }} [params]
   * @returns {Promise<GetLogsReturnType<abiEvent, abiEvent[]>>}
   */
  async getLogs(t) {
    return d(this._config.getClient({ chainId: t == null ? void 0 : t.chainId }), {
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wag
      ...t,
      ...t != null && t.eventName ? {
        event: i({
          abi: this.abi,
          name: t.eventName
          // biome-ignore lint/suspicious/noExplicitAny: awkward abi intersection issue
        })
      } : {},
      ...t != null && t.eventNames ? {
        events: t.eventNames.map(
          (e) => i({
            abi: this.abi,
            name: e
            // biome-ignore lint/suspicious/noExplicitAny: awkward abi intersection issue
          })
        )
      } : {},
      address: this.assertValidAddress()
    });
  }
  /**
   * A typed wrapper for `wagmi.watchContractEvent`
   *
   * @public
   * @template {ContractEvent} event
   * @param {(
   *       log: WatchContractEventOnLogsParameter<ContractAbi, event, true>[number],
   *     ) => unknown} cb
   * @param {?WatchParams<ContractAbi, event> & {
   *       eventName?: event;
   *     }} [params]
   * @returns {() => void}
   */
  subscribe(t, e) {
    return o(this._config, {
      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally
      ...e,
      eventName: e == null ? void 0 : e.eventName,
      abi: this.abi,
      address: this.assertValidAddress(),
      onLogs: (s) => {
        for (let n of s)
          t(n);
      }
    });
  }
  /**
   * @see {@link awaitResult}
   * @protected
   * @async
   * @template [Result=unknown]
   * @param {Promise<HashAndSimulatedResult<Result>>} hashPromise
   * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]
   * @returns {Promise<Result>}
   */
  async awaitResult(t, e) {
    return await h(this._config, t, e);
  }
}
export {
  v as Contract
};
//# sourceMappingURL=Contract.js.map
