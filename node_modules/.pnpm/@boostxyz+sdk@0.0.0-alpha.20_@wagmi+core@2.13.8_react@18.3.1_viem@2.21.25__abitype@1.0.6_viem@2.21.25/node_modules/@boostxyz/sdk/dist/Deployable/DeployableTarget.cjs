"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const c=require("../generated-B0tk-c9b.cjs"),u=require("@wagmi/core"),i=require("viem"),d=require("../errors.cjs"),l=require("../utils.cjs"),h=require("./Deployable.cjs"),a=class a extends h.Deployable{constructor(s,e,t){super(s,e),this._isBase=!0,typeof e=="string"&&i.isAddress(e)&&e!==i.zeroAddress&&!Object.values(this.bases).some(r=>!e||!r?!1:i.isAddressEqual(e,r))&&(t=!1),t!==void 0&&(this._isBase=t)}get isBase(){return this.address&&Object.values(this.bases).some(s=>i.isAddressEqual(this.address,s))?!0:this._isBase}get bases(){return this.constructor.bases}get registryType(){return this.constructor.registryType}async deploy(s,e,t){return await super.deploy(s,e,t),this.assertValidAddress(),this}async deployRaw(s,e){if(this.address)throw new d.DeployableAlreadyDeployedError(this.address);const t=s||this._payload,r=(e==null?void 0:e.config)||this._config,{args:y,...o}=this.buildParameters(t);return await u.deployContract(r,{...o,...this.optionallyAttachAccount(e==null?void 0:e.account),args:[]})}async supportsInterface(s,e){return await c.ti(this._config,{address:this.assertValidAddress(),...this.optionallyAttachAccount(),...e,args:[s]})}async getComponentInterface(s){return await c.ei(this._config,{address:this.assertValidAddress(),...this.optionallyAttachAccount(),...s,args:[]})}validateDeploymentConfig(s,e){const t=s||this._payload;if(!t)throw new d.DeployableMissingPayloadError;return super.validateDeploymentConfig(t,e)}};a.bases={},a.registryType=l.RegistryType.ACTION;let n=a;exports.DeployableTarget=n;
//# sourceMappingURL=DeployableTarget.cjs.map
