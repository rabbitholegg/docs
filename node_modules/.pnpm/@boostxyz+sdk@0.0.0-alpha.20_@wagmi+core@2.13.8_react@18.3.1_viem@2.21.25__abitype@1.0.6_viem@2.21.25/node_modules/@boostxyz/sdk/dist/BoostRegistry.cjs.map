{"version":3,"file":"BoostRegistry.cjs","sources":["../src/BoostRegistry.ts"],"sourcesContent":["import {\n  boostRegistryAbi,\n  readBoostRegistryGetBaseImplementation,\n  readBoostRegistryGetCloneIdentifier,\n  readBoostRegistryGetClones,\n  simulateBoostRegistryDeployClone,\n  simulateBoostRegistryRegister,\n  writeBoostRegistryDeployClone,\n  writeBoostRegistryRegister,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/BoostRegistry.sol/BoostRegistry.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  isAddress,\n  zeroAddress,\n} from 'viem';\nimport { BoostRegistry as BoostRegistryBases } from '../dist/deployments.json';\nimport {\n  Deployable,\n  type DeployableOptions,\n  type GenericDeployableParams,\n} from './Deployable/Deployable';\nimport type { DeployableTarget } from './Deployable/DeployableTarget';\nimport {\n  type GenericLog,\n  type HashAndSimulatedResult,\n  type ReadParams,\n  type RegistryType,\n  type WriteParams,\n  assertValidAddressByChainId,\n} from './utils';\n\n/**\n * The ABI of the BoostRegistry contract, if needed for low level operations\n *\n * @type {typeof boostRegistryAbi}\n */\nexport { boostRegistryAbi };\n\n/**\n * The address of the deployed `BoostRegistry` instance. In prerelease mode, this will be its sepolia address\n *\n * @type {Address}\n */\nexport const BOOST_REGISTRY_ADDRESS =\n  (BoostRegistryBases as Record<string, Address>)[__DEFAULT_CHAIN_ID__] ||\n  zeroAddress;\n\n/**\n * The fixed addresses for the deployed Boost Registry.\n * By default, `new BoostRegistry` will use the address deployed to the currently connected chain, or `BOOST_REGISTRY_ADDRESS` if not provided.\n *\n * @type {Record<number, Address>}\n */\nexport const BOOST_REGISTRY_ADDRESSES: Record<number, Address> = {\n  ...(BoostRegistryBases as Record<number, Address>),\n  31337: import.meta.env.VITE_BOOST_REGISTRY_ADDRESS,\n};\n\n/**\n * A record of `BoostRegistry` event names to `AbiEvent` objects for use with `getLogs`\n *\n * @export\n * @typedef {BoostRegistryLog}\n * @template {ContractEventName<typeof boostRegistryAbi>} [event=ContractEventName<\n *     typeof boostRegistryAbi\n *   >]\n */\nexport type BoostRegistryLog<\n  event extends ContractEventName<typeof boostRegistryAbi> = ContractEventName<\n    typeof boostRegistryAbi\n  >,\n> = GenericLog<typeof boostRegistryAbi, event>;\n\n/**\n * Instantiation options for a previously deployed Boost Registry\n *\n * @export\n * @interface BoostRegistryDeployedOptions\n * @typedef {BoostRegistryDeployedOptions}\n * @extends {DeployableOptions}\n */\nexport interface BoostRegistryDeployedOptions extends DeployableOptions {\n  /**\n   * The address for a Boost Registry, if different than `BOOST_REGISTRY_ADDRESS`\n   *\n   * @type {?Address}\n   */\n  address?: Address;\n}\n\n/**\n * A typeguard to determine if instantiation is using a custom address.\n *\n * @param {*} opts\n * @returns {opts is BoostRegistryDeployedOptions}\n */\nfunction isBoostRegistryDeployed(\n  // biome-ignore lint/suspicious/noExplicitAny: type guard\n  opts: any,\n): opts is BoostRegistryDeployedOptions {\n  return opts.address && isAddress(opts.address);\n}\n\n/**\n * The Boost Registry does not take any construction arguments, so if you'd like to deploy a new Boost Registry, pass an explicit null to the `address` field.\n *\n * @export\n * @interface BoostRegistryOptionsWithPayload\n * @typedef {BoostRegistryOptionsWithPayload}\n * @extends {DeployableOptions}\n */\nexport interface BoostRegistryOptionsWithPayload extends DeployableOptions {\n  /**\n   *\n   * @type {null}\n   */\n  address: null;\n}\n\n/**\n * A typeguard to determine if the user is intending to deploy a new Boost Registry before usage\n *\n * @param {*} opts\n * @returns {opts is BoostRegistryOptionsWithPayload}\n */\nfunction isBoostRegistryDeployable(\n  // biome-ignore lint/suspicious/noExplicitAny: type guard\n  opts: any,\n): opts is BoostRegistryOptionsWithPayload {\n  return opts.address === null;\n}\n\n/**\n * Instantiation options for a Boost Registry.\n *\n * @example\n * To target Boost's Registry, omit the address field.\n * Otherwise, supply a custom address to a previously deployed custom Boost Registry.\n * You can also pass `{ address: null }` if you are intending to deploy a new Boost Registry.\n * ```ts\n * let registry = new BoostRegistry({ config, account })\n * // or\n * registry = new BoostRegistry({ config, account, address: CUSTOM_ADDRESS })\n * // or\n * registry = new BoostRegistry({ config, account, address: null })\n * await registry.deploy()\n * ```\n *\n * @export\n * @typedef {BoostRegistryConfig}\n */\nexport type BoostRegistryConfig =\n  | BoostRegistryDeployedOptions\n  | BoostRegistryOptionsWithPayload;\n\n/**\n * Constructs a new Boost Registry. A registry for base implementations and cloned instances.\n * This contract is used to register base implementations and deploy new instances of those implementations for use within the Boost protocol.\n *\n * @see {@link BoostRegistryConfig}\n * @export\n * @class BoostRegistry\n * @typedef {BoostRegistry}\n * @extends {Deployable<never[]>}\n */\nexport class BoostRegistry extends Deployable<\n  never[],\n  typeof boostRegistryAbi\n> {\n  /**\n   * A static property representing a map of stringified chain ID's to the address of the deployed implementation on chain\n   *\n   * @static\n   * @readonly\n   * @type {Record<string, Address>}\n   */\n  static readonly addresses: Record<number, Address> = BOOST_REGISTRY_ADDRESSES;\n\n  /**\n   * A getter that will return Boost registry's static addresses by numerical chain ID\n   *\n   * @public\n   * @readonly\n   * @type {Record<number, Address>}\n   */\n  public get addresses(): Record<number, Address> {\n    return (this.constructor as typeof BoostRegistry).addresses;\n  }\n\n  /**\n   * Creates an instance of BoostRegistry.\n   *\n   * @see {@link BoostRegistryConfig}\n   * @constructor\n   * @param {BoostRegistryConfig} param0\n   * @param {Config} param0.config - [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)\n   * @param {?Account} [param0.account] - [Viem Local Account](https://viem.sh/docs/accounts/local)\n   * @param {({ address?: Address; } | {})} param0....options\n   */\n  constructor({ config, account, ...options }: BoostRegistryConfig) {\n    if (isBoostRegistryDeployed(options) && options.address) {\n      super({ account, config }, options.address);\n    } else if (isBoostRegistryDeployable(options)) {\n      super({ account, config }, []);\n    } else {\n      const { address } = assertValidAddressByChainId(\n        config,\n        BOOST_REGISTRY_ADDRESSES,\n      );\n      super({ account, config }, address);\n    }\n  }\n\n  /**\n   *  Register a new base implementation of a given type\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {string} name - A name for the implementation (must be unique within the given type)\n   * @param {Address} implementation - The address of the implementation contract\n   * @param {?WriteParams} [params] - Optional params to provide the underlying Viem contract call\n   * @returns {Promise<void>}\n   * @example\n   * ```ts\n   * await registry.register(ContractAction.registryType, 'ContractAction', ContractAction.base)\n   * ```\n   */\n  public async register(\n    registryType: RegistryType,\n    name: string,\n    implementation: Address,\n    params?: WriteParams<typeof boostRegistryAbi, 'register'>,\n  ) {\n    return await this.awaitResult(\n      this.registerRaw(registryType, name, implementation, params),\n    );\n  }\n\n  /**\n   * @see {@link register}\n   * @public\n   * @async\n   * @param {RegistryType} registryType\n   * @param {string} name\n   * @param {Address} implementation\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async registerRaw(\n    registryType: RegistryType,\n    name: string,\n    implementation: Address,\n    params?: WriteParams<typeof boostRegistryAbi, 'register'>,\n  ) {\n    const { request, result } = await simulateBoostRegistryRegister(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [registryType, name, implementation],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostRegistryRegister(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Initialize a new instance of a registered base implementation, returning the provided target with a new address set on it.\n   * This method is the same as `clone`, but serves to make its function more obvious as to why you'd need to use it.\n   *\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName - The display name for the clone\n   * @param {Target} target - An instance of a target contract to clone and initialize\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Target>} - The provided instance, but with a new address attached.\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public initialize<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Target> {\n    return this.clone(displayName, target, params);\n  }\n\n  /**\n   * Deploy a new instance of a registered base implementation, returning the provided target with a new address set on it.\n   *\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName - The display name for the clone\n   * @param {Target} target - An instance of a target contract to clone and initialize\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Target>} - The provided instance, but with a new address attached.\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async clone<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Target> {\n    const instance = await this.deployClone(displayName, target, params);\n    return target.at(instance);\n  }\n\n  /**\n   *\n   * @see {@link clone}\n   * @public\n   * @async\n   * @template {DeployableTarget} Target\n   * @param {string} displayName\n   * @param {Target} target\n   * @param {?WriteParams} [params]\n   * @returns {Promise<Address>}\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async deployClone<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<Address> {\n    return await this.awaitResult(\n      this.deployCloneRaw(displayName, target, params),\n    );\n  }\n\n  /**\n   * @see {@link clone}\n   * @public\n   * @async\n   * @param {string} displayName\n   * @param {DeployableTarget} target\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: Hex, result: Address }>} - The transaction hash\n   * biome-ignore lint/suspicious/noExplicitAny: any deployable target will suffice\n   */\n  public async deployCloneRaw<Target extends DeployableTarget<any, any>>(\n    displayName: string,\n    target: Target,\n    params?: WriteParams<typeof boostRegistryAbi, 'deployClone'>,\n  ): Promise<HashAndSimulatedResult<Address>> {\n    const payload = target.buildParameters(undefined, {\n      config: this._config,\n      account: this._account,\n    });\n    const { address: baseAddress } = assertValidAddressByChainId(\n      this._config,\n      target.bases,\n      params?.chain?.id || params?.chainId,\n    );\n    const { request, result } = await simulateBoostRegistryDeployClone(\n      this._config,\n      {\n        ...assertValidAddressByChainId(\n          this._config,\n          this.addresses,\n          params?.chain?.id || params?.chainId,\n        ),\n        args: [target.registryType, baseAddress, displayName, payload.args[0]],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeBoostRegistryDeployClone(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get the address of a registered base implementation.\n   * This function will revert if the implementation is not registered\n   *\n   * @public\n   * @async\n   * @param {Hex} identifier - The unique identifier for the implementation (see {getIdentifier})\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>} - The address of the implementation\n   */\n  public async getBaseImplementation(\n    identifier: Hex,\n    params?: ReadParams<typeof boostRegistryAbi, 'getBaseImplementation'>,\n  ) {\n    return await readBoostRegistryGetBaseImplementation(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [identifier],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the address of a deployed clone by its identifier\n   *\n   * @public\n   * @async\n   * @param {Hex} identifier - The unique identifier for the deployed clone (see {getCloneIdentifier})\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>} - The address of the deployed clone\n   */\n  public async getClone(\n    identifier: Hex,\n    params?: ReadParams<typeof boostRegistryAbi, 'getClone'>,\n  ) {\n    return await readBoostRegistryGetBaseImplementation(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [identifier],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the list of identifiers of deployed clones for a given deployer\n   *\n   * @public\n   * @async\n   * @param {Address} deployer - The address of the deployer\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex[]>} - The list of deployed clones for the given deployer\n   */\n  public async getClones(\n    deployer: Address,\n    params?: ReadParams<typeof boostRegistryAbi, 'getClones'>,\n  ) {\n    return await readBoostRegistryGetClones(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [deployer],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Build the identifier for a clone of a base implementation\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {Address} base - The address of the base implementation\n   * @param {Address} deployer - The address of the deployer\n   * @param {string} displayName - The display name of the clone\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>} - The unique identifier for the clone\n   */\n  public async getCloneIdentifier(\n    registryType: RegistryType,\n    base: Address,\n    deployer: Address,\n    displayName: string,\n    params?: ReadParams<typeof boostRegistryAbi, 'getCloneIdentifier'>,\n  ) {\n    return await readBoostRegistryGetCloneIdentifier(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [registryType, base, deployer, displayName],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Build the identifier for a base implementation\n   *\n   * @public\n   * @async\n   * @param {RegistryType} registryType - The base type for the implementation\n   * @param {string} displayName - The name of the implementation\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>} - The unique identifier for the implementation\n   */\n  public async getIdentifier(\n    registryType: RegistryType,\n    displayName: string,\n    params?: ReadParams<typeof boostRegistryAbi, 'getIdentifier'>,\n  ) {\n    return await readBoostRegistryGetCloneIdentifier(this._config, {\n      ...assertValidAddressByChainId(\n        this._config,\n        this.addresses,\n        params?.chainId,\n      ),\n      args: [registryType, displayName],\n      ...this.optionallyAttachAccount(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?never[]} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: never[],\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [, options] = this.validateDeploymentConfig([], _options);\n    return {\n      abi: boostRegistryAbi,\n      bytecode: bytecode as Hex,\n      // biome-ignore lint/suspicious/noExplicitAny: Registry doesn't construct or initialize\n      args: [] as any,\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n"],"names":["BOOST_REGISTRY_ADDRESS","BoostRegistryBases","BOOST_REGISTRY_ADDRESSES","isBoostRegistryDeployed","opts","isAddress","isBoostRegistryDeployable","_BoostRegistry","Deployable","config","account","options","address","assertValidAddressByChainId","registryType","name","implementation","params","request","result","simulateBoostRegistryRegister","_a","writeBoostRegistryRegister","displayName","target","instance","payload","baseAddress","simulateBoostRegistryDeployClone","_b","writeBoostRegistryDeployClone","identifier","readBoostRegistryGetBaseImplementation","deployer","readBoostRegistryGetClones","base","readBoostRegistryGetCloneIdentifier","_payload","_options","boostRegistryAbi","bytecode","BoostRegistry"],"mappings":"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"}