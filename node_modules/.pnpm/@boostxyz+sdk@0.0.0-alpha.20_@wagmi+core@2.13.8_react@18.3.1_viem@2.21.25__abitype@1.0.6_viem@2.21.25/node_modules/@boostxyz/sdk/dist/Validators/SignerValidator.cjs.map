{"version":3,"file":"SignerValidator.cjs","sources":["../../src/Validators/SignerValidator.ts"],"sourcesContent":["import {\n  readSignerValidatorHashSignerData,\n  readSignerValidatorSigners,\n  signerValidatorAbi,\n  simulateSignerValidatorSetAuthorized,\n  simulateSignerValidatorSetValidatorCaller,\n  simulateSignerValidatorValidate,\n  writeSignerValidatorSetAuthorized,\n  writeSignerValidatorSetValidatorCaller,\n  writeSignerValidatorValidate,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/validators/SignerValidator.sol/SignerValidator.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  type PrivateKeyAccount,\n  encodeAbiParameters,\n} from 'viem';\nimport { signTypedData } from 'viem/accounts';\nimport { SignerValidator as SignerValidatorBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\nexport { signerValidatorAbi };\n\n/**\n * Object reprentation of a {@link SignerValidator} initialization payload\n *\n * @export\n * @interface SignerValidatorPayload\n * @typedef {SignerValidatorPayload}\n */\nexport interface SignerValidatorPayload {\n  /**\n   * The list of authorized signers. The first address in the list will be the initial owner of the contract.\n   *\n   * @type {Address[]}\n   */\n  signers: Address[];\n  /**\n   * The authorized caller of the {@link prepareSignerValidator} function\n   * @type {Address}\n   */\n  validatorCaller: Address;\n}\n\n/**\n * Description placeholder\n *\n * @export\n * @interface SignerValidatorValidatePayload\n * @typedef {SignerValidatorValidatePayload}\n */\nexport interface SignerValidatorValidatePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {bigint}\n   */\n  incentiveId: bigint;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  claimData: Hex;\n}\n\n/**\n * Object reprentation of a {@link SignerValidator} initialization payload\n *\n * @export\n * @interface SignerValidatorPayload\n * @typedef {SignerValidatorPayload}\n */\nexport interface SignerValidatorPayload {\n  /**\n   * The list of authorized signers. The first address in the list will be the initial owner of the contract.\n   *\n   * @type {Address[]}\n   */\n  signers: Address[];\n  /**\n   * The authorized caller of the {@link prepareSignerValidator} function\n   * @type {Address}\n   */\n  validatorCaller: Address;\n}\n\n/**\n * Description placeholder\n *\n * @export\n * @interface SignerValidatorValidatePayload\n * @typedef {SignerValidatorValidatePayload}\n */\nexport interface SignerValidatorValidatePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {bigint}\n   */\n  incentiveId: bigint;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  claimData: Hex;\n}\n\n/**\n * Signer Validator Claim Data Payload\n *\n * @export\n * @interface SignerValidatorClaimDataParams\n * @typedef {SignerValidatorClaimDataParams}\n */\nexport interface SignerValidatorClaimDataParams {\n  /**\n   * The signer with which to sign the input\n   *\n   * @type {{\n   *     account: Address;\n   *     key: Hex;\n   *     privateKey: PrivateKeyAccount;\n   *   }}\n   */\n  signer: {\n    account: Address;\n    key: Hex;\n    privateKey: PrivateKeyAccount;\n  };\n  /**\n   * The encoded data to provide the underlying incentive. You can use {@link prepareAllowListIncentivePayload}, {@link prepareCGDAIncentivePayload}, {@link prepareERC20IncentivePayload}, {@link prepareERC1155IncentivePayload}, or {@link preparePointsIncentivePayload}\n   *\n   * @type {Hex}\n   */\n  incentiveData: Hex;\n  /**\n   * The chain id to target\n   *\n   * @type {number}\n   */\n  chainId: number;\n  /**\n   * The address of the validator\n   *\n   * @type {Address}\n   */\n  validator: Address;\n  /**\n   * The incentive quantity.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n  /**\n   * The address of the claimant\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The ID of the boost\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n}\n\n/**\n * Object representation of a {@link SignerValidatorInputParams} initialization payload\n *\n * @export\n * @interface SignerValidatorInputParams\n * @typedef {SignerValidatorInputParams}\n */\nexport interface SignerValidatorInputParams {\n  /**\n   * The signer address.\n   *\n   * @type {Address}\n   */\n  signer: Address;\n\n  /**\n   * The signature data.\n   *\n   * @type {string}\n   */\n  signature: Hex;\n\n  /**\n   * The incentive quantity.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n}\n\n/**\n * Object representing the payload for signing before validaton.\n *\n * @export\n * @interface SignerValidatorSignaturePayload\n * @typedef {SignerValidatorSignaturePayload}\n */\nexport interface SignerValidatorSignaturePayload {\n  /**\n   * The ID of the boost.\n   *\n   * @type {bigint}\n   */\n  boostId: bigint;\n  /**\n   * The ID of the incentive.\n   *\n   * @type {number}\n   */\n  incentiveQuantity: number;\n  /**\n   * The address of the claimant.\n   *\n   * @type {Address}\n   */\n  claimant: Address;\n  /**\n   * The claim data.\n   *\n   * @type {Hex}\n   */\n  incentiveData: Hex;\n}\n\n/**\n * A generic `viem.Log` event with support for `BoostCore` event types.\n *\n * @export\n * @typedef {SignerValidatorLog}\n * @template {ContractEventName<\n *     typeof signerValidatorAbi\n *   >} [event=ContractEventName<typeof signerValidatorAbi>]\n */\nexport type SignerValidatorLog<\n  event extends ContractEventName<\n    typeof signerValidatorAbi\n  > = ContractEventName<typeof signerValidatorAbi>,\n> = GenericLog<typeof signerValidatorAbi, event>;\n\n/**\n *  A simple implementation of a Validator that verifies a given signature and checks the recovered address against a set of authorized signers\n *\n * @export\n * @class SignerValidator\n * @typedef {SignerValidator}\n * @extends {DeployableTarget<SignerValidatorPayload>}\n */\nexport class SignerValidator extends DeployableTarget<\n  SignerValidatorPayload,\n  typeof signerValidatorAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = signerValidatorAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(SignerValidatorBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.VALIDATOR;\n\n  /**\n   * The set of authorized signers\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public async signers(\n    address: Address,\n    params?: ReadParams<typeof signerValidatorAbi, 'signers'>,\n  ) {\n    return await readSignerValidatorSigners(this._config, {\n      address: this.assertValidAddress(),\n      args: [address],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Retrieve the hash and signer data for a given hash\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorSignaturePayload} payload\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>}\n   */\n  public async hashSignerData(\n    payload: SignerValidatorSignaturePayload,\n    params?: ReadParams<typeof signerValidatorAbi, 'hashSignerData'>,\n  ) {\n    return await readSignerValidatorHashSignerData(this._config, {\n      address: this.assertValidAddress(),\n      args: [\n        payload.boostId,\n        payload.incentiveQuantity,\n        payload.claimant,\n        payload.incentiveData,\n      ],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorValidatePayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the action has been validated based on the data payload\n   */\n  protected async validate(\n    payload: SignerValidatorValidatePayload,\n    params?: WriteParams<typeof signerValidatorAbi, 'validate'>,\n  ) {\n    return await this.awaitResult(this.validateRaw(payload, params));\n  }\n\n  /**\n   * Validate that the action has been completed successfully. The data payload is expected to be a tuple of (address signer, bytes32 hash, bytes signature). The signature is expected to be a valid ECDSA or EIP-1271 signature of a unique hash by an authorized signer.\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorValidatePayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the action has been validated based on the data payload\n   */\n  protected async validateRaw(\n    payload: SignerValidatorValidatePayload,\n    params?: ReadParams<typeof signerValidatorAbi, 'validate'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorValidate(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [\n          payload.boostId,\n          payload.incentiveId,\n          payload.claimant,\n          payload.claimData,\n        ],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorValidate(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Set the authorized status of a signer\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of signers to update\n   * @param {boolean[]} allowed - The authorized status of each signer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setAuthorized(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>,\n  ) {\n    return await this.awaitResult(\n      this.setAuthorizedRaw(addresses, allowed, params),\n    );\n  }\n\n  /**\n   * Set the authorized status of a signer\n   *\n   * @public\n   * @async\n   * @param {Address[]} addresses - The list of signers to update\n   * @param {boolean[]} allowed - The authorized status of each signer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setAuthorizedRaw(\n    addresses: Address[],\n    allowed: boolean[],\n    params?: WriteParams<typeof signerValidatorAbi, 'setAuthorized'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorSetAuthorized(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [addresses, allowed],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorSetAuthorized(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Update the authorized caller of the validator function\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: void; }>}\n   */\n  public async setValidatorCallerRaw(\n    address: Address,\n    params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>,\n  ) {\n    const { request, result } = await simulateSignerValidatorSetValidatorCaller(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [address],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeSignerValidatorSetValidatorCaller(\n      this._config,\n      request,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Update the authorized caller of the validator function\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?WriteParams} [params]\n   * @returns {Promise<void>}\n   */\n  public async setValidatorCaller(\n    address: Address,\n    params?: WriteParams<typeof signerValidatorAbi, 'setValidatorCaller'>,\n  ) {\n    return await this.awaitResult(this.setValidatorCallerRaw(address, params));\n  }\n\n  /**\n   * Properly encodes the data needed to claim\n   *\n   * @public\n   * @async\n   * @param {SignerValidatorClaimDataParams} params\n   * @returns {Promise<Hex>}\n   */\n  public async encodeClaimData(\n    params: Omit<SignerValidatorClaimDataParams, 'validator'>,\n  ): Promise<Hex> {\n    return await prepareSignerValidatorClaimDataPayload({\n      ...params,\n      validator: this.assertValidAddress(),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?SignerValidatorPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: SignerValidatorPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: signerValidatorAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareSignerValidatorPayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Signer Validator Claim Data Payload Preparation\n *\n * @export\n * @async\n * @param {SignerValidatorClaimDataParams} param0\n * @param {{ account: Address; key: Hex; privateKey: PrivateKeyAccount; }} param0.signer\n * @param {Hex} param0.incentiveData\n * @param {number} param0.chainId\n * @param {Address} param0.validator\n * @param {number} param0.incentiveQuantity\n * @param {Address} param0.claimant\n * @param {bigint} param0.boostId\n * @returns {Promise<Hex>}\n */\nexport async function prepareSignerValidatorClaimDataPayload({\n  signer,\n  incentiveData,\n  chainId,\n  validator,\n  incentiveQuantity,\n  claimant,\n  boostId,\n}: SignerValidatorClaimDataParams): Promise<Hex> {\n  const domain = {\n    name: 'SignerValidator',\n    version: '1',\n    chainId: chainId,\n    verifyingContract: validator,\n  };\n  const typedData = {\n    domain,\n    types: {\n      SignerValidatorData: [\n        { name: 'boostId', type: 'uint256' },\n        { name: 'incentiveQuantity', type: 'uint8' },\n        { name: 'claimant', type: 'address' },\n        { name: 'incentiveData', type: 'bytes' },\n      ],\n    },\n    primaryType: 'SignerValidatorData' as const,\n    message: {\n      boostId,\n      incentiveQuantity,\n      claimant,\n      incentiveData: incentiveData,\n    },\n  };\n\n  const trustedSignature = await signTypedData({\n    ...typedData,\n    privateKey: signer.key,\n  });\n\n  // Prepare the claim data payload using the new helper\n  const validatorData = prepareSignerValidatorInputParams({\n    signer: signer.account,\n    signature: trustedSignature,\n    incentiveQuantity, // Adjust incentive quantity as necessary\n  });\n\n  const boostClaimDataPayload = encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'BoostClaimData',\n        components: [\n          { type: 'bytes', name: 'validatorData' },\n          { type: 'bytes', name: 'incentiveData' },\n        ],\n      },\n    ],\n    [{ validatorData, incentiveData }],\n  );\n\n  return boostClaimDataPayload;\n}\n\n/**\n * Given a {@link SignerValidatorInputParams}, properly encode the initialization payload.\n *\n * @param {SignerValidatorInputParams} param0\n * @param {Address} param0.signer\n * @param {Hex} param0.signature\n * @param {number} param0.incentiveQuantity\n * @returns {Hex}\n */\nexport function prepareSignerValidatorInputParams({\n  signer,\n  signature,\n  incentiveQuantity,\n}: SignerValidatorInputParams) {\n  return encodeAbiParameters(\n    [\n      {\n        type: 'tuple',\n        name: 'SignerValidatorInputParams',\n        components: [\n          { type: 'address', name: 'signer' },\n          { type: 'bytes', name: 'signature' },\n          { type: 'uint8', name: 'incentiveQuantity' },\n        ],\n      },\n    ],\n    [{ signer, signature, incentiveQuantity }],\n  );\n}\n\n/**\n * Given a {@link SignerValidatorPayload}, properly encode the initialization payload.\n *\n * @param {SignerValidatorPayload} param0\n * @param {Address[]} param0.signers\n * @param {Address} param0.validatorCaller\n * @returns {Hex}\n */\nexport function prepareSignerValidatorPayload({\n  signers,\n  validatorCaller,\n}: SignerValidatorPayload) {\n  return encodeAbiParameters(\n    [\n      { type: 'address[]', name: 'signers' },\n      { type: 'address', name: 'validatorCaller' },\n    ],\n    [signers, validatorCaller],\n  );\n}\n"],"names":["_SignerValidator","DeployableTarget","signerValidatorAbi","address","params","readSignerValidatorSigners","payload","readSignerValidatorHashSignerData","request","result","simulateSignerValidatorValidate","writeSignerValidatorValidate","addresses","allowed","simulateSignerValidatorSetAuthorized","writeSignerValidatorSetAuthorized","simulateSignerValidatorSetValidatorCaller","writeSignerValidatorSetValidatorCaller","prepareSignerValidatorClaimDataPayload","_payload","_options","options","bytecode","prepareSignerValidatorPayload","SignerValidatorBases","RegistryType","SignerValidator","signer","incentiveData","chainId","validator","incentiveQuantity","claimant","boostId","typedData","trustedSignature","signTypedData","validatorData","prepareSignerValidatorInputParams","encodeAbiParameters","signature","signers","validatorCaller"],"mappings":"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"}