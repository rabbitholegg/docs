{"version":3,"file":"PointsIncentive.cjs","sources":["../../src/Incentives/PointsIncentive.ts"],"sourcesContent":["import {\n  pointsIncentiveAbi,\n  readPointsIncentiveClaimed,\n  readPointsIncentiveClaims,\n  readPointsIncentiveCurrentReward,\n  readPointsIncentiveIsClaimable,\n  readPointsIncentiveLimit,\n  readPointsIncentiveReward,\n  readPointsIncentiveSelector,\n  readPointsIncentiveVenue,\n  simulatePointsIncentiveClaim,\n  writePointsIncentiveClaim,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/incentives/PointsIncentive.sol/PointsIncentive.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  encodeAbiParameters,\n} from 'viem';\nimport { PointsIncentive as PointsIncentiveBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport { type ClaimPayload, prepareClaimPayload } from '../claiming';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\nexport { pointsIncentiveAbi };\n\n/**\n * The object representation of a `PointsIncentive.InitPayload`\n *\n * @export\n * @interface PointsIncentivePayload\n * @typedef {PointsIncentivePayload}\n */\nexport interface PointsIncentivePayload {\n  /**\n   * The address of the points contract\n   *\n   * @type {Address}\n   */\n  venue: Address;\n  /**\n   * The selector for the issuance function on the points contract\n   *\n   * @type {Hex}\n   */\n  selector: Hex;\n  /**\n   * The reward amount issued for each claim\n   *\n   * @type {bigint}\n   */\n  reward: bigint;\n  /**\n   *  The maximum number of claims that can be made (one per address)\n   *\n   * @type {bigint}\n   */\n  limit: bigint;\n}\n\n/**\n * A generic `viem.Log` event with support for `PointsIncentive` event types.\n *\n * @export\n * @typedef {PointsIncentiveLog}\n * @template {ContractEventName<\n *     typeof pointsIncentiveAbi\n *   >} [event=ContractEventName<typeof pointsIncentiveAbi>]\n */\nexport type PointsIncentiveLog<\n  event extends ContractEventName<\n    typeof pointsIncentiveAbi\n  > = ContractEventName<typeof pointsIncentiveAbi>,\n> = GenericLog<typeof pointsIncentiveAbi, event>;\n\n/**\n * A simple on-chain points incentive implementation that allows claiming of soulbound tokens.\n *\n * In order for any claim to be successful:\n * - The claimer must not have already claimed the incentive; and\n * - The maximum number of claims must not have been reached; and\n * - This contract must be authorized to operate the points contract's issuance function\n *\n * @export\n * @class PointsIncentive\n * @typedef {PointsIncentive}\n * @extends {DeployableTarget<PointsIncentivePayload>}\n */\nexport class PointsIncentive extends DeployableTarget<\n  PointsIncentivePayload,\n  typeof pointsIncentiveAbi\n> {\n  public override readonly abi = pointsIncentiveAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(PointsIncentiveBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.INCENTIVE;\n\n  /**\n   * The number of claims that have been made\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async claims(\n    params?: ReadParams<typeof pointsIncentiveAbi, 'claims'>,\n  ) {\n    return await readPointsIncentiveClaims(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The current reward\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The current reward\n   */\n  public async currentReward(\n    params?: ReadParams<typeof pointsIncentiveAbi, 'currentReward'>,\n  ) {\n    return await readPointsIncentiveCurrentReward(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The reward amount issued for each claim\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} The reward amount issued for each claim\n   */\n  public async reward(\n    params?: ReadParams<typeof pointsIncentiveAbi, 'reward'>,\n  ) {\n    return await readPointsIncentiveReward(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * A mapping of address to claim status\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public async claimed(\n    address: Address,\n    params?: ReadParams<typeof pointsIncentiveAbi, 'claimed'>,\n  ) {\n    return await readPointsIncentiveClaimed(this._config, {\n      address: this.assertValidAddress(),\n      args: [address],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The address of the points contract\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public async venue(params?: ReadParams<typeof pointsIncentiveAbi, 'venue'>) {\n    return await readPointsIncentiveVenue(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The maximum number of claims that can be made (one per address)\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async limit(params?: ReadParams<typeof pointsIncentiveAbi, 'limit'>) {\n    return await readPointsIncentiveLimit(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The selector for the issuance function on the points contract\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Hex>}\n   */\n  public async selector(\n    params?: ReadParams<typeof pointsIncentiveAbi, 'selector'>,\n  ) {\n    return await readPointsIncentiveSelector(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Claim the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} -  True if the incentive was successfully claimed\n   */\n  protected async claim(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof pointsIncentiveAbi, 'claim'>,\n  ) {\n    return await this.awaitResult(this.claimRaw(payload, params));\n  }\n\n  /**\n   * Claim the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} -  True if the incentive was successfully claimed\n   */\n  protected async claimRaw(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof pointsIncentiveAbi, 'claim'>,\n  ) {\n    const { request, result } = await simulatePointsIncentiveClaim(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareClaimPayload(payload)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writePointsIncentiveClaim(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Check if an incentive is claimable.\n   * For the POOL strategy, the `bytes data` portion of the payload ignored.\n   * The recipient must not have already claimed the incentive.\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} -  True if the incentive is claimable based on the data payload\n   */\n  public async isClaimable(\n    payload: ClaimPayload,\n    params?: ReadParams<typeof pointsIncentiveAbi, 'isClaimable'>,\n  ) {\n    return await readPointsIncentiveIsClaimable(this._config, {\n      address: this.assertValidAddress(),\n      args: [prepareClaimPayload(payload)],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?PointsIncentivePayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: PointsIncentivePayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: pointsIncentiveAbi,\n      bytecode: bytecode as Hex,\n      args: [preparePointsIncentivePayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Given a {@link PointsIncentivePayload}, properly encode a `PointsIncentive.InitPayload` for use with {@link PointsIncentive} initialization.\n *\n * @param {PointsIncentivePayload} param0\n * @param {Address} param0.venue - The address of the points contract\n * @param {Hex} param0.selector - The selector for the issuance function on the points contract\n * @param {bigint} param0.reward - The reward amount issued for each claim\n * @param {bigint} param0.limit -  The maximum number of claims that can be made (one per address)\n * @returns {*}\n */\nexport const preparePointsIncentivePayload = ({\n  venue,\n  selector,\n  reward,\n  limit,\n}: PointsIncentivePayload) => {\n  return encodeAbiParameters(\n    [\n      { type: 'address', name: 'venue' },\n      { type: 'bytes4', name: 'selector' },\n      { type: 'uint256', name: 'reward' },\n      { type: 'uint256', name: 'limit' },\n    ],\n    [venue, selector, reward, limit],\n  );\n};\n"],"names":["_PointsIncentive","DeployableTarget","pointsIncentiveAbi","params","readPointsIncentiveClaims","readPointsIncentiveCurrentReward","readPointsIncentiveReward","address","readPointsIncentiveClaimed","readPointsIncentiveVenue","readPointsIncentiveLimit","readPointsIncentiveSelector","payload","request","result","simulatePointsIncentiveClaim","prepareClaimPayload","writePointsIncentiveClaim","readPointsIncentiveIsClaimable","_payload","_options","options","bytecode","preparePointsIncentivePayload","PointsIncentiveBases","RegistryType","PointsIncentive","venue","selector","reward","limit","encodeAbiParameters"],"mappings":"0qcAkGaA,EAAN,MAAMA,UAAwBC,EAAAA,gBAGnC,CAHK,aAAA,CAAA,MAAA,GAAA,SAAA,EAIL,KAAyB,IAAMC,GAAA,CA4B/B,MAAa,OACXC,EACA,CACO,OAAA,MAAMC,EAAAA,GAA0B,KAAK,QAAS,CACnD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAAC,EAEP,GAAID,CAAA,CACL,CACH,CAUA,MAAa,cACXA,EACA,CACO,OAAA,MAAME,EAAAA,GAAiC,KAAK,QAAS,CAC1D,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAAC,EAEP,GAAIF,CAAA,CACL,CACH,CAUA,MAAa,OACXA,EACA,CACO,OAAA,MAAMG,EAAAA,GAA0B,KAAK,QAAS,CACnD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAAC,EAEP,GAAIH,CAAA,CACL,CACH,CAWA,MAAa,QACXI,EACAJ,EACA,CACO,OAAA,MAAMK,EAAAA,GAA2B,KAAK,QAAS,CACpD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACD,CAAO,EAEd,GAAIJ,CAAA,CACL,CACH,CAUA,MAAa,MAAMA,EAAyD,CACnE,OAAA,MAAMM,EAAAA,GAAyB,KAAK,QAAS,CAClD,QAAS,KAAK,mBAAmB,EAEjC,GAAIN,CAAA,CACL,CACH,CAUA,MAAa,MAAMA,EAAyD,CACnE,OAAA,MAAMO,EAAAA,GAAyB,KAAK,QAAS,CAClD,QAAS,KAAK,mBAAmB,EAEjC,GAAIP,CAAA,CACL,CACH,CAUA,MAAa,SACXA,EACA,CACO,OAAA,MAAMQ,EAAAA,GAA4B,KAAK,QAAS,CACrD,QAAS,KAAK,mBAAmB,EAEjC,GAAIR,CAAA,CACL,CACH,CAWA,MAAgB,MACdS,EACAT,EACA,CACA,OAAO,MAAM,KAAK,YAAY,KAAK,SAASS,EAAST,CAAM,CAAC,CAC9D,CAWA,MAAgB,SACdS,EACAT,EACA,CACA,KAAM,CAAE,QAAAU,EAAS,OAAAC,CAAO,EAAI,MAAMC,EAAA,GAChC,KAAK,QACL,CACE,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACC,sBAAoBJ,CAAO,CAAC,EACnC,GAAG,KAAK,wBAAwB,EAEhC,GAAIT,CACN,CAAA,EAGK,MAAA,CAAE,KADI,MAAMc,EAA0B,GAAA,KAAK,QAASJ,CAAO,EACnD,OAAAC,EACjB,CAaA,MAAa,YACXF,EACAT,EACA,CACO,OAAA,MAAMe,EAAAA,GAA+B,KAAK,QAAS,CACxD,QAAS,KAAK,mBAAmB,EACjC,KAAM,CAACF,sBAAoBJ,CAAO,CAAC,EAEnC,GAAIT,CAAA,CACL,CACH,CAUgB,gBACdgB,EACAC,EACyB,CACzB,KAAM,CAACR,EAASS,CAAO,EAAI,KAAK,yBAC9BF,EACAC,CAAA,EAEK,MAAA,CACL,IAAKlB,EAAA,EACL,SAAAoB,EACA,KAAM,CAACC,EAA8BX,CAAO,CAAC,EAC7C,GAAG,KAAK,wBAAwBS,EAAQ,OAAO,CAAA,CAEnD,CACF,EArOErB,EAAuB,MAAiC,CACtD,GAAIwB,EAAA,eAAA,EASNxB,EAAuB,aAA6ByB,EAAa,aAAA,UAtB5D,IAAMC,EAAN1B,EA6PA,MAAMuB,EAAgC,CAAC,CAC5C,MAAAI,EACA,SAAAC,EACA,OAAAC,EACA,MAAAC,CACF,IACSC,EAAA,oBACL,CACE,CAAE,KAAM,UAAW,KAAM,OAAQ,EACjC,CAAE,KAAM,SAAU,KAAM,UAAW,EACnC,CAAE,KAAM,UAAW,KAAM,QAAS,EAClC,CAAE,KAAM,UAAW,KAAM,OAAQ,CACnC,EACA,CAACJ,EAAOC,EAAUC,EAAQC,CAAK,CAAA"}