import { erc20IncentiveAbi } from '@boostxyz/evm';
import { type Address, type ContractEventName } from 'viem';
import type { DeployableOptions, GenericDeployableParams } from '../Deployable/Deployable';
import { DeployableTarget } from '../Deployable/DeployableTarget';
import { type ClaimPayload, type StrategyType } from '../claiming';
import { type GenericLog, type ReadParams, RegistryType, type WriteParams } from '../utils';
export { erc20IncentiveAbi };
/**
 * The object representation of a `ERC20Incentive.InitPayload`
 *
 * @export
 * @interface ERC20IncentivePayload
 * @typedef {ERC20IncentivePayload}
 */
export interface ERC20IncentivePayload {
    /**
     * The address of the incentivized asset.
     *
     * @type {Address}
     */
    asset: Address;
    /**
     * The type of disbursement strategy for the incentive. `StrategyType.MINT` is not supported for `ERC20Incentives`
     *
     * @type {StrategyType}
     */
    strategy: StrategyType;
    /**
     * The amount of the asset to distribute.
     *
     * @type {bigint}
     */
    reward: bigint;
    /**
     * How many times can this incentive be claimed.
     *
     * @type {bigint}
     */
    limit: bigint;
}
/**
 * A generic `viem.Log` event with support for `ERC20Incentive` event types.
 *
 * @export
 * @typedef {ERC20IncentiveLog}
 * @template {ContractEventName<typeof erc20IncentiveAbi>} [event=ContractEventName<
 *     typeof erc20IncentiveAbi
 *   >]
 */
export type ERC20IncentiveLog<event extends ContractEventName<typeof erc20IncentiveAbi> = ContractEventName<typeof erc20IncentiveAbi>> = GenericLog<typeof erc20IncentiveAbi, event>;
/**
 * A simple ERC20 incentive implementation that allows claiming of tokens
 *
 * @export
 * @class ERC20Incentive
 * @typedef {ERC20Incentive}
 * @extends {DeployableTarget<ERC20IncentivePayload>}
 */
export declare class ERC20Incentive extends DeployableTarget<ERC20IncentivePayload, typeof erc20IncentiveAbi> {
    readonly abi: readonly [{
        readonly type: "constructor";
        readonly inputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "AlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "ClaimFailed";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "caller";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "data";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "ClaimFailed";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "CloneAlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InitializerNotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [{
            readonly name: "asset";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "available";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }, {
            readonly name: "required";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "InsufficientFunds";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitialization";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitialization";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitializationData";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NewOwnerIsZeroAddress";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NoHandoverRequest";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotClaimable";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotInitializing";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "Unauthorized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "recipient";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "data";
            readonly internalType: "bytes";
            readonly type: "bytes";
            readonly indexed: false;
        }];
        readonly name: "Claimed";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "entry";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "Entry";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "version";
            readonly internalType: "uint64";
            readonly type: "uint64";
            readonly indexed: false;
        }];
        readonly name: "Initialized";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverCanceled";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipHandoverRequested";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "oldOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }];
        readonly name: "OwnershipTransferred";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "asset";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "cancelOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "claimTarget";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "claim";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "claimed";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "claims";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "clawback";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "completeOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "currentReward";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "drawRaffle";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "entries";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getComponentInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "claimTarget";
            readonly internalType: "address";
            readonly type: "address";
        }, {
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "isClaimable";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "limit";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "owner";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "pendingOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "ownershipHandoverExpiresAt";
        readonly outputs: readonly [{
            readonly name: "result";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "preflight";
        readonly outputs: readonly [{
            readonly name: "budgetData";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "renounceOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "requestOwnershipHandover";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "reward";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "strategy";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "enum AERC20Incentive.Strategy";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "interfaceId";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly name: "supportsInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "newOwner";
            readonly internalType: "address";
            readonly type: "address";
        }];
        readonly name: "transferOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
    }];
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {Record<number, Address>}
     */
    static bases: Record<number, Address>;
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {RegistryType}
     */
    static registryType: RegistryType;
    /**
     * The owner of the incentive
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<Address>}
     */
    owner(params?: ReadParams<typeof erc20IncentiveAbi, 'owner'>): Promise<`0x${string}`>;
    /**
     * Calculates the current reward based on the time since the last claim. The reward is calculated based on the time since the last claim, the available budget, and the reward parameters. It increases linearly over time in the absence of claims, with each hour adding `rewardBoost` to the current reward, up to the available budget. For example, if there is one claim in the first hour, then no claims for three hours, the claimable reward would be `initialReward - rewardDecay + (rewardBoost * 3)`
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>} - The current reward
     */
    currentReward(params?: ReadParams<typeof erc20IncentiveAbi, 'currentReward'>): Promise<bigint>;
    /**
     * The number of claims that have been made
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>}
     */
    claims(params?: ReadParams<typeof erc20IncentiveAbi, 'claims'>): Promise<bigint>;
    /**
     * A mapping of address to claim status
     *
     * @public
     * @async
     * @param {Address} address
     * @param {?ReadParams} [params]
     * @returns {Promise<boolean>}
     */
    claimed(address: Address, params?: ReadParams<typeof erc20IncentiveAbi, 'claimed'>): Promise<boolean>;
    /**
     * The address of the ERC20-like token
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<Address>}
     */
    asset(params?: ReadParams<typeof erc20IncentiveAbi, 'asset'>): Promise<`0x${string}`>;
    /**
     * The strategy for the incentive (MINT or POOL)
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<StrategyType>}
     */
    strategy(params?: ReadParams<typeof erc20IncentiveAbi, 'strategy'>): Promise<StrategyType>;
    /**
     * The reward amount issued for each claim
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>}
     */
    reward(params?: ReadParams<typeof erc20IncentiveAbi, 'reward'>): Promise<bigint>;
    /**
     * The limit (max claims, or max entries for raffles)
     *
     * @public
     * @async
     * @param {?ReadParams} [params]
     * @returns {Promise<bigint>}
     */
    limit(params?: ReadParams<typeof erc20IncentiveAbi, 'limit'>): Promise<bigint>;
    /**
     * The set of addresses that have claimed a slot in the incentive raffle, accessed by bigint index.
     *
     * @public
     * @async
     * @param {bigint} i - Index of address
     * @param {?ReadParams} [params]
     * @returns {Promise<Address>}
     */
    entries(i: bigint, params?: ReadParams<typeof erc20IncentiveAbi, 'entries'>): Promise<`0x${string}`>;
    /**
     * Claim the incentive
     *
     * @public
     * @async
     * @param {ClaimPayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} - Returns true if successfully claimed
     */
    protected claim(payload: ClaimPayload, params?: WriteParams<typeof erc20IncentiveAbi, 'claim'>): Promise<boolean>;
    /**
     * Claim the incentive
     *
     * @public
     * @async
     * @param {ClaimPayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - Returns true if successfully claimed
     */
    protected claimRaw(payload: ClaimPayload, params?: WriteParams<typeof erc20IncentiveAbi, 'claim'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Clawback assets from the incentive
     *
     * @public
     * @async
     * @param {ClaimPayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<boolean>} -  True if the assets were successfully clawbacked
     */
    clawback(payload: ClaimPayload, params?: WriteParams<typeof erc20IncentiveAbi, 'clawback'>): Promise<boolean>;
    /**
     * Clawback assets from the incentive
     *
     * @public
     * @async
     * @param {ClaimPayload} payload
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} -  True if the assets were successfully clawbacked
     */
    clawbackRaw(payload: ClaimPayload, params?: WriteParams<typeof erc20IncentiveAbi, 'clawback'>): Promise<{
        hash: `0x${string}`;
        result: boolean;
    }>;
    /**
     * Check if an incentive is claimable. For the POOL strategy, the `bytes data` portion of the payload ignored. The recipient must not have already claimed the incentive.
     *
     * @public
     * @async
     * @param {ClaimPayload} payload
     * @param {?ReadParams} [params]
     * @returns {Promise<boolean>} = True if the incentive is claimable based on the data payload
     */
    isClaimable(payload: ClaimPayload, params?: ReadParams<typeof erc20IncentiveAbi, 'isClaimable'>): Promise<boolean>;
    /**
     * Draw a winner from the raffle. Only callable by owner. Only valid when the strategy is set to `Strategy.RAFFLE`
     *
     * @public
     * @async
     * @param {?WriteParams} [params]
     * @returns {Promise<void>}
     */
    drawRaffle(params?: WriteParams<typeof erc20IncentiveAbi, 'drawRaffle'>): Promise<void>;
    /**
     * Draw a winner from the raffle. Only callable by owner. Only valid when the strategy is set to `Strategy.RAFFLE`
     *
     * @public
     * @async
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: void; }>}
     */
    drawRaffleRaw(params?: WriteParams<typeof erc20IncentiveAbi, 'drawRaffle'>): Promise<{
        hash: `0x${string}`;
        result: void;
    }>;
    /**
     * @inheritdoc
     *
     * @public
     * @param {?ERC20IncentivePayload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {GenericDeployableParams}
     */
    buildParameters(_payload?: ERC20IncentivePayload, _options?: DeployableOptions): GenericDeployableParams;
}
/**
 * Given a {@link ERC20IncentivePayload}, properly encode a `ERC20Incentive.InitPayload` for use with {@link ERC20Incentive} initialization.
 *
 * @param {ERC20IncentivePayload} param0
 * @param {Address} param0.asset - The address of the incentivized asset.
 * @param {StrategyType} param0.strategy - The type of disbursement strategy for the incentive. `StrategyType.MINT` is not supported for `ERC20Incentives`
 * @param {bigint} param0.reward - The amount of the asset to distribute.
 * @param {bigint} param0.limit - How many times can this incentive be claimed.
 * @returns {Hex}
 */
export declare function prepareERC20IncentivePayload({ asset, strategy, reward, limit, }: ERC20IncentivePayload): `0x${string}`;
//# sourceMappingURL=ERC20Incentive.d.ts.map