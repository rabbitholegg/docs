import { waitForTransactionReceipt as f, getAccount as A, getClient as u } from "@wagmi/core";
import { slice as e, isHex as w, keccak256 as i, toHex as m } from "viem";
import { NoContractAddressUponReceiptError as I, InvalidProtocolChainIdError as s } from "./errors.js";
var N = /* @__PURE__ */ ((o) => (o[o.ACTION = 0] = "ACTION", o[o.ALLOW_LIST = 1] = "ALLOW_LIST", o[o.BUDGET = 2] = "BUDGET", o[o.INCENTIVE = 3] = "INCENTIVE", o[o.VALIDATOR = 4] = "VALIDATOR", o))(N || {});
function L(o) {
  return e(w(o) ? i(o) : i(m(o)), 0, 4);
}
async function l(o, c, n) {
  const t = await f(o, {
    ...n,
    hash: await c
  });
  if (!t.contractAddress)
    throw new I(t);
  return t.contractAddress;
}
async function v(o, c, n) {
  const { hash: t, result: a } = await c;
  return await f(o, {
    ...n,
    hash: t
  }), a;
}
function O(o, c, n) {
  let t;
  const a = A(o);
  if (n !== void 0 ? c[n] && (t = n) : a.chainId !== void 0 && c[a.chainId] && (t = a.chainId), t === void 0) {
    const r = u(o);
    r != null && r.chain.id && c[r == null ? void 0 : r.chain.id] && (t = r.chain.id);
  }
  if (t === void 0 && (t = 11155111), !c[t])
    throw new s(
      t,
      Object.keys(c).map(Number)
    );
  return { chainId: t, address: c[t] };
}
export {
  N as RegistryType,
  O as assertValidAddressByChainId,
  v as awaitResult,
  L as bytes4,
  l as getDeployedContractAddress
};
//# sourceMappingURL=utils.js.map
