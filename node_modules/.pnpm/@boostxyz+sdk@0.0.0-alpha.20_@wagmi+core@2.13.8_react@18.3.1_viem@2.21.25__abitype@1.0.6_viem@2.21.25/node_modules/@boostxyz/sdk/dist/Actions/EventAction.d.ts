import { eventActionAbi } from '@boostxyz/evm';
import { type AbiEvent, type AbiFunction, type Address, type ContractFunctionName, type GetLogsReturnType, type Hex, type Transaction } from 'viem';
import type { DeployableOptions, GenericDeployableParams } from '../Deployable/Deployable';
import { DeployableTarget } from '../Deployable/DeployableTarget';
import { type ReadParams, RegistryType, type WriteParams } from '../utils';
/**
 * Filter types used to determine how criteria are evaluated.
 *
 * @export
 * @enum {number}
 */
export declare enum FilterType {
    EQUAL = 0,
    NOT_EQUAL = 1,
    GREATER_THAN = 2,
    LESS_THAN = 3,
    CONTAINS = 4,
    REGEX = 5
}
/**
 * The primitive types supported for filtering.
 *
 * @export
 * @enum {number}
 */
export declare enum PrimitiveType {
    UINT = 0,
    ADDRESS = 1,
    BYTES = 2,
    STRING = 3
}
/**
 * Object representation of a `Criteria` struct used in event actions.
 *
 * @export
 * @interface Criteria
 * @typedef {Criteria}
 */
export interface Criteria {
    /**
     * The filter type used in this criteria.
     *
     * @type {FilterType}
     */
    filterType: FilterType;
    /**
     * The primitive type of the field being filtered.
     *
     * @type {PrimitiveType}
     */
    fieldType: PrimitiveType;
    /**
     * The index in the logs argument array where the field is located.
     *
     * @type {number}
     */
    fieldIndex: number;
    /**
     * The filter data used for complex filtering.
     *
     * @type {Hex}
     */
    filterData: Hex;
}
/**
 * Whether a given signature is an event or function
 *
 * @export
 * @enum {number}
 */
export declare enum SignatureType {
    EVENT = 0,
    FUNC = 1
}
/**
 *  The payload describing how claimants are identified
 *
 * @export
 * @interface ActionClaimant
 * @typedef {ActionClaimant}
 */
export interface ActionClaimant {
    /**
     * Whether claimaint is inferred from event or function
     *
     * @type {SignatureType}
     */
    signatureType: SignatureType;
    /**
     * The 4 byte signature of the event or function
     *
     * @type {Hex}
     */
    signature: Hex;
    /**
     * The index corresponding to claimant.
     *
     * @type {number}
     */
    fieldIndex: number;
    /**
     * The address of the target contract
     *
     * @type {Address}
     */
    targetContract: Address;
    /**
     * The chain id of the target contract.
     * @type {number}
     */
    chainid: number;
}
/**
 * Object representation of an `ActionStep` struct used in event actions.
 *
 * @export
 * @interface ActionStep
 * @typedef {ActionStep}
 */
export interface ActionStep {
    /**
     * The signature of the event.
     *
     * @type {Hex}
     */
    signature: Hex;
    /**
     * Whether claimaint is inferred from event or function
     *
     * @type {SignatureType}
     */
    signatureType: SignatureType;
    /**
     * The type of action being performed.
     *
     * @type {number}
     */
    actionType?: number;
    /**
     * The address of the target contract.
     *
     * @type {Address}
     */
    targetContract: Address;
    /**
     * The chain id of the target contract.
     * @type {number}
     */
    chainid: number;
    /**
     * The criteria used for this action step.
     *
     * @type {Criteria}
     */
    actionParameter: Criteria;
}
/**
 * Parameters for validating an action step.
 *
 * @typedef {Object} ValidateActionStepParams
 * @property {Record<Hex, AbiEvent | AbiFunction>} [knownSignatures] - Optional record of known events, keyed by 32 byte selectors.
 * @property {AbiEvent | AbiFunction} [abiItem] - Optional ABI item definition.
 * @property {EventLogs} [logs] - Event logs to validate against. Required if 'hash' is not provided.
 * @property {Hex} [hash] - Transaction hash to validate against. Required if 'logs' is not provided.
 * @property {number} [chainId] - Chain ID for the transaction. Required if 'hash' is provided.
 */
export type ValidateActionStepParams = {
    knownSignatures?: Record<Hex, AbiEvent | AbiFunction>;
    abiItem?: AbiEvent | AbiFunction;
} & ({
    logs: EventLogs;
} | {
    hash: Hex;
    chainId: number;
});
/**
 * You can either supply a simplified version of the payload, or one that explicitly declares action steps.
 *
 * @export
 * @typedef {EventActionPayload}
 */
export type EventActionPayload = EventActionPayloadSimple | EventActionPayloadRaw;
export interface EventActionPayloadSimple {
    /**
     *  The payload describing how claimants are identified
     *
     * @type {ActionClaimant}
     */
    actionClaimant: ActionClaimant;
    /**
     * Up to 4 action steps.
     * If you supply less than 4, then the last step will be reused to satisfy the EventAction.InitPayload
     * Any more than 4 will throw an error.
     *
     * @type {ActionStep[]}
     */
    actionSteps: ActionStep[];
}
export type ActionStepTuple = [ActionStep, ActionStep, ActionStep, ActionStep];
/**
 * Typeguard to determine if a user is supplying a simple or raw EventActionPayload
 *
 * @param {*} opts
 * @returns {opts is EventActionPayloadSimple}
 */
export declare function isEventActionPayloadSimple(opts: EventActionPayload): opts is EventActionPayloadSimple;
/**
 * Object representation of an `InitPayload` struct used to initialize event actions.
 *
 * @export
 * @interface EventActionPayloadRaw
 * @typedef {EventActionPayloadRaw}
 */
export interface EventActionPayloadRaw {
    /**
     *  The payload describing how claimants are identified
     *
     * @type {ActionClaimant}
     */
    actionClaimant: ActionClaimant;
    /**
     * The first action step.
     *
     * @type {ActionStep}
     */
    actionStepOne: ActionStep;
    /**
     * The second action step.
     *
     * @type {ActionStep}
     */
    actionStepTwo: ActionStep;
    /**
     * The third action step.
     *
     * @type {ActionStep}
     */
    actionStepThree: ActionStep;
    /**
     * The fourth action step.
     *
     * @type {ActionStep}
     */
    actionStepFour: ActionStep;
}
/**
 * Array of event logs to pass into TxParams
 * @export
 * @typedef {EventLogs}
 */
export type EventLogs = GetLogsReturnType<AbiEvent, AbiEvent[], true>;
/**
 * Getter params from the event action contract
 *
 * @export
 * @typedef {ReadEventActionParams}
 * @param {fnName} fnName - The getter function name
 */
export type ReadEventActionParams<fnName extends ContractFunctionName<typeof eventActionAbi, 'pure' | 'view'>> = ReadParams<typeof eventActionAbi, fnName>;
/**
 * A generic event action
 *
 * @export
 * @class EventAction
 * @typedef {EventAction}
 * @extends {DeployableTarget<EventActionPayload>}
 */
export declare class EventAction extends DeployableTarget<EventActionPayload, typeof eventActionAbi> {
    /**
     * @inheritdoc
     *
     * @public
     * @readonly
     * @type {*}
     */
    readonly abi: readonly [{
        readonly type: "constructor";
        readonly inputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "CloneAlreadyInitialized";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InitializerNotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitialization";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "InvalidInitializationData";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotImplemented";
    }, {
        readonly type: "error";
        readonly inputs: readonly [];
        readonly name: "NotInitializing";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "executor";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "caller";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: false;
        }, {
            readonly name: "success";
            readonly internalType: "bool";
            readonly type: "bool";
            readonly indexed: false;
        }, {
            readonly name: "data";
            readonly internalType: "bytes";
            readonly type: "bytes";
            readonly indexed: false;
        }];
        readonly name: "ActionExecuted";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "user";
            readonly internalType: "address";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "isValidated";
            readonly internalType: "bool";
            readonly type: "bool";
            readonly indexed: false;
        }, {
            readonly name: "data";
            readonly internalType: "bytes";
            readonly type: "bytes";
            readonly indexed: false;
        }];
        readonly name: "ActionValidated";
    }, {
        readonly type: "event";
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly name: "version";
            readonly internalType: "uint64";
            readonly type: "uint64";
            readonly indexed: false;
        }];
        readonly name: "Initialized";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "VALIDATOR";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "contract AValidator";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "execute";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }, {
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly stateMutability: "payable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getActionClaimant";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "struct AEventAction.ActionClaimant";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "signatureType";
                readonly internalType: "enum AEventAction.SignatureType";
                readonly type: "uint8";
            }, {
                readonly name: "signature";
                readonly internalType: "bytes32";
                readonly type: "bytes32";
            }, {
                readonly name: "fieldIndex";
                readonly internalType: "uint8";
                readonly type: "uint8";
            }, {
                readonly name: "targetContract";
                readonly internalType: "address";
                readonly type: "address";
            }, {
                readonly name: "chainid";
                readonly internalType: "uint256";
                readonly type: "uint256";
            }];
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "index";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly name: "getActionStep";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "struct AEventAction.ActionStep";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "signature";
                readonly internalType: "bytes32";
                readonly type: "bytes32";
            }, {
                readonly name: "signatureType";
                readonly internalType: "enum AEventAction.SignatureType";
                readonly type: "uint8";
            }, {
                readonly name: "actionType";
                readonly internalType: "uint8";
                readonly type: "uint8";
            }, {
                readonly name: "targetContract";
                readonly internalType: "address";
                readonly type: "address";
            }, {
                readonly name: "chainid";
                readonly internalType: "uint256";
                readonly type: "uint256";
            }, {
                readonly name: "actionParameter";
                readonly internalType: "struct AEventAction.Criteria";
                readonly type: "tuple";
                readonly components: readonly [{
                    readonly name: "filterType";
                    readonly internalType: "enum AEventAction.FilterType";
                    readonly type: "uint8";
                }, {
                    readonly name: "fieldType";
                    readonly internalType: "enum AEventAction.PrimitiveType";
                    readonly type: "uint8";
                }, {
                    readonly name: "fieldIndex";
                    readonly internalType: "uint8";
                    readonly type: "uint8";
                }, {
                    readonly name: "filterData";
                    readonly internalType: "bytes";
                    readonly type: "bytes";
                }];
            }];
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getActionSteps";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "struct AEventAction.ActionStep[]";
            readonly type: "tuple[]";
            readonly components: readonly [{
                readonly name: "signature";
                readonly internalType: "bytes32";
                readonly type: "bytes32";
            }, {
                readonly name: "signatureType";
                readonly internalType: "enum AEventAction.SignatureType";
                readonly type: "uint8";
            }, {
                readonly name: "actionType";
                readonly internalType: "uint8";
                readonly type: "uint8";
            }, {
                readonly name: "targetContract";
                readonly internalType: "address";
                readonly type: "address";
            }, {
                readonly name: "chainid";
                readonly internalType: "uint256";
                readonly type: "uint256";
            }, {
                readonly name: "actionParameter";
                readonly internalType: "struct AEventAction.Criteria";
                readonly type: "tuple";
                readonly components: readonly [{
                    readonly name: "filterType";
                    readonly internalType: "enum AEventAction.FilterType";
                    readonly type: "uint8";
                }, {
                    readonly name: "fieldType";
                    readonly internalType: "enum AEventAction.PrimitiveType";
                    readonly type: "uint8";
                }, {
                    readonly name: "fieldIndex";
                    readonly internalType: "uint8";
                    readonly type: "uint8";
                }, {
                    readonly name: "filterData";
                    readonly internalType: "bytes";
                    readonly type: "bytes";
                }];
            }];
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getActionStepsCount";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "uint256";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [];
        readonly name: "getComponentInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly stateMutability: "pure";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "data_";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly name: "prepare";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bytes";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
    }, {
        readonly type: "function";
        readonly inputs: readonly [{
            readonly name: "interfaceId";
            readonly internalType: "bytes4";
            readonly type: "bytes4";
        }];
        readonly name: "supportsInterface";
        readonly outputs: readonly [{
            readonly name: "";
            readonly internalType: "bool";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
    }];
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {Record<number, Address>}
     */
    static bases: Record<number, Address>;
    /**
     * @inheritdoc
     *
     * @public
     * @static
     * @type {RegistryType}
     */
    static registryType: RegistryType;
    /**
     * Gets a specific action event by index
     *
     * @public
     * @async
     * @param {number} index The index of the action event to retrieve
     * @param {?ReadEventActionParams<'getActionStep'>} [params]
     * @returns {Promise<ActionStep>}
     */
    getActionStep(index: number, params?: ReadEventActionParams<'getActionStep'>): Promise<ActionStep | undefined>;
    /**
     * Gets all action events
     *
     * @public
     * @async
     * @param {?ReadEventActionParams<'getActionSteps'>} [params]
     * @returns {Promise<ActionStep[]>}
     */
    getActionSteps(params?: ReadEventActionParams<'getActionSteps'>): Promise<ActionStep[]>;
    /**
     * Gets the count of action events
     *
     * @public
     * @async
     * @param {?ReadEventActionParams<'getActionStepsCount'>} [params]
     * @returns {Promise<bigint>}
     */
    getActionStepsCount(params?: ReadEventActionParams<'getActionStepsCount'>): Promise<number>;
    /**
     * Retrieves the payload describing how claimants can be identified from logs or function calls.
     *
     * @public
     * @async
     * @param {?ReadEventActionParams<'getActionClaimant'>} [params]
     * @returns {Promise<ActionClaimant>}
     */
    getActionClaimant(params?: ReadEventActionParams<'getActionClaimant'>): Promise<ActionClaimant>;
    /**
     * Executes a prepared event action
     *
     * @public
     * @async
     * @param {Hex} data
     * @param {?WriteParams} [params]
     * @returns {Promise<readonly [boolean, `0x${string}`]>}
     */
    execute(data: Hex, params?: WriteParams<typeof eventActionAbi, 'execute'>): Promise<readonly [boolean, `0x${string}`]>;
    /**
     * Executes a prepared event action
     *
     * @public
     * @async
     * @param {Hex} data
     * @param {?WriteParams} [params]
     * @returns {Promise<{ hash: `0x${string}`; result: readonly [boolean, `0x${string}`]; }>}
     */
    executeRaw(data: Hex, params?: WriteParams<typeof eventActionAbi, 'execute'>): Promise<{
        hash: `0x${string}`;
        result: readonly [boolean, `0x${string}`];
    }>;
    /**
     * Derives the action claimant address from a transaction based on the provided ActionClaimant configuration.
     * This method supports both event-based and function-based claimant derivation.
     *
     ** @example
     * // Example usage
     * const eventAction = boost.action as EventAction
     * const claimant = await eventAction.getActionClaimant() // {
     *   signatureType: SignatureType.EVENT,
     *   signature: '0x1234...',
     *   fieldIndex: 2,
     *   targetContract: '0xabcd...',
     *   chainid: 1
     * };
     * const params: ValidateActionStepParams = {
     *   hash: '0x5678...',
     *   chainId: 1,
     *   knownSignatures?: {
     *     '0x1234...': {}
     *   }
     * };
     * const claimantAddress = await eventAction.deriveActionClaimantFromTransaction(claimant, params);
     *
     * @param {ActionClaimant} claimant - The configuration specifying how to derive the claimant.
     * @param {ValidateActionStepParams} params - Parameters for validation, including transaction hash, known signatures, logs, and chain ID.
     * @returns {Promise<Address | undefined>} The derived claimant address if found, undefined otherwise.
     * @throws {ValidationAbiMissingError} If the ABI for the specified signature is not found.
     * @throws {FunctionDataDecodeError} If there's an error decoding function data (for function-based derivation).
     */
    deriveActionClaimantFromTransaction(claimant: ActionClaimant, params: ValidateActionStepParams): Promise<Address | undefined>;
    /**
     * Validates the action claimant against the arguments of a log or function data.
     *
     * @param {ActionClaimant} claimant - The action claimant to validate.
     * @param {Object} [logOrFnData] - Optional object containing the arguments to validate against.
     * @param {Array<any> | readonly unknown[] | Record<string, unknown>} [logOrFnData.args] - The arguments from the log or function data.
     * @returns {Address | undefined} The validated address if found and valid, otherwise undefined.
     */
    validateClaimantAgainstArgs(claimant: ActionClaimant, logOrFnData?: {
        args: Array<unknown> | readonly unknown[] | Record<string, unknown>;
    }): Address | undefined;
    /**
     * Retrieves action steps, and uses them to validate against, and optionally fetch logs that match the step's signature.
     * If logs are provided in the optional `params` argument, then those logs will be used instead of fetched with the configured client.
     *
     * @public
     * @async
     * @param ValidateActionStepParams params
     * @returns {Promise<boolean>}
     */
    validateActionSteps(params: ValidateActionStepParams): Promise<boolean>;
    /**
     * Validates a single action step with a given criteria against logs or function calls.
     * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.
     * For functions a hash is required.
     *
     * @public
     * @async
     * @param {ActionStep} actionStep - The action step to validate. Can be a function of event step.
     * @param {ValidateActionStepParams} params - Additional parameters for validation, including hash, known events, logs, and chain ID.
     * @returns {Promise<boolean>}
     */
    isActionStepValid(actionStep: ActionStep, params: ValidateActionStepParams): Promise<boolean>;
    /**
     * Validates a single action event with a given criteria against logs.
     * If logs are provided in the optional `params` argument, then those logs will be used instead of being fetched with the configured client.
     *
     * @public
     * @async
     * @param {ActionStep} actionStep - The action step containing the event to validate.
     * @param {EventLogs} logs - Event logs to validate the given step against
     * @returns {Promise<boolean>} Resolves to true if the action event is valid, throws if input is invalid, otherwise false.
     */
    isActionEventValid(actionStep: ActionStep, logs: EventLogs): boolean;
    /**
     * Validates a single action function with a given criteria against the transaction input.
     *
     * @public
     * @param {ActionStep} actionStep - The action step containing the function to validate.
     * @param {Transaction} transaction - The transaction that will be validated against.
     * @param {Object} [params] - Optional parameters for validation.
     * @param {AbiItem} [params.abiItem] - The ABI item for the function, if known.
     * @param {Record<Hex, AbiEvent | AbiFunction>} [params.knownSignatures] - A record of known signatures.
     * @returns {boolean} Returns true if the action function is valid, false otherwise.
     * @throws {ValidationAbiMissingError} Throws if the ABI for the function signature is not found.
     * @throws {FunctionDataDecodeError} Throws if there's an error decoding the function data.
     */
    isActionFunctionValid(actionStep: ActionStep, transaction: Transaction, params?: Pick<ValidateActionStepParams, 'abiItem' | 'knownSignatures'>): boolean;
    /**
     * Validates a field against a given criteria.
     *
     * @param {Criteria} criteria - The criteria to validate against.
     * @param {string | bigint | Hex} fieldValue - The field value to validate.
     * @param {Object} input - Additional context for validation.
     * @param {EventLogs[0]} [input.log] - The event log, if validating an event.
     * @param {readonly (string | bigint)[]} [input.decodedArgs] - The decoded function arguments, if validating a function call.
     * @returns {Promise<boolean>} - Returns true if the field passes the criteria, false otherwise.
     */
    validateFieldAgainstCriteria(criteria: Criteria, fieldValue: string | bigint | Hex, input: {
        log: EventLogs[0];
    } | {
        decodedArgs: readonly (string | bigint)[];
    }): boolean;
    /**
     * Validates a {@link Log} against a given criteria.
     *
     * @param {Criteria} criteria - The criteria to validate against.
     * @param {Log} log - The Viem event log.
     * @returns {boolean} - Returns true if the log passes the criteria, false otherwise.
     */
    validateLogAgainstCriteria(criteria: Criteria, log: EventLogs[0]): boolean;
    /**
     * Validates a function's decoded arguments against a given criteria.
     *
     * @param {Criteria} criteria - The criteria to validate against.
     * @param {unknown[]} decodedArgs - The decoded arguments of the function call.
     * @returns {Promise<boolean>} - Returns true if the decoded argument passes the criteria, false otherwise.
     */
    validateFunctionAgainstCriteria(criteria: Criteria, decodedArgs: readonly (string | bigint)[]): boolean;
    /**
     * @inheritdoc
     *
     * @public
     * @param {?EventActionPayload} [_payload]
     * @param {?DeployableOptions} [_options]
     * @returns {GenericDeployableParams}
     */
    buildParameters(_payload?: EventActionPayload, _options?: DeployableOptions): GenericDeployableParams;
    isArraylikeIndexed(step: ActionStep, event: AbiEvent): boolean;
}
/**
 * Function to properly encode an event action payload.
 *
 * @param {InitPayload} param0
 * @param {ActionStep} param0.actionStepOne - The first action step to initialize.
 * @param {ActionStep} param0.actionStepTwo - The second action step to initialize.
 * @param {ActionStep} param0.actionStepThree - The third action step to initialize.
 * @param {ActionStep} param0.actionStepFour - The fourth action step to initialize.
 * @returns {Hex}
 */
export declare function prepareEventActionPayload({ actionClaimant, actionStepOne, actionStepTwo, actionStepThree, actionStepFour, }: EventActionPayloadRaw): `0x${string}`;
//# sourceMappingURL=EventAction.d.ts.map