{"version":3,"file":"Incentive-Djnzseoj.cjs","sources":["../src/Incentives/ERC20VariableIncentive.ts","../src/Incentives/Incentive.ts"],"sourcesContent":["import {\n  erc20VariableIncentiveAbi,\n  readErc20VariableIncentiveAsset,\n  readErc20VariableIncentiveClaimed,\n  readErc20VariableIncentiveClaims,\n  readErc20VariableIncentiveCurrentReward,\n  readErc20VariableIncentiveIsClaimable,\n  readErc20VariableIncentiveLimit,\n  readErc20VariableIncentiveOwner,\n  readErc20VariableIncentiveReward,\n  readErc20VariableIncentiveTotalClaimed,\n  simulateErc20VariableIncentiveClaim,\n  simulateErc20VariableIncentiveClawback,\n  writeErc20VariableIncentiveClaim,\n  writeErc20VariableIncentiveClawback,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/incentives/ERC20VariableIncentive.sol/ERC20VariableIncentive.json';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  encodeAbiParameters,\n} from 'viem';\nimport { ERC20VariableIncentive as ERC20VariableIncentiveBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport { type ClaimPayload, prepareClaimPayload } from '../claiming';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\n\nexport { erc20VariableIncentiveAbi };\n/**\n * The object representation of a `ERC20VariableIncentivePayload.InitPayload`\n *\n * @export\n * @interface ERC20VariableIncentivePayload\n * @typedef {ERC20VariableIncentivePayload}\n */\nexport interface ERC20VariableIncentivePayload {\n  /**\n   * The address of the incentivized asset.\n   *\n   * @type {Address}\n   */\n  asset: Address;\n  /**\n   * The amount of the asset to distribute.\n   *\n   * @type {bigint}\n   */\n  reward: bigint;\n  /**\n   * The total spending limit of the asset that will be distributed.\n   *\n   * @type {bigint}\n   */\n  limit: bigint;\n}\n\n/**\n * A generic `viem.Log` event with support for `ERC20VariableIncentive` event types.\n *\n * @export\n * @typedef {ERC20VariableIncentiveLog}\n * @template {ContractEventName<typeof erc20VariableIncentiveAbi>} [event=ContractEventName<\n *     typeof erc20VariableIncentiveAbi\n *   >]\n */\nexport type ERC20VariableIncentiveLog<\n  event extends ContractEventName<\n    typeof erc20VariableIncentiveAbi\n  > = ContractEventName<typeof erc20VariableIncentiveAbi>,\n> = GenericLog<typeof erc20VariableIncentiveAbi, event>;\n\n/**\n *  A modified ERC20 incentive implementation that allows claiming of variable token amounts with a spending limit\n *\n * @export\n * @class ERC20VariableIncentive\n * @typedef {ERC20VariableIncentive}\n * @extends {DeployableTarget<ERC20VariableIncentivePayload>}\n */\nexport class ERC20VariableIncentive extends DeployableTarget<\n  ERC20VariableIncentivePayload,\n  typeof erc20VariableIncentiveAbi\n> {\n  public override readonly abi = erc20VariableIncentiveAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(ERC20VariableIncentiveBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.INCENTIVE;\n\n  /**\n   * The owner of the incentive\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public async owner(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'owner'>,\n  ) {\n    return await readErc20VariableIncentiveOwner(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The total amount of rewards claimed\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async totalClaimed(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'totalClaimed'>,\n  ) {\n    return await readErc20VariableIncentiveTotalClaimed(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The current reward\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The current reward\n   */\n  public async currentReward(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'currentReward'>,\n  ) {\n    return await readErc20VariableIncentiveCurrentReward(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The number of claims that have been made\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async claims(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'claims'>,\n  ) {\n    return await readErc20VariableIncentiveClaims(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * A mapping of address to claim status\n   *\n   * @public\n   * @async\n   * @param {Address} address\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>}\n   */\n  public async claimed(\n    address: Address,\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'claimed'>,\n  ) {\n    return await readErc20VariableIncentiveClaimed(this._config, {\n      address: this.assertValidAddress(),\n      args: [address],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The address of the ERC20-like token\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public async asset(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'asset'>,\n  ) {\n    return await readErc20VariableIncentiveAsset(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The reward amount issued for each claim\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async reward(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'reward'>,\n  ) {\n    return await readErc20VariableIncentiveReward(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * The limit (max claims, or max entries for raffles)\n   *\n   * @public\n   * @async\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>}\n   */\n  public async limit(\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'limit'>,\n  ) {\n    return await readErc20VariableIncentiveLimit(this._config, {\n      address: this.assertValidAddress(),\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Claim the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - Returns true if successfully claimed\n   */\n  protected async claim(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof erc20VariableIncentiveAbi, 'claim'>,\n  ) {\n    return await this.awaitResult(this.claimRaw(payload, params));\n  }\n\n  /**\n   * Claim the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - Returns true if successfully claimed\n   */\n  protected async claimRaw(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof erc20VariableIncentiveAbi, 'claim'>,\n  ) {\n    const { request, result } = await simulateErc20VariableIncentiveClaim(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareClaimPayload(payload)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeErc20VariableIncentiveClaim(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Clawback assets from the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} -  True if the assets were successfully clawbacked\n   */\n  public async clawback(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof erc20VariableIncentiveAbi, 'clawback'>,\n  ) {\n    return await this.awaitResult(this.clawbackRaw(payload, params));\n  }\n\n  /**\n   * Clawback assets from the incentive\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} -  True if the assets were successfully clawbacked\n   */\n  public async clawbackRaw(\n    payload: ClaimPayload,\n    params?: WriteParams<typeof erc20VariableIncentiveAbi, 'clawback'>,\n  ) {\n    const { request, result } = await simulateErc20VariableIncentiveClawback(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareClaimPayload(payload)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeErc20VariableIncentiveClawback(\n      this._config,\n      request,\n    );\n    return { hash, result };\n  }\n\n  /**\n   * Check if an incentive is claimable. For the POOL strategy, the `bytes data` portion of the payload ignored. The recipient must not have already claimed the incentive.\n   *\n   * @public\n   * @async\n   * @param {ClaimPayload} payload\n   * @param {?ReadParams} [params]\n   * @returns {Promise<boolean>} = True if the incentive is claimable based on the data payload\n   */\n  public async isClaimable(\n    payload: ClaimPayload,\n    params?: ReadParams<typeof erc20VariableIncentiveAbi, 'isClaimable'>,\n  ) {\n    return await readErc20VariableIncentiveIsClaimable(this._config, {\n      address: this.assertValidAddress(),\n      args: [prepareClaimPayload(payload)],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?ERC20VariableIncentivePayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: ERC20VariableIncentivePayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    return {\n      abi: erc20VariableIncentiveAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareERC20VariableIncentivePayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Given a {@link ERC20VariableIncentivePayload}, properly encode a ` ERC20VariableIncentive.InitPayload` for use with {@link ERC20VariableIncentive} initialization.\n *\n * @param {ERC20VariableIncentivePayload} param0\n * @param {Address} param0.asset - The address of the incentivized asset.\n * @param {bigint} param0.reward - The amount of the asset to distribute.\n * @param {bigint} param0.limit - How many times can this incentive be claimed.\n * @returns {Hex}\n */\nexport function prepareERC20VariableIncentivePayload({\n  asset,\n  reward,\n  limit,\n}: ERC20VariableIncentivePayload) {\n  return encodeAbiParameters(\n    [\n      { type: 'address', name: 'asset' },\n      { type: 'uint256', name: 'reward' },\n      { type: 'uint256', name: 'limit' },\n    ],\n    [asset, reward, limit],\n  );\n}\n","import { aIncentiveAbi } from '@boostxyz/evm';\nimport {\n  AAllowListIncentive,\n  ACGDAIncentive,\n  AERC20Incentive,\n  AERC20VariableIncentive,\n  APointsIncentive,\n} from '@boostxyz/evm/deploys/componentInterfaces.json';\nimport { readContract } from '@wagmi/core';\nimport type { Address, Hex } from 'viem';\nimport type { DeployableOptions } from '../Deployable/Deployable';\nimport { InvalidComponentInterfaceError } from '../errors';\nimport { AllowListIncentive } from './AllowListIncentive';\nimport { CGDAIncentive } from './CGDAIncentive';\nimport { ERC20Incentive } from './ERC20Incentive';\nimport type { ERC20VariableCriteriaIncentive } from './ERC20VariableCriteriaIncentive';\nimport { ERC20VariableIncentive } from './ERC20VariableIncentive';\n// import { ERC1155Incentive } from './ERC1155Incentive';\nimport { PointsIncentive } from './PointsIncentive';\n\nexport {\n  AllowListIncentive,\n  CGDAIncentive,\n  // ERC1155Incentive,\n  ERC20Incentive,\n  PointsIncentive,\n  ERC20VariableIncentive,\n};\n\n/**\n * A union type representing all valid protocol Incentive implementations\n *\n * @export\n * @typedef {Incentive}\n */\nexport type Incentive =\n  | AllowListIncentive\n  | CGDAIncentive\n  | ERC20Incentive\n  // | ERC1155Incentive\n  | PointsIncentive\n  | ERC20VariableIncentive\n  | ERC20VariableCriteriaIncentive;\n\n/**\n * A map of Incentive component interfaces to their constructors.\n *\n * @type {{ \"0xc5b24b8e\": typeof PointsIncentive; \"0x8c901437\": typeof ERC20Incentive; \"0x0a466e6f\": typeof AllowListIncentive; \"0xa39e44d9\": typeof CGDAIncentive; \"0x6060409d\": typeof ERC20VariableIncentive }}\n */\nexport const IncentiveByComponentInterface = {\n  [APointsIncentive as Hex]: PointsIncentive,\n  [AERC20Incentive as Hex]: ERC20Incentive,\n  [AAllowListIncentive]: AllowListIncentive,\n  // [AERC1155Incentive as Hex]: ERC1155Incentive,\n  [ACGDAIncentive as Hex]: CGDAIncentive,\n  [AERC20VariableIncentive as Hex]: ERC20VariableIncentive,\n};\n\n/**\n * A function that will read a contract's component interface using `getComponentInterface` and return the correct instantiated instance.\n *\n * @export\n * @async\n * @param {DeployableOptions} options\n * @param {Address} address\n * @returns {Incentive}\n * @throws {@link InvalidComponentInterfaceError}\n */\nexport async function incentiveFromAddress(\n  options: DeployableOptions,\n  address: Address,\n) {\n  const interfaceId = (await readContract(options.config, {\n    abi: aIncentiveAbi,\n    functionName: 'getComponentInterface',\n    address,\n  })) as keyof typeof IncentiveByComponentInterface;\n  const Ctor = IncentiveByComponentInterface[interfaceId];\n  if (!Ctor) {\n    throw new InvalidComponentInterfaceError(\n      Object.keys(IncentiveByComponentInterface) as Hex[],\n      interfaceId as Hex,\n    );\n  }\n  return new Ctor(options, address);\n}\n"],"names":["_ERC20VariableIncentive","DeployableTarget","erc20VariableIncentiveAbi","params","readErc20VariableIncentiveOwner","readErc20VariableIncentiveTotalClaimed","readErc20VariableIncentiveCurrentReward","readErc20VariableIncentiveClaims","address","readErc20VariableIncentiveClaimed","readErc20VariableIncentiveAsset","readErc20VariableIncentiveReward","readErc20VariableIncentiveLimit","payload","request","result","simulateErc20VariableIncentiveClaim","prepareClaimPayload","writeErc20VariableIncentiveClaim","simulateErc20VariableIncentiveClawback","writeErc20VariableIncentiveClawback","readErc20VariableIncentiveIsClaimable","_payload","_options","options","bytecode","prepareERC20VariableIncentivePayload","ERC20VariableIncentiveBases","RegistryType","ERC20VariableIncentive","asset","reward","limit","encodeAbiParameters","IncentiveByComponentInterface","APointsIncentive","PointsIncentive","AERC20Incentive","ERC20Incentive","AAllowListIncentive","AllowListIncentive","ACGDAIncentive","CGDAIncentive","AERC20VariableIncentive","incentiveFromAddress","interfaceId","readContract","aIncentiveAbi","Ctor","InvalidComponentInterfaceError"],"mappings":"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"}