{"version":3,"file":"utils.js","sources":["../src/utils.ts"],"sourcesContent":["import {\n  type Config,\n  type ReadContractParameters,\n  type WatchContractEventParameters,\n  type WriteContractParameters,\n  getAccount,\n  getClient,\n  waitForTransactionReceipt,\n} from '@wagmi/core';\nimport type { ExtractAbiEvent } from 'abitype';\nimport type {\n  Abi,\n  AbiEvent,\n  Address,\n  ContractEventName,\n  ContractFunctionName,\n  GetLogsParameters,\n  Hash,\n  Hex,\n  Log,\n  WaitForTransactionReceiptParameters,\n} from 'viem';\nimport { isHex, keccak256, slice, toHex } from 'viem';\nimport {\n  InvalidProtocolChainIdError,\n  NoConnectedChainIdError,\n  NoContractAddressUponReceiptError,\n} from './errors';\n\nexport type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;\n\n/**\n * Enum encapsulating all the different types of targets used in the Boost V2 Protocol.\n *\n * @export\n * @enum {number}\n */\nexport enum RegistryType {\n  ACTION = 0,\n  ALLOW_LIST = 1,\n  BUDGET = 2,\n  INCENTIVE = 3,\n  VALIDATOR = 4,\n}\n\n/**\n * Helper type that encapsulates common writeContract parameters without fields like `abi`, `args`, `functionName`, `address` that are expected to be provided the SDK.\n * See (writeContract)[https://viem.sh/docs/contract/writeContract]\n *\n * @export\n * @typedef {WriteParams}\n * @template {Abi} abi\n * @template {ContractFunctionName<abi>} functionName\n */\nexport type WriteParams<\n  abi extends Abi = Abi,\n  functionName extends ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = Partial<\n  Omit<\n    WriteContractParameters<abi, functionName>,\n    'address' | 'args' | 'functionName' | 'abi'\n  >\n>;\n\n/**\n * Helper type that encapsulates common readContract parameters without fields like `abi`, `args`, `functionName`, `address` that are expected to be provided the SDK.\n * See (readContract)[https://viem.sh/docs/contract/readContract]\n *\n * @export\n * @typedef {ReadParams}\n * @template {Abi} abi\n * @template {ContractFunctionName<abi>} functionName\n */\nexport type ReadParams<\n  abi extends Abi,\n  functionName extends ContractFunctionName<abi>,\n> = Partial<\n  Omit<\n    ReadContractParameters<abi, functionName>,\n    'address' | 'args' | 'functionName' | 'abi'\n  >\n>;\n\n/**\n * Helper type that encapsulates common `watchContractEvent` parameters without fields like `address`, and `abi` that are expected to be provided the SDK.\n * See (watchContractEvent)[https://wagmi.sh/core/api/actions/watchContractEvent]\n *\n * @export\n * @typedef {WatchParams}\n * @template {Abi} abi\n * @template {ContractEventName<abi> | undefined} [eventName=undefined]\n */\nexport type WatchParams<\n  abi extends Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n> = Partial<\n  Omit<WatchContractEventParameters<abi, eventName>, 'address' | 'abi'>\n>;\n\n/**\n * Helper type that encapsulates common `getLogs` parameters without fields like `address` that are expected to be provided the SDK.\n * See (getLogs)[https://viem.sh/docs/actions/public/getLogs#getlogs]\n *\n * @export\n * @typedef {GetLogsParams}\n * @template {Abi} abi\n * @template {ContractEventName<abi>} event\n * @template {ExtractAbiEvent<abi, event>} [abiEvent=ExtractAbiEvent<abi, event>]\n * @template {| readonly AbiEvent[]\n *     | readonly unknown[]\n *     | undefined} [abiEvents=abiEvent extends AbiEvent ? [abiEvent] : undefined]\n */\nexport type GetLogsParams<\n  abi extends Abi,\n  event extends ContractEventName<abi>,\n  abiEvent extends ExtractAbiEvent<abi, event> = ExtractAbiEvent<abi, event>,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n> = Partial<Omit<GetLogsParameters<abiEvent, abiEvents>, 'address'>> & {\n  chainId?: number | undefined;\n};\n\n/**\n * A generic `viem.Log` event with typed `args` support via a given `Abi` and `ContractEventName`\n *\n * @export\n * @typedef {GenericLog}\n * @template {Abi} abi\n * @template {ContractEventName<abi>} [event=ContractEventName<abi>]\n */\nexport type GenericLog<\n  abi extends Abi,\n  event extends ContractEventName<abi> = ContractEventName<abi>,\n> = Log<bigint, number, false, ExtractAbiEvent<abi, event>, false>;\n\n/**\n * Helper utility to convert a string to a `bytes4` type\n *\n * @export\n * @param {string} input\n * @returns {Hex}\n */\nexport function bytes4(input: string) {\n  return slice(isHex(input) ? keccak256(input) : keccak256(toHex(input)), 0, 4);\n}\n\n/**\n * Utility function to wait for a transaction receipt, and extract the contractAddress\n *\n * @export\n * @async\n * @param {WagmiConfig} config - [Wagmi Configuration](https://wagmi.sh/core/api/createConfig)\n * @param {Promise<Hash>} hash - A transaction hash promise\n * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams] - @see {@link WaitForTransactionReceiptParameters}\n * @returns {Promise<Address>}\n * @throws {@link NoContractAddressUponReceiptError} if no `contractAddress` exists after the transaction has been received\n */\nexport async function getDeployedContractAddress(\n  config: Config,\n  hash: Promise<Hash>,\n  waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n) {\n  const receipt = await waitForTransactionReceipt(config, {\n    ...waitParams,\n    hash: await hash,\n  });\n  if (!receipt.contractAddress)\n    throw new NoContractAddressUponReceiptError(receipt);\n  return receipt.contractAddress;\n}\n\n/**\n * Utility type to encapsulate a transaction hash, and the simulated result prior to submitting the transaction.\n *\n * @export\n * @typedef {HashAndSimulatedResult}\n * @template [T=unknown]\n */\nexport type HashAndSimulatedResult<T = unknown> = { hash: Hash; result: T };\n\n/**\n * Helper function to wait for a transaction receipt given a hash promise.\n *\n * @export\n * @async\n * @template [Result=unknown]\n * @param {WagmiConfig} config\n * @param {Promise<HashAndSimulatedResult<Result>>} hashPromise\n * @param {?Omit<WaitForTransactionReceiptParameters, 'hash'>} [waitParams]\n * @returns {Promise<Result>}\n */\nexport async function awaitResult<Result = unknown>(\n  config: Config,\n  hashPromise: Promise<HashAndSimulatedResult<Result>>,\n  waitParams?: Omit<WaitForTransactionReceiptParameters, 'hash'>,\n): Promise<Result> {\n  const { hash, result } = await hashPromise;\n  await waitForTransactionReceipt(config, {\n    ...waitParams,\n    hash,\n  });\n  return result;\n}\n\n/**\n * Given a wagmi config and a map of chain id's to addresses, determine an address/chainId combo that maps to the currently connected chain id, or throw a typed error.\n *\n * @export\n * @param {Config} config\n * @param {Record<string, Address>} addressByChainId\n * @param {number} desiredChainId\n * @returns {{ chainId: number, address: Address }}\n * @throws {@link InvalidProtocolChainIdError}\n */\nexport function assertValidAddressByChainId(\n  config: Config,\n  addressByChainId: Record<number, Address>,\n  desiredChainId?: number,\n): { chainId: number; address: Address } {\n  let chainId: number | undefined = undefined;\n  const wagmiAccount = getAccount(config);\n  // if manually providing a chain id for some contract operation, try to use it\n  if (desiredChainId !== undefined) {\n    if (addressByChainId[desiredChainId]) chainId = desiredChainId;\n  } else if (wagmiAccount.chainId !== undefined) {\n    // otherwise if we can get the current chain id off the connected account and it matches one of ours, use it\n    if (addressByChainId[wagmiAccount.chainId]) chainId = wagmiAccount.chainId;\n  }\n  // chainId is still undefined, try to get chain id off viem client\n  if (chainId === undefined) {\n    const client = getClient(config);\n    if (client?.chain.id && addressByChainId[client?.chain.id])\n      chainId = client.chain.id;\n  }\n  // if chainId is STILL undefined, use our default addresses\n  // TODO: update this when on prod network\n  if (chainId === undefined) chainId = Number(__DEFAULT_CHAIN_ID__);\n  if (!addressByChainId[chainId])\n    throw new InvalidProtocolChainIdError(\n      chainId,\n      Object.keys(addressByChainId).map(Number),\n    );\n  // biome-ignore lint/style/noNonNullAssertion: this type should be narrowed by the above statement but isn't?\n  return { chainId, address: addressByChainId[chainId]! };\n}\n"],"names":["RegistryType","bytes4","input","slice","isHex","keccak256","toHex","getDeployedContractAddress","config","hash","waitParams","receipt","waitForTransactionReceipt","NoContractAddressUponReceiptError","awaitResult","hashPromise","result","assertValidAddressByChainId","addressByChainId","desiredChainId","chainId","wagmiAccount","getAccount","client","getClient","InvalidProtocolChainIdError"],"mappings":";;;AAqCY,IAAAA,sBAAAA,OACVA,EAAAA,EAAA,SAAS,CAAT,IAAA,UACAA,EAAAA,EAAA,aAAa,CAAb,IAAA,cACAA,EAAAA,EAAA,SAAS,CAAT,IAAA,UACAA,EAAAA,EAAA,YAAY,CAAZ,IAAA,aACAA,EAAAA,EAAA,YAAY,CAAZ,IAAA,aALUA,IAAAA,KAAA,CAAA,CAAA;AA2GL,SAASC,EAAOC,GAAe;AACpC,SAAOC,EAAMC,EAAMF,CAAK,IAAIG,EAAUH,CAAK,IAAIG,EAAUC,EAAMJ,CAAK,CAAC,GAAG,GAAG,CAAC;AAC9E;AAasB,eAAAK,EACpBC,GACAC,GACAC,GACA;AACM,QAAAC,IAAU,MAAMC,EAA0BJ,GAAQ;AAAA,IACtD,GAAGE;AAAA,IACH,MAAM,MAAMD;AAAA,EAAA,CACb;AACD,MAAI,CAACE,EAAQ;AACL,UAAA,IAAIE,EAAkCF,CAAO;AACrD,SAAOA,EAAQ;AACjB;AAsBsB,eAAAG,EACpBN,GACAO,GACAL,GACiB;AACjB,QAAM,EAAE,MAAAD,GAAM,QAAAO,EAAO,IAAI,MAAMD;AAC/B,eAAMH,EAA0BJ,GAAQ;AAAA,IACtC,GAAGE;AAAA,IACH,MAAAD;AAAA,EAAA,CACD,GACMO;AACT;AAYgB,SAAAC,EACdT,GACAU,GACAC,GACuC;AACvC,MAAIC;AACE,QAAAC,IAAeC,EAAWd,CAAM;AAStC,MAPIW,MAAmB,SACjBD,EAAiBC,CAAc,MAAaC,IAAAD,KACvCE,EAAa,YAAY,UAE9BH,EAAiBG,EAAa,OAAO,UAAaA,EAAa,UAGjED,MAAY,QAAW;AACnB,UAAAG,IAASC,EAAUhB,CAAM;AAC/B,IAAIe,KAAA,QAAAA,EAAQ,MAAM,MAAML,EAAiBK,KAAA,gBAAAA,EAAQ,MAAM,EAAE,MACvDH,IAAUG,EAAO,MAAM;AAAA,EAC3B;AAII,MADAH,MAAY,WAAqBA,IAAO,WACxC,CAACF,EAAiBE,CAAO;AAC3B,UAAM,IAAIK;AAAA,MACRL;AAAA,MACA,OAAO,KAAKF,CAAgB,EAAE,IAAI,MAAM;AAAA,IAAA;AAG5C,SAAO,EAAE,SAAAE,GAAS,SAASF,EAAiBE,CAAO,EAAG;AACxD;"}