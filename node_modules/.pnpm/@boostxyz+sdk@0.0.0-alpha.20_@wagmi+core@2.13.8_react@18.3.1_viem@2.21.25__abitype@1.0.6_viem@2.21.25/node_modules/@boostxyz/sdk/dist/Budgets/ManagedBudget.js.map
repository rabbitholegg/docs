{"version":3,"file":"ManagedBudget.js","sources":["../../src/Budgets/ManagedBudget.ts"],"sourcesContent":["import {\n  managedBudgetAbi,\n  readManagedBudgetAvailable,\n  readManagedBudgetDistributed,\n  readManagedBudgetHasAllRoles,\n  readManagedBudgetHasAnyRole,\n  readManagedBudgetIsAuthorized,\n  readManagedBudgetOwner,\n  readManagedBudgetRolesOf,\n  readManagedBudgetTotal,\n  simulateManagedBudgetAllocate,\n  simulateManagedBudgetClawback,\n  simulateManagedBudgetDisburse,\n  simulateManagedBudgetDisburseBatch,\n  simulateManagedBudgetGrantRoles,\n  simulateManagedBudgetRevokeRoles,\n  simulateManagedBudgetSetAuthorized,\n  writeManagedBudgetAllocate,\n  writeManagedBudgetClawback,\n  writeManagedBudgetDisburse,\n  writeManagedBudgetDisburseBatch,\n  writeManagedBudgetGrantRoles,\n  writeManagedBudgetRevokeRoles,\n  writeManagedBudgetSetAuthorized,\n} from '@boostxyz/evm';\nimport { bytecode } from '@boostxyz/evm/artifacts/contracts/budgets/ManagedBudget.sol/ManagedBudget.json';\nimport { getAccount } from '@wagmi/core';\nimport {\n  type Address,\n  type ContractEventName,\n  type Hex,\n  encodeAbiParameters,\n  parseAbiParameters,\n  zeroAddress,\n} from 'viem';\nimport { ManagedBudget as ManagedBudgetBases } from '../../dist/deployments.json';\nimport type {\n  DeployableOptions,\n  GenericDeployableParams,\n} from '../Deployable/Deployable';\nimport { DeployableTarget } from '../Deployable/DeployableTarget';\nimport { DeployableTargetWithRBAC } from '../Deployable/DeployableTargetWithRBAC';\nimport {\n  DeployableUnknownOwnerProvidedError,\n  UnknownTransferPayloadSupplied,\n} from '../errors';\nimport {\n  type ERC1155TransferPayload,\n  type FungibleTransferPayload,\n  prepareERC1155Transfer,\n  prepareFungibleTransfer,\n} from '../transfers';\nimport {\n  type GenericLog,\n  type ReadParams,\n  RegistryType,\n  type WriteParams,\n} from '../utils';\nexport { managedBudgetAbi };\nexport type { ERC1155TransferPayload, FungibleTransferPayload };\n\n/**\n * The object representation of a `ManagedBudgetPayload.InitPayload`\n *\n * @export\n * @interface ManagedBudgetPayload\n * @typedef {ManagedBudgetPayload}\n */\nexport interface ManagedBudgetPayload {\n  /**\n   * The budget's owner\n   *\n   * @type {Address}\n   */\n  owner: Address;\n  /**\n   * List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.\n   *\n   * @type {Address[]}\n   */\n  authorized: Address[];\n  /**\n   * List of roles to assign to the corresponding account by index.\n   *\n   * @type {ManagedBudgetRoles[]}\n   */\n  roles: ManagedBudgetRoles[];\n}\n\n/**\n *  Enum representing available roles for use in the `ManagedBudget`.\n * `MANAGER` can disburse funds.\n * `ADMIN` can additionally manage authorized users on the budget.\n *\n * @export\n * @type {{ readonly MANAGER: 1n; readonly ADMIN_ROLE: 2n; }}\n * @enum {bigint}\n */\nexport enum ManagedBudgetRoles {\n  //@ts-expect-error ts doesn't like bigint enum values\n  MANAGER = 1n,\n  //@ts-expect-error ts doesn't like bigint enum values\n  ADMIN = 2n,\n}\n\n/**\n * A generic `viem.Log` event with support for `ManagedBudget` event types.\n *\n * @export\n * @typedef {ManagedBudgetLog}\n * @template {ContractEventName<typeof managedBudgetAbi>} [event=ContractEventName<\n *     typeof managedBudgetAbi\n *   >]\n */\nexport type ManagedBudgetLog<\n  event extends ContractEventName<typeof managedBudgetAbi> = ContractEventName<\n    typeof managedBudgetAbi\n  >,\n> = GenericLog<typeof managedBudgetAbi, event>;\n\n/**\n * Typeguard to determine if a transfer payload is a Fungible Transfer\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {transfer is FungibleTransferPayload}\n */\nexport function isFungibleTransfer(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n): transfer is FungibleTransferPayload {\n  return (transfer as ERC1155TransferPayload).tokenId === undefined;\n}\n\n/**\n * Typeguard to determine if a transfer payload is an ERC1155 Transfer\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {transfer is ERC1155TransferPayload}\n */\nexport function isERC1155TransferPayload(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n): transfer is ERC1155TransferPayload {\n  return (transfer as ERC1155TransferPayload).tokenId !== undefined;\n}\n\n/**\n * Given either a Fungible transfer, or ERC1155 transfer, will properly encode parameters for transfers, claims, disbursements, allocations, etc.\n *\n * @export\n * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n * @returns {Hex}\n * @throws {@link UnknownTransferPayloadSupplied}\n */\nexport function prepareTransfer(\n  transfer: FungibleTransferPayload | ERC1155TransferPayload,\n) {\n  if (isFungibleTransfer(transfer)) {\n    return prepareFungibleTransfer(transfer);\n  }\n  if (isERC1155TransferPayload(transfer)) {\n    return prepareERC1155Transfer(transfer);\n  }\n  throw new UnknownTransferPayloadSupplied(transfer);\n}\n\n/**\n * A minimal budget implementation that simply holds and distributes tokens (ERC20-like and native)\n * This type of budget supports ETH, ERC20, and ERC1155 assets only\n *\n * @export\n * @class ManagedBudget\n * @typedef {ManagedBudget}\n * @extends {DeployableTargetWithRBAC<ManagedBudgetPayload>}\n */\nexport class ManagedBudget extends DeployableTargetWithRBAC<\n  ManagedBudgetPayload,\n  typeof managedBudgetAbi\n> {\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @readonly\n   * @type {*}\n   */\n  public override readonly abi = managedBudgetAbi;\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {Record<number, Address>}\n   */\n  public static override bases: Record<number, Address> = {\n    ...(ManagedBudgetBases as Record<number, Address>),\n  };\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @static\n   * @type {RegistryType}\n   */\n  public static override registryType: RegistryType = RegistryType.BUDGET;\n\n  /**\n   *  Allocates assets to the budget.\n   *  The caller must have already approved the contract to transfer the asset\n   *  If the asset transfer fails, the allocation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the allocation was successful\n   */\n  public async allocate(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'allocate'>,\n  ) {\n    return await this.awaitResult(this.allocateRaw(transfer, params));\n  }\n\n  /**\n   *  Allocates assets to the budget.\n   *  The caller must have already approved the contract to transfer the asset\n   *  If the asset transfer fails, the allocation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the allocation was successful\n   */\n  public async allocateRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'allocate'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetAllocate(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetAllocate(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Clawbacks assets from the budget.\n   * Only the owner can directly clawback assets from the budget\n   * If the amount is zero, the entire balance of the asset will be transferred to the receiver\n   * If the asset transfer fails, the reclamation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the request was successful\n   */\n  public async clawback(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'clawback'>,\n  ) {\n    return await this.awaitResult(this.clawbackRaw(transfer, params));\n  }\n\n  /**\n   * Clawbacks assets from the budget.\n   * Only the owner can directly clawback assets from the budget\n   * If the amount is zero, the entire balance of the asset will be transferred to the receiver\n   * If the asset transfer fails, the reclamation will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the request was successful\n   */\n  public async clawbackRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'clawback'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetClawback(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetClawback(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Disburses assets from the budget to a single recipient\n   * If the asset transfer fails, the disbursement will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if the disbursement was successful\n   */\n  public async disburse(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburse'>,\n  ) {\n    return await this.awaitResult(this.disburseRaw(transfer, params));\n  }\n\n  /**\n   * Disburses assets from the budget to a single recipient\n   * If the asset transfer fails, the disbursement will revert\n   *\n   * @public\n   * @async\n   * @param {(FungibleTransferPayload | ERC1155TransferPayload)} transfer\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if the disbursement was successful\n   */\n  public async disburseRaw(\n    transfer: FungibleTransferPayload | ERC1155TransferPayload,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburse'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetDisburse(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [prepareTransfer(transfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetDisburse(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Disburses assets from the budget to multiple recipients\n   *\n   * @public\n   * @async\n   * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers\n   * @param {?WriteParams} [params]\n   * @returns {Promise<boolean>} - True if all disbursements were successful\n   */\n  public async disburseBatch(\n    transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>,\n  ) {\n    return await this.awaitResult(this.disburseBatchRaw(transfers, params));\n  }\n\n  /**\n   * Disburses assets from the budget to multiple recipients\n   *\n   * @public\n   * @async\n   * @param {Array<FungibleTransferPayload | ERC1155TransferPayload>} transfers\n   * @param {?WriteParams} [params]\n   * @returns {Promise<{ hash: `0x${string}`; result: boolean; }>} - True if all disbursements were successful\n   */\n  public async disburseBatchRaw(\n    transfers: Array<FungibleTransferPayload | ERC1155TransferPayload>,\n    params?: WriteParams<typeof managedBudgetAbi, 'disburseBatch'>,\n  ) {\n    const { request, result } = await simulateManagedBudgetDisburseBatch(\n      this._config,\n      {\n        address: this.assertValidAddress(),\n        args: [transfers.map(prepareTransfer)],\n        ...this.optionallyAttachAccount(),\n        // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n        ...(params as any),\n      },\n    );\n    const hash = await writeManagedBudgetDisburseBatch(this._config, request);\n    return { hash, result };\n  }\n\n  /**\n   * Get the owner of the budget\n   *\n   * @public\n   * @param {?ReadParams} [params]\n   * @returns {Promise<Address>}\n   */\n  public owner(params?: ReadParams<typeof managedBudgetAbi, 'owner'>) {\n    return readManagedBudgetOwner(this._config, {\n      address: this.assertValidAddress(),\n      args: [],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the total amount of assets allocated to the budget, including any that have been distributed\n   * If a tokenId is provided, get the total amount of ERC1155 assets allocated to the budget, including any that have been distributed\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"] - The address of the asset\n   * @param {?(bigint | undefined)} [tokenId] - The ID of the token\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The total amount of assets\n   */\n  public total(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'total'>,\n  ) {\n    return readManagedBudgetTotal(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the amount of assets available for distribution from the budget.\n   * If a tokenId is provided, get the amount of ERC1155 assets available for distribution from the budget\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"]\n   * @param {?(bigint | undefined)} [tokenId]\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The amount of assets available\n   */\n  public available(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'available'>,\n  ) {\n    return readManagedBudgetAvailable(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * Get the amount of assets that have been distributed from the budget.\n   * If a tokenId is provided, get the amount of ERC1155 assets that have been distributed from the budget\n   *\n   * @public\n   * @param {Address} [asset=\"0x0000000000000000000000000000000000000000\"]\n   * @param {?(bigint | undefined)} [tokenId]\n   * @param {?ReadParams} [params]\n   * @returns {Promise<bigint>} - The amount of assets distributed\n   */\n  public distributed(\n    asset: Address = zeroAddress,\n    tokenId?: bigint | undefined,\n    params?: ReadParams<typeof managedBudgetAbi, 'distributed'>,\n  ) {\n    return readManagedBudgetDistributed(this._config, {\n      address: this.assertValidAddress(),\n      args: tokenId ? [asset, tokenId] : [asset],\n      // biome-ignore lint/suspicious/noExplicitAny: Accept any shape of valid wagmi/viem parameters, wagmi does the same thing internally\n      ...(params as any),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @public\n   * @param {?ManagedBudgetPayload} [_payload]\n   * @param {?DeployableOptions} [_options]\n   * @returns {GenericDeployableParams}\n   */\n  public override buildParameters(\n    _payload?: ManagedBudgetPayload,\n    _options?: DeployableOptions,\n  ): GenericDeployableParams {\n    const [payload, options] = this.validateDeploymentConfig(\n      _payload,\n      _options,\n    );\n    if (!payload.owner || payload.owner === zeroAddress) {\n      const owner = options.account\n        ? options.account.address\n        : options.config\n          ? getAccount(options.config).address\n          : this._account?.address;\n      if (owner) {\n        payload.owner = owner;\n      } else {\n        throw new DeployableUnknownOwnerProvidedError();\n      }\n    }\n    return {\n      abi: managedBudgetAbi,\n      bytecode: bytecode as Hex,\n      args: [prepareManagedBudgetPayload(payload)],\n      ...this.optionallyAttachAccount(options.account),\n    };\n  }\n}\n\n/**\n * Given a {@link ManagedBudgetPayload}, properly encode a `ManagedBudget.InitPayload` for use with {@link ManagedBudget} initialization.\n *\n * @param {ManagedBudgetPayload} param0\n * @param {Address} param0.owner - The budget's owner\n * @param {{}} param0.authorized - List of accounts authorized to use the budget. This list should include a Boost core address to interact with the protocol.\n * @param {{}} param0.roles - List of roles to assign to the corresponding account by index.\n * @returns {Hex}\n */\nexport const prepareManagedBudgetPayload = ({\n  owner,\n  authorized,\n  roles,\n}: ManagedBudgetPayload) => {\n  return encodeAbiParameters(\n    parseAbiParameters([\n      'ManagedBudgetPayload payload',\n      'struct ManagedBudgetPayload { address owner; address[] authorized; uint256[] roles; }',\n    ]),\n    [{ owner, authorized, roles: roles as unknown as Array<bigint> }],\n  );\n};\n"],"names":["ManagedBudgetRoles","isFungibleTransfer","transfer","isERC1155TransferPayload","prepareTransfer","prepareFungibleTransfer","prepareERC1155Transfer","UnknownTransferPayloadSupplied","_ManagedBudget","DeployableTargetWithRBAC","managedBudgetAbi","params","request","result","simulateManagedBudgetAllocate","writeManagedBudgetAllocate","simulateManagedBudgetClawback","writeManagedBudgetClawback","simulateManagedBudgetDisburse","writeManagedBudgetDisburse","transfers","simulateManagedBudgetDisburseBatch","writeManagedBudgetDisburseBatch","readManagedBudgetOwner","asset","zeroAddress","tokenId","readManagedBudgetTotal","readManagedBudgetAvailable","readManagedBudgetDistributed","_payload","_options","payload","options","owner","getAccount","_a","DeployableUnknownOwnerProvidedError","bytecode","prepareManagedBudgetPayload","ManagedBudgetBases","RegistryType","ManagedBudget","authorized","roles","encodeAbiParameters","parseAbiParameters"],"mappings":";;;;;;;;;AAkGY,IAAAA,sBAAAA,OAEVA,EAAAA,EAAA,UAAU,EAAV,IAAA,WAEAA,EAAAA,EAAA,QAAQ,EAAR,IAAA,SAJUA,IAAAA,KAAA,CAAA,CAAA;AA6BL,SAASC,EACdC,GACqC;AACrC,SAAQA,EAAoC,YAAY;AAC1D;AASO,SAASC,EACdD,GACoC;AACpC,SAAQA,EAAoC,YAAY;AAC1D;AAUO,SAASE,EACdF,GACA;AACI,MAAAD,EAAmBC,CAAQ;AAC7B,WAAOG,EAAwBH,CAAQ;AAErC,MAAAC,EAAyBD,CAAQ;AACnC,WAAOI,EAAuBJ,CAAQ;AAElC,QAAA,IAAIK,EAA+BL,CAAQ;AACnD;AAWO,MAAMM,IAAN,MAAMA,UAAsBC,EAGjC;AAAA,EAHK,cAAA;AAAA,UAAA,GAAA,SAAA,GAWL,KAAyB,MAAMC;AAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+B/B,MAAa,SACXR,GACAS,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,YAAYT,GAAUS,CAAM,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAa,YACXT,GACAS,GACA;AACA,UAAM,EAAE,SAAAC,GAAS,QAAAC,EAAO,IAAI,MAAMC;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACV,EAAgBF,CAAQ,CAAC;AAAA,QAChC,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIS;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMI,EAA2B,KAAK,SAASH,CAAO,GACpD,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,SACXX,GACAS,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,YAAYT,GAAUS,CAAM,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,YACXT,GACAS,GACA;AACA,UAAM,EAAE,SAAAC,GAAS,QAAAC,EAAO,IAAI,MAAMG;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACZ,EAAgBF,CAAQ,CAAC;AAAA,QAChC,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIS;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMM,EAA2B,KAAK,SAASL,CAAO,GACpD,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAa,SACXX,GACAS,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,YAAYT,GAAUS,CAAM,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAa,YACXT,GACAS,GACA;AACA,UAAM,EAAE,SAAAC,GAAS,QAAAC,EAAO,IAAI,MAAMK;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACd,EAAgBF,CAAQ,CAAC;AAAA,QAChC,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIS;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMQ,EAA2B,KAAK,SAASP,CAAO,GACpD,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,cACXO,GACAT,GACA;AACA,WAAO,MAAM,KAAK,YAAY,KAAK,iBAAiBS,GAAWT,CAAM,CAAC;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,iBACXS,GACAT,GACA;AACA,UAAM,EAAE,SAAAC,GAAS,QAAAC,EAAO,IAAI,MAAMQ;AAAAA,MAChC,KAAK;AAAA,MACL;AAAA,QACE,SAAS,KAAK,mBAAmB;AAAA,QACjC,MAAM,CAACD,EAAU,IAAIhB,CAAe,CAAC;AAAA,QACrC,GAAG,KAAK,wBAAwB;AAAA;AAAA,QAEhC,GAAIO;AAAA,MACN;AAAA,IAAA;AAGK,WAAA,EAAE,MADI,MAAMW,EAAgC,KAAK,SAASV,CAAO,GACzD,QAAAC;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,MAAMF,GAAuD;AAC3D,WAAAY,EAAuB,KAAK,SAAS;AAAA,MAC1C,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAM,CAAC;AAAA;AAAA,MAEP,GAAIZ;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,MACLa,IAAiBC,GACjBC,GACAf,GACA;AACO,WAAAgB,EAAuB,KAAK,SAAS;AAAA,MAC1C,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAMD,IAAU,CAACF,GAAOE,CAAO,IAAI,CAACF,CAAK;AAAA;AAAA,MAEzC,GAAIb;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,UACLa,IAAiBC,GACjBC,GACAf,GACA;AACO,WAAAiB,EAA2B,KAAK,SAAS;AAAA,MAC9C,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAMF,IAAU,CAACF,GAAOE,CAAO,IAAI,CAACF,CAAK;AAAA;AAAA,MAEzC,GAAIb;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,YACLa,IAAiBC,GACjBC,GACAf,GACA;AACO,WAAAkB,EAA6B,KAAK,SAAS;AAAA,MAChD,SAAS,KAAK,mBAAmB;AAAA,MACjC,MAAMH,IAAU,CAACF,GAAOE,CAAO,IAAI,CAACF,CAAK;AAAA;AAAA,MAEzC,GAAIb;AAAA,IAAA,CACL;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUgB,gBACdmB,GACAC,GACyB;;AACzB,UAAM,CAACC,GAASC,CAAO,IAAI,KAAK;AAAA,MAC9BH;AAAA,MACAC;AAAA,IAAA;AAEF,QAAI,CAACC,EAAQ,SAASA,EAAQ,UAAUP,GAAa;AACnD,YAAMS,IAAQD,EAAQ,UAClBA,EAAQ,QAAQ,UAChBA,EAAQ,SACNE,EAAWF,EAAQ,MAAM,EAAE,WAC3BG,IAAA,KAAK,aAAL,gBAAAA,EAAe;AACrB,UAAIF;AACF,QAAAF,EAAQ,QAAQE;AAAA;AAEhB,cAAM,IAAIG,EAAoC;AAAA,IAElD;AACO,WAAA;AAAA,MACL,KAAK3B;AAAAA,MACL,UAAA4B;AAAA,MACA,MAAM,CAACC,EAA4BP,CAAO,CAAC;AAAA,MAC3C,GAAG,KAAK,wBAAwBC,EAAQ,OAAO;AAAA,IAAA;AAAA,EAEnD;AACF;AA5TEzB,EAAuB,QAAiC;AAAA,EACtD,GAAIgC;AAAA,GASNhC,EAAuB,eAA6BiC,EAAa;AA7B5D,IAAMC,IAANlC;AA0VA,MAAM+B,IAA8B,CAAC;AAAA,EAC1C,OAAAL;AAAA,EACA,YAAAS;AAAA,EACA,OAAAC;AACF,MACSC;AAAA,EACLC,EAAmB;AAAA,IACjB;AAAA,IACA;AAAA,EAAA,CACD;AAAA,EACD,CAAC,EAAE,OAAAZ,GAAO,YAAAS,GAAY,OAAAC,GAA0C;AAAA;"}